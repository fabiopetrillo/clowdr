import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  bigint: any;
  json: any;
  jsonb: any;
  timestamptz: any;
  uuid: any;
};

/** columns and relationships of "Attendee" */
export type Attendee = {
  readonly __typename?: 'Attendee';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentPeople: ReadonlyArray<ContentPerson>;
  /** An aggregated array relationship */
  readonly contentPeople_aggregate: ContentPerson_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly displayName: Scalars['String'];
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<EventPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: EventPerson_Aggregate;
  /** An array relationship */
  readonly groupAttendees: ReadonlyArray<GroupAttendee>;
  /** An aggregated array relationship */
  readonly groupAttendees_aggregate: GroupAttendee_Aggregate;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly invitation?: Maybe<Invitation>;
  /** A computed field, executes function "hasbeeninvited" */
  readonly inviteSent?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  readonly profile?: Maybe<AttendeeProfile>;
  /** An array relationship */
  readonly roomParticipants: ReadonlyArray<RoomParticipant>;
  /** An aggregated array relationship */
  readonly roomParticipants_aggregate: RoomParticipant_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly userId?: Maybe<Scalars['String']>;
};


/** columns and relationships of "Attendee" */
export type AttendeeContentPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeContentPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeGroupAttendeesArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeGroupAttendees_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeRoomParticipantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeRoomParticipants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};

/** columns and relationships of "AttendeeProfile" */
export type AttendeeProfile = {
  readonly __typename?: 'AttendeeProfile';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at: Scalars['timestamptz'];
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited: Scalars['Boolean'];
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at: Scalars['timestamptz'];
  readonly website?: Maybe<Scalars['String']>;
};


/** columns and relationships of "AttendeeProfile" */
export type AttendeeProfileBadgesArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "AttendeeProfile" */
export type AttendeeProfilePronounsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "AttendeeProfile" */
export type AttendeeProfile_Aggregate = {
  readonly __typename?: 'AttendeeProfile_aggregate';
  readonly aggregate?: Maybe<AttendeeProfile_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<AttendeeProfile>;
};

/** aggregate fields of "AttendeeProfile" */
export type AttendeeProfile_Aggregate_Fields = {
  readonly __typename?: 'AttendeeProfile_aggregate_fields';
  readonly avg?: Maybe<AttendeeProfile_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<AttendeeProfile_Max_Fields>;
  readonly min?: Maybe<AttendeeProfile_Min_Fields>;
  readonly stddev?: Maybe<AttendeeProfile_Stddev_Fields>;
  readonly stddev_pop?: Maybe<AttendeeProfile_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<AttendeeProfile_Stddev_Samp_Fields>;
  readonly sum?: Maybe<AttendeeProfile_Sum_Fields>;
  readonly var_pop?: Maybe<AttendeeProfile_Var_Pop_Fields>;
  readonly var_samp?: Maybe<AttendeeProfile_Var_Samp_Fields>;
  readonly variance?: Maybe<AttendeeProfile_Variance_Fields>;
};


/** aggregate fields of "AttendeeProfile" */
export type AttendeeProfile_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "AttendeeProfile" */
export type AttendeeProfile_Aggregate_Order_By = {
  readonly avg?: Maybe<AttendeeProfile_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<AttendeeProfile_Max_Order_By>;
  readonly min?: Maybe<AttendeeProfile_Min_Order_By>;
  readonly stddev?: Maybe<AttendeeProfile_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<AttendeeProfile_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<AttendeeProfile_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<AttendeeProfile_Sum_Order_By>;
  readonly var_pop?: Maybe<AttendeeProfile_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<AttendeeProfile_Var_Samp_Order_By>;
  readonly variance?: Maybe<AttendeeProfile_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AttendeeProfile_Append_Input = {
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "AttendeeProfile" */
export type AttendeeProfile_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<AttendeeProfile_Insert_Input>;
  readonly on_conflict?: Maybe<AttendeeProfile_On_Conflict>;
};

/** aggregate avg on columns */
export type AttendeeProfile_Avg_Fields = {
  readonly __typename?: 'AttendeeProfile_avg_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Avg_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "AttendeeProfile". All fields are combined with a logical 'AND'. */
export type AttendeeProfile_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<AttendeeProfile_Bool_Exp>>>;
  readonly _not?: Maybe<AttendeeProfile_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<AttendeeProfile_Bool_Exp>>>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly affiliationURL?: Maybe<String_Comparison_Exp>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly badges?: Maybe<Jsonb_Comparison_Exp>;
  readonly bio?: Maybe<String_Comparison_Exp>;
  readonly country?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly github?: Maybe<String_Comparison_Exp>;
  readonly hasBeenEdited?: Maybe<Boolean_Comparison_Exp>;
  readonly photoS3BucketName?: Maybe<String_Comparison_Exp>;
  readonly photoS3BucketRegion?: Maybe<String_Comparison_Exp>;
  readonly photoS3ObjectName?: Maybe<String_Comparison_Exp>;
  readonly photoURL_350x350?: Maybe<String_Comparison_Exp>;
  readonly photoURL_50x50?: Maybe<String_Comparison_Exp>;
  readonly pronouns?: Maybe<Jsonb_Comparison_Exp>;
  readonly realName?: Maybe<String_Comparison_Exp>;
  readonly timezoneUTCOffset?: Maybe<Float_Comparison_Exp>;
  readonly twitter?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly website?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "AttendeeProfile" */
export enum AttendeeProfile_Constraint {
  /** unique or primary key constraint */
  AttendeeProfileAttendeeIdKey = 'AttendeeProfile_attendeeId_key',
  /** unique or primary key constraint */
  AttendeeProfilePkey = 'AttendeeProfile_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AttendeeProfile_Delete_At_Path_Input = {
  readonly badges?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly pronouns?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AttendeeProfile_Delete_Elem_Input = {
  readonly badges?: Maybe<Scalars['Int']>;
  readonly pronouns?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AttendeeProfile_Delete_Key_Input = {
  readonly badges?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "AttendeeProfile" */
export type AttendeeProfile_Inc_Input = {
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** input type for inserting data into table "AttendeeProfile" */
export type AttendeeProfile_Insert_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited?: Maybe<Scalars['Boolean']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type AttendeeProfile_Max_Fields = {
  readonly __typename?: 'AttendeeProfile_max_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Max_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly realName?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type AttendeeProfile_Min_Fields = {
  readonly __typename?: 'AttendeeProfile_min_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Min_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly realName?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** response of any mutation on the table "AttendeeProfile" */
export type AttendeeProfile_Mutation_Response = {
  readonly __typename?: 'AttendeeProfile_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<AttendeeProfile>;
};

/** input type for inserting object relation for remote table "AttendeeProfile" */
export type AttendeeProfile_Obj_Rel_Insert_Input = {
  readonly data: AttendeeProfile_Insert_Input;
  readonly on_conflict?: Maybe<AttendeeProfile_On_Conflict>;
};

/** on conflict condition type for table "AttendeeProfile" */
export type AttendeeProfile_On_Conflict = {
  readonly constraint: AttendeeProfile_Constraint;
  readonly update_columns: ReadonlyArray<AttendeeProfile_Update_Column>;
  readonly where?: Maybe<AttendeeProfile_Bool_Exp>;
};

/** ordering options when selecting data from "AttendeeProfile" */
export type AttendeeProfile_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly badges?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly hasBeenEdited?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly pronouns?: Maybe<Order_By>;
  readonly realName?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** primary key columns input for table: "AttendeeProfile" */
export type AttendeeProfile_Pk_Columns_Input = {
  readonly attendeeId: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AttendeeProfile_Prepend_Input = {
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "AttendeeProfile" */
export enum AttendeeProfile_Select_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AffiliationUrl = 'affiliationURL',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  Badges = 'badges',
  /** column name */
  Bio = 'bio',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Github = 'github',
  /** column name */
  HasBeenEdited = 'hasBeenEdited',
  /** column name */
  PhotoS3BucketName = 'photoS3BucketName',
  /** column name */
  PhotoS3BucketRegion = 'photoS3BucketRegion',
  /** column name */
  PhotoS3ObjectName = 'photoS3ObjectName',
  /** column name */
  PhotoUrl_350x350 = 'photoURL_350x350',
  /** column name */
  PhotoUrl_50x50 = 'photoURL_50x50',
  /** column name */
  Pronouns = 'pronouns',
  /** column name */
  RealName = 'realName',
  /** column name */
  TimezoneUtcOffset = 'timezoneUTCOffset',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

/** input type for updating data in table "AttendeeProfile" */
export type AttendeeProfile_Set_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited?: Maybe<Scalars['Boolean']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type AttendeeProfile_Stddev_Fields = {
  readonly __typename?: 'AttendeeProfile_stddev_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Stddev_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type AttendeeProfile_Stddev_Pop_Fields = {
  readonly __typename?: 'AttendeeProfile_stddev_pop_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Stddev_Pop_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type AttendeeProfile_Stddev_Samp_Fields = {
  readonly __typename?: 'AttendeeProfile_stddev_samp_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Stddev_Samp_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type AttendeeProfile_Sum_Fields = {
  readonly __typename?: 'AttendeeProfile_sum_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by sum() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Sum_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** update columns of table "AttendeeProfile" */
export enum AttendeeProfile_Update_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AffiliationUrl = 'affiliationURL',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  Badges = 'badges',
  /** column name */
  Bio = 'bio',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Github = 'github',
  /** column name */
  HasBeenEdited = 'hasBeenEdited',
  /** column name */
  PhotoS3BucketName = 'photoS3BucketName',
  /** column name */
  PhotoS3BucketRegion = 'photoS3BucketRegion',
  /** column name */
  PhotoS3ObjectName = 'photoS3ObjectName',
  /** column name */
  PhotoUrl_350x350 = 'photoURL_350x350',
  /** column name */
  PhotoUrl_50x50 = 'photoURL_50x50',
  /** column name */
  Pronouns = 'pronouns',
  /** column name */
  RealName = 'realName',
  /** column name */
  TimezoneUtcOffset = 'timezoneUTCOffset',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

/** aggregate var_pop on columns */
export type AttendeeProfile_Var_Pop_Fields = {
  readonly __typename?: 'AttendeeProfile_var_pop_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Var_Pop_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type AttendeeProfile_Var_Samp_Fields = {
  readonly __typename?: 'AttendeeProfile_var_samp_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Var_Samp_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type AttendeeProfile_Variance_Fields = {
  readonly __typename?: 'AttendeeProfile_variance_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Variance_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregated selection of "Attendee" */
export type Attendee_Aggregate = {
  readonly __typename?: 'Attendee_aggregate';
  readonly aggregate?: Maybe<Attendee_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Attendee>;
};

/** aggregate fields of "Attendee" */
export type Attendee_Aggregate_Fields = {
  readonly __typename?: 'Attendee_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Attendee_Max_Fields>;
  readonly min?: Maybe<Attendee_Min_Fields>;
};


/** aggregate fields of "Attendee" */
export type Attendee_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Attendee" */
export type Attendee_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Attendee_Max_Order_By>;
  readonly min?: Maybe<Attendee_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Attendee" */
export type Attendee_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Attendee_Insert_Input>;
  readonly on_conflict?: Maybe<Attendee_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Attendee". All fields are combined with a logical 'AND'. */
export type Attendee_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Attendee_Bool_Exp>>>;
  readonly _not?: Maybe<Attendee_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Attendee_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentPeople?: Maybe<ContentPerson_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly displayName?: Maybe<String_Comparison_Exp>;
  readonly eventPeople?: Maybe<EventPerson_Bool_Exp>;
  readonly groupAttendees?: Maybe<GroupAttendee_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly invitation?: Maybe<Invitation_Bool_Exp>;
  readonly profile?: Maybe<AttendeeProfile_Bool_Exp>;
  readonly roomParticipants?: Maybe<RoomParticipant_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Attendee" */
export enum Attendee_Constraint {
  /** unique or primary key constraint */
  AttendeeConferenceIdUserIdKey = 'Attendee_conferenceId_userId_key',
  /** unique or primary key constraint */
  AttendeePkey = 'Attendee_pkey'
}

/** input type for inserting data into table "Attendee" */
export type Attendee_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentPeople?: Maybe<ContentPerson_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly eventPeople?: Maybe<EventPerson_Arr_Rel_Insert_Input>;
  readonly groupAttendees?: Maybe<GroupAttendee_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitation?: Maybe<Invitation_Obj_Rel_Insert_Input>;
  readonly profile?: Maybe<AttendeeProfile_Obj_Rel_Insert_Input>;
  readonly roomParticipants?: Maybe<RoomParticipant_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Attendee_Max_Fields = {
  readonly __typename?: 'Attendee_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Attendee" */
export type Attendee_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Attendee_Min_Fields = {
  readonly __typename?: 'Attendee_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Attendee" */
export type Attendee_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "Attendee" */
export type Attendee_Mutation_Response = {
  readonly __typename?: 'Attendee_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Attendee>;
};

/** input type for inserting object relation for remote table "Attendee" */
export type Attendee_Obj_Rel_Insert_Input = {
  readonly data: Attendee_Insert_Input;
  readonly on_conflict?: Maybe<Attendee_On_Conflict>;
};

/** on conflict condition type for table "Attendee" */
export type Attendee_On_Conflict = {
  readonly constraint: Attendee_Constraint;
  readonly update_columns: ReadonlyArray<Attendee_Update_Column>;
  readonly where?: Maybe<Attendee_Bool_Exp>;
};

/** ordering options when selecting data from "Attendee" */
export type Attendee_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentPeople_aggregate?: Maybe<ContentPerson_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<EventPerson_Aggregate_Order_By>;
  readonly groupAttendees_aggregate?: Maybe<GroupAttendee_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitation?: Maybe<Invitation_Order_By>;
  readonly profile?: Maybe<AttendeeProfile_Order_By>;
  readonly roomParticipants_aggregate?: Maybe<RoomParticipant_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "Attendee" */
export type Attendee_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Attendee" */
export enum Attendee_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "Attendee" */
export type Attendee_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** update columns of table "Attendee" */
export enum Attendee_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** expression to compare columns of type Boolean. All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Boolean']>;
  readonly _gt?: Maybe<Scalars['Boolean']>;
  readonly _gte?: Maybe<Scalars['Boolean']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Boolean']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Boolean']>;
  readonly _lte?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Scalars['Boolean']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Boolean']>>;
};

/** columns and relationships of "Broadcast" */
export type Broadcast = {
  readonly __typename?: 'Broadcast';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly to: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Broadcast" */
export type BroadcastDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItem = {
  readonly __typename?: 'BroadcastContentItem';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentItem?: Maybe<ContentItem>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event?: Maybe<Event>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly executedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** An aggregated array relationship */
  readonly executedTransitions_aggregate: ExecutedTransitions_Aggregate;
  /** An array relationship */
  readonly fallbackForTransitions: ReadonlyArray<Transitions>;
  /** An aggregated array relationship */
  readonly fallbackForTransitions_aggregate: Transitions_Aggregate;
  readonly id: Scalars['uuid'];
  readonly input: Scalars['jsonb'];
  /** An object relationship */
  readonly inputType: InputType;
  readonly inputTypeName: InputType_Enum;
  /** An array relationship */
  readonly transitions: ReadonlyArray<Transitions>;
  /** An aggregated array relationship */
  readonly transitions_aggregate: Transitions_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemFallbackForTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemFallbackForTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemInputArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};

/** aggregated selection of "BroadcastContentItem" */
export type BroadcastContentItem_Aggregate = {
  readonly __typename?: 'BroadcastContentItem_aggregate';
  readonly aggregate?: Maybe<BroadcastContentItem_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<BroadcastContentItem>;
};

/** aggregate fields of "BroadcastContentItem" */
export type BroadcastContentItem_Aggregate_Fields = {
  readonly __typename?: 'BroadcastContentItem_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<BroadcastContentItem_Max_Fields>;
  readonly min?: Maybe<BroadcastContentItem_Min_Fields>;
};


/** aggregate fields of "BroadcastContentItem" */
export type BroadcastContentItem_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "BroadcastContentItem" */
export type BroadcastContentItem_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<BroadcastContentItem_Max_Order_By>;
  readonly min?: Maybe<BroadcastContentItem_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type BroadcastContentItem_Append_Input = {
  readonly input?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "BroadcastContentItem" */
export type BroadcastContentItem_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<BroadcastContentItem_Insert_Input>;
  readonly on_conflict?: Maybe<BroadcastContentItem_On_Conflict>;
};

/** Boolean expression to filter rows from the table "BroadcastContentItem". All fields are combined with a logical 'AND'. */
export type BroadcastContentItem_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<BroadcastContentItem_Bool_Exp>>>;
  readonly _not?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<BroadcastContentItem_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItem?: Maybe<ContentItem_Bool_Exp>;
  readonly contentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Bool_Exp>;
  readonly fallbackForTransitions?: Maybe<Transitions_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly input?: Maybe<Jsonb_Comparison_Exp>;
  readonly inputType?: Maybe<InputType_Bool_Exp>;
  readonly inputTypeName?: Maybe<InputType_Enum_Comparison_Exp>;
  readonly transitions?: Maybe<Transitions_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "BroadcastContentItem" */
export enum BroadcastContentItem_Constraint {
  /** unique or primary key constraint */
  BroadcastContentItemContentItemIdKey = 'BroadcastContentItem_contentItemId_key',
  /** unique or primary key constraint */
  BroadcastContentItemEventIdKey = 'BroadcastContentItem_eventId_key',
  /** unique or primary key constraint */
  BroadcastContentItemPkey = 'BroadcastContentItem_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type BroadcastContentItem_Delete_At_Path_Input = {
  readonly input?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type BroadcastContentItem_Delete_Elem_Input = {
  readonly input?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type BroadcastContentItem_Delete_Key_Input = {
  readonly input?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "BroadcastContentItem" */
export type BroadcastContentItem_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItem?: Maybe<ContentItem_Obj_Rel_Insert_Input>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Arr_Rel_Insert_Input>;
  readonly fallbackForTransitions?: Maybe<Transitions_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly input?: Maybe<Scalars['jsonb']>;
  readonly inputType?: Maybe<InputType_Obj_Rel_Insert_Input>;
  readonly inputTypeName?: Maybe<InputType_Enum>;
  readonly transitions?: Maybe<Transitions_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type BroadcastContentItem_Max_Fields = {
  readonly __typename?: 'BroadcastContentItem_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "BroadcastContentItem" */
export type BroadcastContentItem_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type BroadcastContentItem_Min_Fields = {
  readonly __typename?: 'BroadcastContentItem_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "BroadcastContentItem" */
export type BroadcastContentItem_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "BroadcastContentItem" */
export type BroadcastContentItem_Mutation_Response = {
  readonly __typename?: 'BroadcastContentItem_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<BroadcastContentItem>;
};

/** input type for inserting object relation for remote table "BroadcastContentItem" */
export type BroadcastContentItem_Obj_Rel_Insert_Input = {
  readonly data: BroadcastContentItem_Insert_Input;
  readonly on_conflict?: Maybe<BroadcastContentItem_On_Conflict>;
};

/** on conflict condition type for table "BroadcastContentItem" */
export type BroadcastContentItem_On_Conflict = {
  readonly constraint: BroadcastContentItem_Constraint;
  readonly update_columns: ReadonlyArray<BroadcastContentItem_Update_Column>;
  readonly where?: Maybe<BroadcastContentItem_Bool_Exp>;
};

/** ordering options when selecting data from "BroadcastContentItem" */
export type BroadcastContentItem_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItem?: Maybe<ContentItem_Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly executedTransitions_aggregate?: Maybe<ExecutedTransitions_Aggregate_Order_By>;
  readonly fallbackForTransitions_aggregate?: Maybe<Transitions_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly input?: Maybe<Order_By>;
  readonly inputType?: Maybe<InputType_Order_By>;
  readonly inputTypeName?: Maybe<Order_By>;
  readonly transitions_aggregate?: Maybe<Transitions_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "BroadcastContentItem" */
export type BroadcastContentItem_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type BroadcastContentItem_Prepend_Input = {
  readonly input?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "BroadcastContentItem" */
export enum BroadcastContentItem_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  Input = 'input',
  /** column name */
  InputTypeName = 'inputTypeName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "BroadcastContentItem" */
export type BroadcastContentItem_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly input?: Maybe<Scalars['jsonb']>;
  readonly inputTypeName?: Maybe<InputType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "BroadcastContentItem" */
export enum BroadcastContentItem_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  Input = 'input',
  /** column name */
  InputTypeName = 'inputTypeName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "Broadcast" */
export type Broadcast_Aggregate = {
  readonly __typename?: 'Broadcast_aggregate';
  readonly aggregate?: Maybe<Broadcast_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Broadcast>;
};

/** aggregate fields of "Broadcast" */
export type Broadcast_Aggregate_Fields = {
  readonly __typename?: 'Broadcast_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Broadcast_Max_Fields>;
  readonly min?: Maybe<Broadcast_Min_Fields>;
};


/** aggregate fields of "Broadcast" */
export type Broadcast_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Broadcast" */
export type Broadcast_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Broadcast_Max_Order_By>;
  readonly min?: Maybe<Broadcast_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Broadcast_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "Broadcast" */
export type Broadcast_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Broadcast_Insert_Input>;
  readonly on_conflict?: Maybe<Broadcast_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Broadcast". All fields are combined with a logical 'AND'. */
export type Broadcast_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Broadcast_Bool_Exp>>>;
  readonly _not?: Maybe<Broadcast_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Broadcast_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly to?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Broadcast" */
export enum Broadcast_Constraint {
  /** unique or primary key constraint */
  BroadcastPkey = 'Broadcast_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Broadcast_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Broadcast_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Broadcast_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "Broadcast" */
export type Broadcast_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly to?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Broadcast_Max_Fields = {
  readonly __typename?: 'Broadcast_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly to?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Broadcast" */
export type Broadcast_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly to?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Broadcast_Min_Fields = {
  readonly __typename?: 'Broadcast_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly to?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Broadcast" */
export type Broadcast_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly to?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Broadcast" */
export type Broadcast_Mutation_Response = {
  readonly __typename?: 'Broadcast_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Broadcast>;
};

/** input type for inserting object relation for remote table "Broadcast" */
export type Broadcast_Obj_Rel_Insert_Input = {
  readonly data: Broadcast_Insert_Input;
  readonly on_conflict?: Maybe<Broadcast_On_Conflict>;
};

/** on conflict condition type for table "Broadcast" */
export type Broadcast_On_Conflict = {
  readonly constraint: Broadcast_Constraint;
  readonly update_columns: ReadonlyArray<Broadcast_Update_Column>;
  readonly where?: Maybe<Broadcast_Bool_Exp>;
};

/** ordering options when selecting data from "Broadcast" */
export type Broadcast_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly to?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Broadcast" */
export type Broadcast_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Broadcast_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "Broadcast" */
export enum Broadcast_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  To = 'to',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Broadcast" */
export type Broadcast_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly to?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Broadcast" */
export enum Broadcast_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  To = 'to',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "Conference" */
export type Conference = {
  readonly __typename?: 'Conference';
  /** An array relationship */
  readonly attendees: ReadonlyArray<Attendee>;
  /** An aggregated array relationship */
  readonly attendees_aggregate: Attendee_Aggregate;
  /** An array relationship */
  readonly chats: ReadonlyArray<Chat_Chat>;
  /** An aggregated array relationship */
  readonly chats_aggregate: Chat_Chat_Aggregate;
  /** An array relationship */
  readonly configurations: ReadonlyArray<ConferenceConfiguration>;
  /** An aggregated array relationship */
  readonly configurations_aggregate: ConferenceConfiguration_Aggregate;
  /** An array relationship */
  readonly contentGroups: ReadonlyArray<ContentGroup>;
  /** An aggregated array relationship */
  readonly contentGroups_aggregate: ContentGroup_Aggregate;
  /** An array relationship */
  readonly contentPeople: ReadonlyArray<ContentPerson>;
  /** An aggregated array relationship */
  readonly contentPeople_aggregate: ContentPerson_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly createdBy: Scalars['String'];
  /** An object relationship */
  readonly creator: User;
  /** An object relationship */
  readonly demoCode: ConferenceDemoCode;
  readonly demoCodeId: Scalars['uuid'];
  /** An array relationship */
  readonly groups: ReadonlyArray<Group>;
  /** An aggregated array relationship */
  readonly groups_aggregate: Group_Aggregate;
  /** An array relationship */
  readonly hallways: ReadonlyArray<Hallway>;
  /** An aggregated array relationship */
  readonly hallways_aggregate: Hallway_Aggregate;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly originatingDatas: ReadonlyArray<OriginatingData>;
  /** An aggregated array relationship */
  readonly originatingDatas_aggregate: OriginatingData_Aggregate;
  /** An array relationship */
  readonly roles: ReadonlyArray<Role>;
  /** An aggregated array relationship */
  readonly roles_aggregate: Role_Aggregate;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Aggregate;
  readonly shortName: Scalars['String'];
  /** An array relationship */
  readonly shufflePeriods: ReadonlyArray<Room_ShufflePeriod>;
  /** An aggregated array relationship */
  readonly shufflePeriods_aggregate: Room_ShufflePeriod_Aggregate;
  readonly slug: Scalars['String'];
  /** An array relationship */
  readonly tags: ReadonlyArray<Tag>;
  /** An aggregated array relationship */
  readonly tags_aggregate: Tag_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Conference" */
export type ConferenceAttendeesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceAttendees_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceChatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceChats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceConfigurationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceConfigurations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceContentGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceContentGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceContentPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceContentPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceHallwaysArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceHallways_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceOriginatingDatasArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceOriginatingDatas_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceShufflePeriodsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceShufflePeriods_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};

/** columns and relationships of "ConferenceConfiguration" */
export type ConferenceConfiguration = {
  readonly __typename?: 'ConferenceConfiguration';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly key: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly value: Scalars['jsonb'];
};


/** columns and relationships of "ConferenceConfiguration" */
export type ConferenceConfigurationValueArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "ConferenceConfiguration" */
export type ConferenceConfiguration_Aggregate = {
  readonly __typename?: 'ConferenceConfiguration_aggregate';
  readonly aggregate?: Maybe<ConferenceConfiguration_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ConferenceConfiguration>;
};

/** aggregate fields of "ConferenceConfiguration" */
export type ConferenceConfiguration_Aggregate_Fields = {
  readonly __typename?: 'ConferenceConfiguration_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ConferenceConfiguration_Max_Fields>;
  readonly min?: Maybe<ConferenceConfiguration_Min_Fields>;
};


/** aggregate fields of "ConferenceConfiguration" */
export type ConferenceConfiguration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ConferenceConfiguration" */
export type ConferenceConfiguration_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ConferenceConfiguration_Max_Order_By>;
  readonly min?: Maybe<ConferenceConfiguration_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ConferenceConfiguration_Append_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "ConferenceConfiguration" */
export type ConferenceConfiguration_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ConferenceConfiguration_Insert_Input>;
  readonly on_conflict?: Maybe<ConferenceConfiguration_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ConferenceConfiguration". All fields are combined with a logical 'AND'. */
export type ConferenceConfiguration_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ConferenceConfiguration_Bool_Exp>>>;
  readonly _not?: Maybe<ConferenceConfiguration_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ConferenceConfiguration_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly key?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly value?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "ConferenceConfiguration" */
export enum ConferenceConfiguration_Constraint {
  /** unique or primary key constraint */
  ConferenceConfigurationConferenceIdKeyKey = 'ConferenceConfiguration_conferenceId_key_key',
  /** unique or primary key constraint */
  ConferenceConfigurationPkey = 'ConferenceConfiguration_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ConferenceConfiguration_Delete_At_Path_Input = {
  readonly value?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ConferenceConfiguration_Delete_Elem_Input = {
  readonly value?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ConferenceConfiguration_Delete_Key_Input = {
  readonly value?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "ConferenceConfiguration" */
export type ConferenceConfiguration_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type ConferenceConfiguration_Max_Fields = {
  readonly __typename?: 'ConferenceConfiguration_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ConferenceConfiguration" */
export type ConferenceConfiguration_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ConferenceConfiguration_Min_Fields = {
  readonly __typename?: 'ConferenceConfiguration_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ConferenceConfiguration" */
export type ConferenceConfiguration_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ConferenceConfiguration" */
export type ConferenceConfiguration_Mutation_Response = {
  readonly __typename?: 'ConferenceConfiguration_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ConferenceConfiguration>;
};

/** input type for inserting object relation for remote table "ConferenceConfiguration" */
export type ConferenceConfiguration_Obj_Rel_Insert_Input = {
  readonly data: ConferenceConfiguration_Insert_Input;
  readonly on_conflict?: Maybe<ConferenceConfiguration_On_Conflict>;
};

/** on conflict condition type for table "ConferenceConfiguration" */
export type ConferenceConfiguration_On_Conflict = {
  readonly constraint: ConferenceConfiguration_Constraint;
  readonly update_columns: ReadonlyArray<ConferenceConfiguration_Update_Column>;
  readonly where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};

/** ordering options when selecting data from "ConferenceConfiguration" */
export type ConferenceConfiguration_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly value?: Maybe<Order_By>;
};

/** primary key columns input for table: "ConferenceConfiguration" */
export type ConferenceConfiguration_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ConferenceConfiguration_Prepend_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "ConferenceConfiguration" */
export enum ConferenceConfiguration_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "ConferenceConfiguration" */
export type ConferenceConfiguration_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "ConferenceConfiguration" */
export enum ConferenceConfiguration_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

/** columns and relationships of "ConferenceDemoCode" */
export type ConferenceDemoCode = {
  readonly __typename?: 'ConferenceDemoCode';
  /** An object relationship */
  readonly conference?: Maybe<Conference>;
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly usedBy?: Maybe<User>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** aggregated selection of "ConferenceDemoCode" */
export type ConferenceDemoCode_Aggregate = {
  readonly __typename?: 'ConferenceDemoCode_aggregate';
  readonly aggregate?: Maybe<ConferenceDemoCode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ConferenceDemoCode>;
};

/** aggregate fields of "ConferenceDemoCode" */
export type ConferenceDemoCode_Aggregate_Fields = {
  readonly __typename?: 'ConferenceDemoCode_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ConferenceDemoCode_Max_Fields>;
  readonly min?: Maybe<ConferenceDemoCode_Min_Fields>;
};


/** aggregate fields of "ConferenceDemoCode" */
export type ConferenceDemoCode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ConferenceDemoCode" */
export type ConferenceDemoCode_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ConferenceDemoCode_Max_Order_By>;
  readonly min?: Maybe<ConferenceDemoCode_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ConferenceDemoCode" */
export type ConferenceDemoCode_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ConferenceDemoCode_Insert_Input>;
  readonly on_conflict?: Maybe<ConferenceDemoCode_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ConferenceDemoCode". All fields are combined with a logical 'AND'. */
export type ConferenceDemoCode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ConferenceDemoCode_Bool_Exp>>>;
  readonly _not?: Maybe<ConferenceDemoCode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ConferenceDemoCode_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly note?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly usedBy?: Maybe<User_Bool_Exp>;
  readonly usedById?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ConferenceDemoCode" */
export enum ConferenceDemoCode_Constraint {
  /** unique or primary key constraint */
  ConferenceDemoCodesPkey = 'ConferenceDemoCodes_pkey'
}

/** input type for inserting data into table "ConferenceDemoCode" */
export type ConferenceDemoCode_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedBy?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type ConferenceDemoCode_Max_Fields = {
  readonly __typename?: 'ConferenceDemoCode_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ConferenceDemoCode" */
export type ConferenceDemoCode_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ConferenceDemoCode_Min_Fields = {
  readonly __typename?: 'ConferenceDemoCode_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ConferenceDemoCode" */
export type ConferenceDemoCode_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** response of any mutation on the table "ConferenceDemoCode" */
export type ConferenceDemoCode_Mutation_Response = {
  readonly __typename?: 'ConferenceDemoCode_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ConferenceDemoCode>;
};

/** input type for inserting object relation for remote table "ConferenceDemoCode" */
export type ConferenceDemoCode_Obj_Rel_Insert_Input = {
  readonly data: ConferenceDemoCode_Insert_Input;
  readonly on_conflict?: Maybe<ConferenceDemoCode_On_Conflict>;
};

/** on conflict condition type for table "ConferenceDemoCode" */
export type ConferenceDemoCode_On_Conflict = {
  readonly constraint: ConferenceDemoCode_Constraint;
  readonly update_columns: ReadonlyArray<ConferenceDemoCode_Update_Column>;
  readonly where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};

/** ordering options when selecting data from "ConferenceDemoCode" */
export type ConferenceDemoCode_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedBy?: Maybe<User_Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** primary key columns input for table: "ConferenceDemoCode" */
export type ConferenceDemoCode_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ConferenceDemoCode" */
export enum ConferenceDemoCode_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedById = 'usedById'
}

/** input type for updating data in table "ConferenceDemoCode" */
export type ConferenceDemoCode_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** update columns of table "ConferenceDemoCode" */
export enum ConferenceDemoCode_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedById = 'usedById'
}

/** columns and relationships of "ConferencePrepareJob" */
export type ConferencePrepareJob = {
  readonly __typename?: 'ConferencePrepareJob';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: JobStatus;
  readonly jobStatusName: JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly videoRenderJobs: ReadonlyArray<VideoRenderJob>;
  /** An aggregated array relationship */
  readonly videoRenderJobs_aggregate: VideoRenderJob_Aggregate;
};


/** columns and relationships of "ConferencePrepareJob" */
export type ConferencePrepareJobVideoRenderJobsArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** columns and relationships of "ConferencePrepareJob" */
export type ConferencePrepareJobVideoRenderJobs_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};

/** aggregated selection of "ConferencePrepareJob" */
export type ConferencePrepareJob_Aggregate = {
  readonly __typename?: 'ConferencePrepareJob_aggregate';
  readonly aggregate?: Maybe<ConferencePrepareJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ConferencePrepareJob>;
};

/** aggregate fields of "ConferencePrepareJob" */
export type ConferencePrepareJob_Aggregate_Fields = {
  readonly __typename?: 'ConferencePrepareJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ConferencePrepareJob_Max_Fields>;
  readonly min?: Maybe<ConferencePrepareJob_Min_Fields>;
};


/** aggregate fields of "ConferencePrepareJob" */
export type ConferencePrepareJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ConferencePrepareJob" */
export type ConferencePrepareJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ConferencePrepareJob_Max_Order_By>;
  readonly min?: Maybe<ConferencePrepareJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ConferencePrepareJob" */
export type ConferencePrepareJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ConferencePrepareJob_Insert_Input>;
  readonly on_conflict?: Maybe<ConferencePrepareJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ConferencePrepareJob". All fields are combined with a logical 'AND'. */
export type ConferencePrepareJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ConferencePrepareJob_Bool_Exp>>>;
  readonly _not?: Maybe<ConferencePrepareJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ConferencePrepareJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoRenderJobs?: Maybe<VideoRenderJob_Bool_Exp>;
};

/** unique or primary key constraints on table "ConferencePrepareJob" */
export enum ConferencePrepareJob_Constraint {
  /** unique or primary key constraint */
  ConferencePrepareJobPkey = 'ConferencePrepareJob_pkey'
}

/** input type for inserting data into table "ConferencePrepareJob" */
export type ConferencePrepareJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoRenderJobs?: Maybe<VideoRenderJob_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type ConferencePrepareJob_Max_Fields = {
  readonly __typename?: 'ConferencePrepareJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ConferencePrepareJob" */
export type ConferencePrepareJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ConferencePrepareJob_Min_Fields = {
  readonly __typename?: 'ConferencePrepareJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ConferencePrepareJob" */
export type ConferencePrepareJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ConferencePrepareJob" */
export type ConferencePrepareJob_Mutation_Response = {
  readonly __typename?: 'ConferencePrepareJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ConferencePrepareJob>;
};

/** input type for inserting object relation for remote table "ConferencePrepareJob" */
export type ConferencePrepareJob_Obj_Rel_Insert_Input = {
  readonly data: ConferencePrepareJob_Insert_Input;
  readonly on_conflict?: Maybe<ConferencePrepareJob_On_Conflict>;
};

/** on conflict condition type for table "ConferencePrepareJob" */
export type ConferencePrepareJob_On_Conflict = {
  readonly constraint: ConferencePrepareJob_Constraint;
  readonly update_columns: ReadonlyArray<ConferencePrepareJob_Update_Column>;
  readonly where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};

/** ordering options when selecting data from "ConferencePrepareJob" */
export type ConferencePrepareJob_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoRenderJobs_aggregate?: Maybe<VideoRenderJob_Aggregate_Order_By>;
};

/** primary key columns input for table: "ConferencePrepareJob" */
export type ConferencePrepareJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ConferencePrepareJob" */
export enum ConferencePrepareJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "ConferencePrepareJob" */
export type ConferencePrepareJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ConferencePrepareJob" */
export enum ConferencePrepareJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ConferencePrepareOutput = {
  readonly __typename?: 'ConferencePrepareOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

/** aggregated selection of "Conference" */
export type Conference_Aggregate = {
  readonly __typename?: 'Conference_aggregate';
  readonly aggregate?: Maybe<Conference_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference>;
};

/** aggregate fields of "Conference" */
export type Conference_Aggregate_Fields = {
  readonly __typename?: 'Conference_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Conference_Max_Fields>;
  readonly min?: Maybe<Conference_Min_Fields>;
};


/** aggregate fields of "Conference" */
export type Conference_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Conference" */
export type Conference_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_Max_Order_By>;
  readonly min?: Maybe<Conference_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Conference" */
export type Conference_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_Insert_Input>;
  readonly on_conflict?: Maybe<Conference_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Conference". All fields are combined with a logical 'AND'. */
export type Conference_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Conference_Bool_Exp>>>;
  readonly _not?: Maybe<Conference_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Conference_Bool_Exp>>>;
  readonly attendees?: Maybe<Attendee_Bool_Exp>;
  readonly chats?: Maybe<Chat_Chat_Bool_Exp>;
  readonly configurations?: Maybe<ConferenceConfiguration_Bool_Exp>;
  readonly contentGroups?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentPeople?: Maybe<ContentPerson_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly createdBy?: Maybe<String_Comparison_Exp>;
  readonly creator?: Maybe<User_Bool_Exp>;
  readonly demoCode?: Maybe<ConferenceDemoCode_Bool_Exp>;
  readonly demoCodeId?: Maybe<Uuid_Comparison_Exp>;
  readonly groups?: Maybe<Group_Bool_Exp>;
  readonly hallways?: Maybe<Hallway_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingDatas?: Maybe<OriginatingData_Bool_Exp>;
  readonly roles?: Maybe<Role_Bool_Exp>;
  readonly rooms?: Maybe<Room_Bool_Exp>;
  readonly shortName?: Maybe<String_Comparison_Exp>;
  readonly shufflePeriods?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
  readonly tags?: Maybe<Tag_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Conference" */
export enum Conference_Constraint {
  /** unique or primary key constraint */
  ConferenceDemoCodeIdKey = 'Conference_demoCodeId_key',
  /** unique or primary key constraint */
  ConferenceNameKey = 'Conference_name_key',
  /** unique or primary key constraint */
  ConferencePkey = 'Conference_pkey',
  /** unique or primary key constraint */
  ConferenceShortNameKey = 'Conference_shortName_key',
  /** unique or primary key constraint */
  ConferenceSlugKey = 'Conference_slug_key'
}

/** input type for inserting data into table "Conference" */
export type Conference_Insert_Input = {
  readonly attendees?: Maybe<Attendee_Arr_Rel_Insert_Input>;
  readonly chats?: Maybe<Chat_Chat_Arr_Rel_Insert_Input>;
  readonly configurations?: Maybe<ConferenceConfiguration_Arr_Rel_Insert_Input>;
  readonly contentGroups?: Maybe<ContentGroup_Arr_Rel_Insert_Input>;
  readonly contentPeople?: Maybe<ContentPerson_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly creator?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly demoCode?: Maybe<ConferenceDemoCode_Obj_Rel_Insert_Input>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly groups?: Maybe<Group_Arr_Rel_Insert_Input>;
  readonly hallways?: Maybe<Hallway_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDatas?: Maybe<OriginatingData_Arr_Rel_Insert_Input>;
  readonly roles?: Maybe<Role_Arr_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Arr_Rel_Insert_Input>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly shufflePeriods?: Maybe<Room_ShufflePeriod_Arr_Rel_Insert_Input>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly tags?: Maybe<Tag_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Conference_Max_Fields = {
  readonly __typename?: 'Conference_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Conference" */
export type Conference_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_Min_Fields = {
  readonly __typename?: 'Conference_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Conference" */
export type Conference_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Conference" */
export type Conference_Mutation_Response = {
  readonly __typename?: 'Conference_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Conference>;
};

/** input type for inserting object relation for remote table "Conference" */
export type Conference_Obj_Rel_Insert_Input = {
  readonly data: Conference_Insert_Input;
  readonly on_conflict?: Maybe<Conference_On_Conflict>;
};

/** on conflict condition type for table "Conference" */
export type Conference_On_Conflict = {
  readonly constraint: Conference_Constraint;
  readonly update_columns: ReadonlyArray<Conference_Update_Column>;
  readonly where?: Maybe<Conference_Bool_Exp>;
};

/** ordering options when selecting data from "Conference" */
export type Conference_Order_By = {
  readonly attendees_aggregate?: Maybe<Attendee_Aggregate_Order_By>;
  readonly chats_aggregate?: Maybe<Chat_Chat_Aggregate_Order_By>;
  readonly configurations_aggregate?: Maybe<ConferenceConfiguration_Aggregate_Order_By>;
  readonly contentGroups_aggregate?: Maybe<ContentGroup_Aggregate_Order_By>;
  readonly contentPeople_aggregate?: Maybe<ContentPerson_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly creator?: Maybe<User_Order_By>;
  readonly demoCode?: Maybe<ConferenceDemoCode_Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly groups_aggregate?: Maybe<Group_Aggregate_Order_By>;
  readonly hallways_aggregate?: Maybe<Hallway_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDatas_aggregate?: Maybe<OriginatingData_Aggregate_Order_By>;
  readonly roles_aggregate?: Maybe<Role_Aggregate_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Aggregate_Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly shufflePeriods_aggregate?: Maybe<Room_ShufflePeriod_Aggregate_Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly tags_aggregate?: Maybe<Tag_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Conference" */
export type Conference_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Conference" */
export enum Conference_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DemoCodeId = 'demoCodeId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Conference" */
export type Conference_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Conference" */
export enum Conference_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DemoCodeId = 'demoCodeId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ConfirmInvitationInput = {
  readonly confirmationCode: Scalars['String'];
  readonly inviteCode: Scalars['uuid'];
};

export type ConfirmInvitationOutput = {
  readonly __typename?: 'ConfirmInvitationOutput';
  readonly confSlug?: Maybe<Scalars['String']>;
  readonly ok: Scalars['Boolean'];
};

/** columns and relationships of "ContentGroup" */
export type ContentGroup = {
  readonly __typename?: 'ContentGroup';
  /** An object relationship */
  readonly chat?: Maybe<Chat_Chat>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroupTags: ReadonlyArray<ContentGroupTag>;
  /** An aggregated array relationship */
  readonly contentGroupTags_aggregate: ContentGroupTag_Aggregate;
  /** An object relationship */
  readonly contentGroupType: ContentGroupType;
  readonly contentGroupTypeName: ContentGroupType_Enum;
  /** An array relationship */
  readonly contentItems: ReadonlyArray<ContentItem>;
  /** An aggregated array relationship */
  readonly contentItems_aggregate: ContentItem_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly events: ReadonlyArray<Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Event_Aggregate;
  /** An array relationship */
  readonly hallways: ReadonlyArray<ContentGroupHallway>;
  /** An aggregated array relationship */
  readonly hallways_aggregate: ContentGroupHallway_Aggregate;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly people: ReadonlyArray<ContentGroupPerson>;
  /** An aggregated array relationship */
  readonly people_aggregate: ContentGroupPerson_Aggregate;
  /** An array relationship */
  readonly requiredContentItems: ReadonlyArray<RequiredContentItem>;
  /** An aggregated array relationship */
  readonly requiredContentItems_aggregate: RequiredContentItem_Aggregate;
  /** An object relationship */
  readonly room?: Maybe<Room>;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Aggregate;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupContentGroupTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupContentGroupTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupHallwaysArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupHallways_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupRequiredContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupRequiredContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};

/** columns and relationships of "ContentGroupHallway" */
export type ContentGroupHallway = {
  readonly __typename?: 'ContentGroupHallway';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentGroup: ContentGroup;
  readonly groupId: Scalars['uuid'];
  /** An object relationship */
  readonly hallway: Hallway;
  readonly hallwayId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "ContentGroupHallway" */
export type ContentGroupHallwayLayoutArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "ContentGroupHallway" */
export type ContentGroupHallway_Aggregate = {
  readonly __typename?: 'ContentGroupHallway_aggregate';
  readonly aggregate?: Maybe<ContentGroupHallway_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroupHallway>;
};

/** aggregate fields of "ContentGroupHallway" */
export type ContentGroupHallway_Aggregate_Fields = {
  readonly __typename?: 'ContentGroupHallway_aggregate_fields';
  readonly avg?: Maybe<ContentGroupHallway_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroupHallway_Max_Fields>;
  readonly min?: Maybe<ContentGroupHallway_Min_Fields>;
  readonly stddev?: Maybe<ContentGroupHallway_Stddev_Fields>;
  readonly stddev_pop?: Maybe<ContentGroupHallway_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<ContentGroupHallway_Stddev_Samp_Fields>;
  readonly sum?: Maybe<ContentGroupHallway_Sum_Fields>;
  readonly var_pop?: Maybe<ContentGroupHallway_Var_Pop_Fields>;
  readonly var_samp?: Maybe<ContentGroupHallway_Var_Samp_Fields>;
  readonly variance?: Maybe<ContentGroupHallway_Variance_Fields>;
};


/** aggregate fields of "ContentGroupHallway" */
export type ContentGroupHallway_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroupHallway" */
export type ContentGroupHallway_Aggregate_Order_By = {
  readonly avg?: Maybe<ContentGroupHallway_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroupHallway_Max_Order_By>;
  readonly min?: Maybe<ContentGroupHallway_Min_Order_By>;
  readonly stddev?: Maybe<ContentGroupHallway_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<ContentGroupHallway_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<ContentGroupHallway_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<ContentGroupHallway_Sum_Order_By>;
  readonly var_pop?: Maybe<ContentGroupHallway_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<ContentGroupHallway_Var_Samp_Order_By>;
  readonly variance?: Maybe<ContentGroupHallway_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ContentGroupHallway_Append_Input = {
  readonly layout?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "ContentGroupHallway" */
export type ContentGroupHallway_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroupHallway_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroupHallway_On_Conflict>;
};

/** aggregate avg on columns */
export type ContentGroupHallway_Avg_Fields = {
  readonly __typename?: 'ContentGroupHallway_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ContentGroupHallway". All fields are combined with a logical 'AND'. */
export type ContentGroupHallway_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroupHallway_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroupHallway_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroupHallway_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly hallway?: Maybe<Hallway_Bool_Exp>;
  readonly hallwayId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly layout?: Maybe<Jsonb_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroupHallway" */
export enum ContentGroupHallway_Constraint {
  /** unique or primary key constraint */
  ContentGroupHallwayPkey = 'ContentGroupHallway_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ContentGroupHallway_Delete_At_Path_Input = {
  readonly layout?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ContentGroupHallway_Delete_Elem_Input = {
  readonly layout?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ContentGroupHallway_Delete_Key_Input = {
  readonly layout?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "ContentGroupHallway" */
export type ContentGroupHallway_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "ContentGroupHallway" */
export type ContentGroupHallway_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly hallway?: Maybe<Hallway_Obj_Rel_Insert_Input>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type ContentGroupHallway_Max_Fields = {
  readonly __typename?: 'ContentGroupHallway_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly hallwayId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroupHallway_Min_Fields = {
  readonly __typename?: 'ContentGroupHallway_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly hallwayId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroupHallway" */
export type ContentGroupHallway_Mutation_Response = {
  readonly __typename?: 'ContentGroupHallway_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroupHallway>;
};

/** input type for inserting object relation for remote table "ContentGroupHallway" */
export type ContentGroupHallway_Obj_Rel_Insert_Input = {
  readonly data: ContentGroupHallway_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroupHallway_On_Conflict>;
};

/** on conflict condition type for table "ContentGroupHallway" */
export type ContentGroupHallway_On_Conflict = {
  readonly constraint: ContentGroupHallway_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroupHallway_Update_Column>;
  readonly where?: Maybe<ContentGroupHallway_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroupHallway" */
export type ContentGroupHallway_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly hallway?: Maybe<Hallway_Order_By>;
  readonly hallwayId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly layout?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroupHallway" */
export type ContentGroupHallway_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ContentGroupHallway_Prepend_Input = {
  readonly layout?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "ContentGroupHallway" */
export enum ContentGroupHallway_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  HallwayId = 'hallwayId',
  /** column name */
  Id = 'id',
  /** column name */
  Layout = 'layout',
  /** column name */
  Priority = 'priority'
}

/** input type for updating data in table "ContentGroupHallway" */
export type ContentGroupHallway_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type ContentGroupHallway_Stddev_Fields = {
  readonly __typename?: 'ContentGroupHallway_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ContentGroupHallway_Stddev_Pop_Fields = {
  readonly __typename?: 'ContentGroupHallway_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ContentGroupHallway_Stddev_Samp_Fields = {
  readonly __typename?: 'ContentGroupHallway_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type ContentGroupHallway_Sum_Fields = {
  readonly __typename?: 'ContentGroupHallway_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "ContentGroupHallway" */
export enum ContentGroupHallway_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  HallwayId = 'hallwayId',
  /** column name */
  Id = 'id',
  /** column name */
  Layout = 'layout',
  /** column name */
  Priority = 'priority'
}

/** aggregate var_pop on columns */
export type ContentGroupHallway_Var_Pop_Fields = {
  readonly __typename?: 'ContentGroupHallway_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ContentGroupHallway_Var_Samp_Fields = {
  readonly __typename?: 'ContentGroupHallway_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type ContentGroupHallway_Variance_Fields = {
  readonly __typename?: 'ContentGroupHallway_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "ContentGroupPerson" */
export type ContentGroupPerson = {
  readonly __typename?: 'ContentGroupPerson';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly group: ContentGroup;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly person: ContentPerson;
  readonly personId: Scalars['uuid'];
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName: Scalars['String'];
};

/** aggregated selection of "ContentGroupPerson" */
export type ContentGroupPerson_Aggregate = {
  readonly __typename?: 'ContentGroupPerson_aggregate';
  readonly aggregate?: Maybe<ContentGroupPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroupPerson>;
};

/** aggregate fields of "ContentGroupPerson" */
export type ContentGroupPerson_Aggregate_Fields = {
  readonly __typename?: 'ContentGroupPerson_aggregate_fields';
  readonly avg?: Maybe<ContentGroupPerson_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroupPerson_Max_Fields>;
  readonly min?: Maybe<ContentGroupPerson_Min_Fields>;
  readonly stddev?: Maybe<ContentGroupPerson_Stddev_Fields>;
  readonly stddev_pop?: Maybe<ContentGroupPerson_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<ContentGroupPerson_Stddev_Samp_Fields>;
  readonly sum?: Maybe<ContentGroupPerson_Sum_Fields>;
  readonly var_pop?: Maybe<ContentGroupPerson_Var_Pop_Fields>;
  readonly var_samp?: Maybe<ContentGroupPerson_Var_Samp_Fields>;
  readonly variance?: Maybe<ContentGroupPerson_Variance_Fields>;
};


/** aggregate fields of "ContentGroupPerson" */
export type ContentGroupPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroupPerson" */
export type ContentGroupPerson_Aggregate_Order_By = {
  readonly avg?: Maybe<ContentGroupPerson_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroupPerson_Max_Order_By>;
  readonly min?: Maybe<ContentGroupPerson_Min_Order_By>;
  readonly stddev?: Maybe<ContentGroupPerson_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<ContentGroupPerson_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<ContentGroupPerson_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<ContentGroupPerson_Sum_Order_By>;
  readonly var_pop?: Maybe<ContentGroupPerson_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<ContentGroupPerson_Var_Samp_Order_By>;
  readonly variance?: Maybe<ContentGroupPerson_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "ContentGroupPerson" */
export type ContentGroupPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroupPerson_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroupPerson_On_Conflict>;
};

/** aggregate avg on columns */
export type ContentGroupPerson_Avg_Fields = {
  readonly __typename?: 'ContentGroupPerson_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ContentGroupPerson". All fields are combined with a logical 'AND'. */
export type ContentGroupPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroupPerson_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroupPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroupPerson_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly group?: Maybe<ContentGroup_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly person?: Maybe<ContentPerson_Bool_Exp>;
  readonly personId?: Maybe<Uuid_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly roleName?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroupPerson" */
export enum ContentGroupPerson_Constraint {
  /** unique or primary key constraint */
  ContentItemPersonPkey = 'ContentItemPerson_pkey',
  /** unique or primary key constraint */
  ContentItemPersonRoleNamePersonIdGroupIdKey = 'ContentItemPerson_roleName_personId_groupId_key'
}

/** input type for incrementing integer column in table "ContentGroupPerson" */
export type ContentGroupPerson_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "ContentGroupPerson" */
export type ContentGroupPerson_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly group?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly person?: Maybe<ContentPerson_Obj_Rel_Insert_Input>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type ContentGroupPerson_Max_Fields = {
  readonly __typename?: 'ContentGroupPerson_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroupPerson_Min_Fields = {
  readonly __typename?: 'ContentGroupPerson_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroupPerson" */
export type ContentGroupPerson_Mutation_Response = {
  readonly __typename?: 'ContentGroupPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroupPerson>;
};

/** input type for inserting object relation for remote table "ContentGroupPerson" */
export type ContentGroupPerson_Obj_Rel_Insert_Input = {
  readonly data: ContentGroupPerson_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroupPerson_On_Conflict>;
};

/** on conflict condition type for table "ContentGroupPerson" */
export type ContentGroupPerson_On_Conflict = {
  readonly constraint: ContentGroupPerson_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroupPerson_Update_Column>;
  readonly where?: Maybe<ContentGroupPerson_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroupPerson" */
export type ContentGroupPerson_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly group?: Maybe<ContentGroup_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly person?: Maybe<ContentPerson_Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroupPerson" */
export type ContentGroupPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ContentGroupPerson" */
export enum ContentGroupPerson_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Priority = 'priority',
  /** column name */
  RoleName = 'roleName'
}

/** input type for updating data in table "ContentGroupPerson" */
export type ContentGroupPerson_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type ContentGroupPerson_Stddev_Fields = {
  readonly __typename?: 'ContentGroupPerson_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ContentGroupPerson_Stddev_Pop_Fields = {
  readonly __typename?: 'ContentGroupPerson_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ContentGroupPerson_Stddev_Samp_Fields = {
  readonly __typename?: 'ContentGroupPerson_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type ContentGroupPerson_Sum_Fields = {
  readonly __typename?: 'ContentGroupPerson_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "ContentGroupPerson" */
export enum ContentGroupPerson_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Priority = 'priority',
  /** column name */
  RoleName = 'roleName'
}

/** aggregate var_pop on columns */
export type ContentGroupPerson_Var_Pop_Fields = {
  readonly __typename?: 'ContentGroupPerson_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ContentGroupPerson_Var_Samp_Fields = {
  readonly __typename?: 'ContentGroupPerson_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type ContentGroupPerson_Variance_Fields = {
  readonly __typename?: 'ContentGroupPerson_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "ContentGroupTag" */
export type ContentGroupTag = {
  readonly __typename?: 'ContentGroupTag';
  /** An object relationship */
  readonly contentGroup: ContentGroup;
  readonly contentGroupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly tag: Tag;
  readonly tagId: Scalars['uuid'];
};

/** aggregated selection of "ContentGroupTag" */
export type ContentGroupTag_Aggregate = {
  readonly __typename?: 'ContentGroupTag_aggregate';
  readonly aggregate?: Maybe<ContentGroupTag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroupTag>;
};

/** aggregate fields of "ContentGroupTag" */
export type ContentGroupTag_Aggregate_Fields = {
  readonly __typename?: 'ContentGroupTag_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroupTag_Max_Fields>;
  readonly min?: Maybe<ContentGroupTag_Min_Fields>;
};


/** aggregate fields of "ContentGroupTag" */
export type ContentGroupTag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroupTag" */
export type ContentGroupTag_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroupTag_Max_Order_By>;
  readonly min?: Maybe<ContentGroupTag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentGroupTag" */
export type ContentGroupTag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroupTag_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroupTag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentGroupTag". All fields are combined with a logical 'AND'. */
export type ContentGroupTag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroupTag_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroupTag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroupTag_Bool_Exp>>>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly tag?: Maybe<Tag_Bool_Exp>;
  readonly tagId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroupTag" */
export enum ContentGroupTag_Constraint {
  /** unique or primary key constraint */
  ContentGroupTagContentGroupIdTagIdKey = 'ContentGroupTag_contentGroupId_tagId_key',
  /** unique or primary key constraint */
  ContentGroupTagPkey = 'ContentGroupTag_pkey'
}

/** input type for inserting data into table "ContentGroupTag" */
export type ContentGroupTag_Insert_Input = {
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tag?: Maybe<Tag_Obj_Rel_Insert_Input>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type ContentGroupTag_Max_Fields = {
  readonly __typename?: 'ContentGroupTag_max_fields';
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "ContentGroupTag" */
export type ContentGroupTag_Max_Order_By = {
  readonly contentGroupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroupTag_Min_Fields = {
  readonly __typename?: 'ContentGroupTag_min_fields';
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "ContentGroupTag" */
export type ContentGroupTag_Min_Order_By = {
  readonly contentGroupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroupTag" */
export type ContentGroupTag_Mutation_Response = {
  readonly __typename?: 'ContentGroupTag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroupTag>;
};

/** input type for inserting object relation for remote table "ContentGroupTag" */
export type ContentGroupTag_Obj_Rel_Insert_Input = {
  readonly data: ContentGroupTag_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroupTag_On_Conflict>;
};

/** on conflict condition type for table "ContentGroupTag" */
export type ContentGroupTag_On_Conflict = {
  readonly constraint: ContentGroupTag_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroupTag_Update_Column>;
  readonly where?: Maybe<ContentGroupTag_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroupTag" */
export type ContentGroupTag_Order_By = {
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tag?: Maybe<Tag_Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroupTag" */
export type ContentGroupTag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ContentGroupTag" */
export enum ContentGroupTag_Select_Column {
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** input type for updating data in table "ContentGroupTag" */
export type ContentGroupTag_Set_Input = {
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "ContentGroupTag" */
export enum ContentGroupTag_Update_Column {
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** columns and relationships of "ContentGroupType" */
export type ContentGroupType = {
  readonly __typename?: 'ContentGroupType';
  /** An array relationship */
  readonly contentGroups: ReadonlyArray<ContentGroup>;
  /** An aggregated array relationship */
  readonly contentGroups_aggregate: ContentGroup_Aggregate;
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};


/** columns and relationships of "ContentGroupType" */
export type ContentGroupTypeContentGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "ContentGroupType" */
export type ContentGroupTypeContentGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};

/** aggregated selection of "ContentGroupType" */
export type ContentGroupType_Aggregate = {
  readonly __typename?: 'ContentGroupType_aggregate';
  readonly aggregate?: Maybe<ContentGroupType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroupType>;
};

/** aggregate fields of "ContentGroupType" */
export type ContentGroupType_Aggregate_Fields = {
  readonly __typename?: 'ContentGroupType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroupType_Max_Fields>;
  readonly min?: Maybe<ContentGroupType_Min_Fields>;
};


/** aggregate fields of "ContentGroupType" */
export type ContentGroupType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroupType" */
export type ContentGroupType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroupType_Max_Order_By>;
  readonly min?: Maybe<ContentGroupType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentGroupType" */
export type ContentGroupType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroupType_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroupType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentGroupType". All fields are combined with a logical 'AND'. */
export type ContentGroupType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroupType_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroupType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroupType_Bool_Exp>>>;
  readonly contentGroups?: Maybe<ContentGroup_Bool_Exp>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroupType" */
export enum ContentGroupType_Constraint {
  /** unique or primary key constraint */
  ContentGroupTypePkey = 'ContentGroupType_pkey'
}

export enum ContentGroupType_Enum {
  /** A keynote. */
  Keynote = 'KEYNOTE',
  /** Conference main landing page. */
  LandingPage = 'LANDING_PAGE',
  /** A generic group type - use sparingly. */
  Other = 'OTHER',
  /** A paper. */
  Paper = 'PAPER',
  /** A poster. */
  Poster = 'POSTER',
  /** A sponsor. */
  Sponsor = 'SPONSOR',
  /** A symposium. */
  Symposium = 'SYMPOSIUM',
  /** A workshop. */
  Workshop = 'WORKSHOP'
}

/** expression to compare columns of type ContentGroupType_enum. All fields are combined with logical 'AND'. */
export type ContentGroupType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<ContentGroupType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<ContentGroupType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<ContentGroupType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<ContentGroupType_Enum>>;
};

/** input type for inserting data into table "ContentGroupType" */
export type ContentGroupType_Insert_Input = {
  readonly contentGroups?: Maybe<ContentGroup_Arr_Rel_Insert_Input>;
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type ContentGroupType_Max_Fields = {
  readonly __typename?: 'ContentGroupType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ContentGroupType" */
export type ContentGroupType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroupType_Min_Fields = {
  readonly __typename?: 'ContentGroupType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ContentGroupType" */
export type ContentGroupType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroupType" */
export type ContentGroupType_Mutation_Response = {
  readonly __typename?: 'ContentGroupType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroupType>;
};

/** input type for inserting object relation for remote table "ContentGroupType" */
export type ContentGroupType_Obj_Rel_Insert_Input = {
  readonly data: ContentGroupType_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroupType_On_Conflict>;
};

/** on conflict condition type for table "ContentGroupType" */
export type ContentGroupType_On_Conflict = {
  readonly constraint: ContentGroupType_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroupType_Update_Column>;
  readonly where?: Maybe<ContentGroupType_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroupType" */
export type ContentGroupType_Order_By = {
  readonly contentGroups_aggregate?: Maybe<ContentGroup_Aggregate_Order_By>;
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroupType" */
export type ContentGroupType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "ContentGroupType" */
export enum ContentGroupType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "ContentGroupType" */
export type ContentGroupType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "ContentGroupType" */
export enum ContentGroupType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "ContentGroup" */
export type ContentGroup_Aggregate = {
  readonly __typename?: 'ContentGroup_aggregate';
  readonly aggregate?: Maybe<ContentGroup_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroup>;
};

/** aggregate fields of "ContentGroup" */
export type ContentGroup_Aggregate_Fields = {
  readonly __typename?: 'ContentGroup_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroup_Max_Fields>;
  readonly min?: Maybe<ContentGroup_Min_Fields>;
};


/** aggregate fields of "ContentGroup" */
export type ContentGroup_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroup" */
export type ContentGroup_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroup_Max_Order_By>;
  readonly min?: Maybe<ContentGroup_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentGroup" */
export type ContentGroup_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroup_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroup_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentGroup". All fields are combined with a logical 'AND'. */
export type ContentGroup_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroup_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroup_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroup_Bool_Exp>>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroupTags?: Maybe<ContentGroupTag_Bool_Exp>;
  readonly contentGroupType?: Maybe<ContentGroupType_Bool_Exp>;
  readonly contentGroupTypeName?: Maybe<ContentGroupType_Enum_Comparison_Exp>;
  readonly contentItems?: Maybe<ContentItem_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly events?: Maybe<Event_Bool_Exp>;
  readonly hallways?: Maybe<ContentGroupHallway_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly people?: Maybe<ContentGroupPerson_Bool_Exp>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly rooms?: Maybe<Room_Bool_Exp>;
  readonly shortTitle?: Maybe<String_Comparison_Exp>;
  readonly title?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroup" */
export enum ContentGroup_Constraint {
  /** unique or primary key constraint */
  ContentGroupPkey = 'ContentGroup_pkey'
}

/** input type for inserting data into table "ContentGroup" */
export type ContentGroup_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupTags?: Maybe<ContentGroupTag_Arr_Rel_Insert_Input>;
  readonly contentGroupType?: Maybe<ContentGroupType_Obj_Rel_Insert_Input>;
  readonly contentGroupTypeName?: Maybe<ContentGroupType_Enum>;
  readonly contentItems?: Maybe<ContentItem_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly events?: Maybe<Event_Arr_Rel_Insert_Input>;
  readonly hallways?: Maybe<ContentGroupHallway_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly people?: Maybe<ContentGroupPerson_Arr_Rel_Insert_Input>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Arr_Rel_Insert_Input>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Arr_Rel_Insert_Input>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type ContentGroup_Max_Fields = {
  readonly __typename?: 'ContentGroup_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ContentGroup" */
export type ContentGroup_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroup_Min_Fields = {
  readonly __typename?: 'ContentGroup_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ContentGroup" */
export type ContentGroup_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroup" */
export type ContentGroup_Mutation_Response = {
  readonly __typename?: 'ContentGroup_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroup>;
};

/** input type for inserting object relation for remote table "ContentGroup" */
export type ContentGroup_Obj_Rel_Insert_Input = {
  readonly data: ContentGroup_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroup_On_Conflict>;
};

/** on conflict condition type for table "ContentGroup" */
export type ContentGroup_On_Conflict = {
  readonly constraint: ContentGroup_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroup_Update_Column>;
  readonly where?: Maybe<ContentGroup_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroup" */
export type ContentGroup_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupTags_aggregate?: Maybe<ContentGroupTag_Aggregate_Order_By>;
  readonly contentGroupType?: Maybe<ContentGroupType_Order_By>;
  readonly contentGroupTypeName?: Maybe<Order_By>;
  readonly contentItems_aggregate?: Maybe<ContentItem_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Event_Aggregate_Order_By>;
  readonly hallways_aggregate?: Maybe<ContentGroupHallway_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly people_aggregate?: Maybe<ContentGroupPerson_Aggregate_Order_By>;
  readonly requiredContentItems_aggregate?: Maybe<RequiredContentItem_Aggregate_Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Aggregate_Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroup" */
export type ContentGroup_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ContentGroup" */
export enum ContentGroup_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupTypeName = 'contentGroupTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  ShortTitle = 'shortTitle',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "ContentGroup" */
export type ContentGroup_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupTypeName?: Maybe<ContentGroupType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ContentGroup" */
export enum ContentGroup_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupTypeName = 'contentGroupTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  ShortTitle = 'shortTitle',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "ContentItem" */
export type ContentItem = {
  readonly __typename?: 'ContentItem';
  /** An object relationship */
  readonly broadcastContentItem?: Maybe<BroadcastContentItem>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentGroup: ContentGroup;
  readonly contentGroupId: Scalars['uuid'];
  /** An object relationship */
  readonly contentType: ContentType;
  readonly contentTypeName: ContentType_Enum;
  readonly createdAt: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['uuid'];
  readonly isHidden: Scalars['Boolean'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly requiredContentItem?: Maybe<RequiredContentItem>;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "ContentItem" */
export type ContentItemDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "ContentItem" */
export type ContentItemLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "ContentItem" */
export type ContentItem_Aggregate = {
  readonly __typename?: 'ContentItem_aggregate';
  readonly aggregate?: Maybe<ContentItem_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentItem>;
};

/** aggregate fields of "ContentItem" */
export type ContentItem_Aggregate_Fields = {
  readonly __typename?: 'ContentItem_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentItem_Max_Fields>;
  readonly min?: Maybe<ContentItem_Min_Fields>;
};


/** aggregate fields of "ContentItem" */
export type ContentItem_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentItem" */
export type ContentItem_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentItem_Max_Order_By>;
  readonly min?: Maybe<ContentItem_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ContentItem_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "ContentItem" */
export type ContentItem_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentItem_Insert_Input>;
  readonly on_conflict?: Maybe<ContentItem_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentItem". All fields are combined with a logical 'AND'. */
export type ContentItem_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentItem_Bool_Exp>>>;
  readonly _not?: Maybe<ContentItem_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentItem_Bool_Exp>>>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentType?: Maybe<ContentType_Bool_Exp>;
  readonly contentTypeName?: Maybe<ContentType_Enum_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly requiredContentId?: Maybe<Uuid_Comparison_Exp>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentItem" */
export enum ContentItem_Constraint {
  /** unique or primary key constraint */
  ContentItemPkey = 'ContentItem_pkey',
  /** unique or primary key constraint */
  ContentItemRequiredContentIdKey = 'ContentItem_requiredContentId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ContentItem_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly layoutData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ContentItem_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ContentItem_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "ContentItem" */
export type ContentItem_Insert_Input = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly contentType?: Maybe<ContentType_Obj_Rel_Insert_Input>;
  readonly contentTypeName?: Maybe<ContentType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Obj_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type ContentItem_Max_Fields = {
  readonly __typename?: 'ContentItem_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ContentItem" */
export type ContentItem_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly requiredContentId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentItem_Min_Fields = {
  readonly __typename?: 'ContentItem_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ContentItem" */
export type ContentItem_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly requiredContentId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentItem" */
export type ContentItem_Mutation_Response = {
  readonly __typename?: 'ContentItem_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentItem>;
};

/** input type for inserting object relation for remote table "ContentItem" */
export type ContentItem_Obj_Rel_Insert_Input = {
  readonly data: ContentItem_Insert_Input;
  readonly on_conflict?: Maybe<ContentItem_On_Conflict>;
};

/** on conflict condition type for table "ContentItem" */
export type ContentItem_On_Conflict = {
  readonly constraint: ContentItem_Constraint;
  readonly update_columns: ReadonlyArray<ContentItem_Update_Column>;
  readonly where?: Maybe<ContentItem_Bool_Exp>;
};

/** ordering options when selecting data from "ContentItem" */
export type ContentItem_Order_By = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly contentType?: Maybe<ContentType_Order_By>;
  readonly contentTypeName?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly requiredContentId?: Maybe<Order_By>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentItem" */
export type ContentItem_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ContentItem_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "ContentItem" */
export enum ContentItem_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ContentTypeName = 'contentTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RequiredContentId = 'requiredContentId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "ContentItem" */
export type ContentItem_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly contentTypeName?: Maybe<ContentType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ContentItem" */
export enum ContentItem_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ContentTypeName = 'contentTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RequiredContentId = 'requiredContentId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "ContentPerson" */
export type ContentPerson = {
  readonly __typename?: 'ContentPerson';
  readonly affiliation?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly attendee?: Maybe<Attendee>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentItemPeople: ReadonlyArray<ContentGroupPerson>;
  /** An aggregated array relationship */
  readonly contentItemPeople_aggregate: ContentGroupPerson_Aggregate;
  readonly email?: Maybe<Scalars['String']>;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "ContentPerson" */
export type ContentPersonContentItemPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** columns and relationships of "ContentPerson" */
export type ContentPersonContentItemPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};

/** aggregated selection of "ContentPerson" */
export type ContentPerson_Aggregate = {
  readonly __typename?: 'ContentPerson_aggregate';
  readonly aggregate?: Maybe<ContentPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentPerson>;
};

/** aggregate fields of "ContentPerson" */
export type ContentPerson_Aggregate_Fields = {
  readonly __typename?: 'ContentPerson_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentPerson_Max_Fields>;
  readonly min?: Maybe<ContentPerson_Min_Fields>;
};


/** aggregate fields of "ContentPerson" */
export type ContentPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentPerson" */
export type ContentPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentPerson_Max_Order_By>;
  readonly min?: Maybe<ContentPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentPerson" */
export type ContentPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentPerson_Insert_Input>;
  readonly on_conflict?: Maybe<ContentPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentPerson". All fields are combined with a logical 'AND'. */
export type ContentPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentPerson_Bool_Exp>>>;
  readonly _not?: Maybe<ContentPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentPerson_Bool_Exp>>>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItemPeople?: Maybe<ContentGroupPerson_Bool_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentPerson" */
export enum ContentPerson_Constraint {
  /** unique or primary key constraint */
  ContentPersonConferenceIdNameAffiliationKey = 'ContentPerson_conferenceId_name_affiliation_key',
  /** unique or primary key constraint */
  ContentPersonPkey = 'ContentPerson_pkey'
}

/** input type for inserting data into table "ContentPerson" */
export type ContentPerson_Insert_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemPeople?: Maybe<ContentGroupPerson_Arr_Rel_Insert_Input>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type ContentPerson_Max_Fields = {
  readonly __typename?: 'ContentPerson_max_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "ContentPerson" */
export type ContentPerson_Max_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentPerson_Min_Fields = {
  readonly __typename?: 'ContentPerson_min_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "ContentPerson" */
export type ContentPerson_Min_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentPerson" */
export type ContentPerson_Mutation_Response = {
  readonly __typename?: 'ContentPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentPerson>;
};

/** input type for inserting object relation for remote table "ContentPerson" */
export type ContentPerson_Obj_Rel_Insert_Input = {
  readonly data: ContentPerson_Insert_Input;
  readonly on_conflict?: Maybe<ContentPerson_On_Conflict>;
};

/** on conflict condition type for table "ContentPerson" */
export type ContentPerson_On_Conflict = {
  readonly constraint: ContentPerson_Constraint;
  readonly update_columns: ReadonlyArray<ContentPerson_Update_Column>;
  readonly where?: Maybe<ContentPerson_Bool_Exp>;
};

/** ordering options when selecting data from "ContentPerson" */
export type ContentPerson_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemPeople_aggregate?: Maybe<ContentGroupPerson_Aggregate_Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentPerson" */
export type ContentPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ContentPerson" */
export enum ContentPerson_Select_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId'
}

/** input type for updating data in table "ContentPerson" */
export type ContentPerson_Set_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "ContentPerson" */
export enum ContentPerson_Update_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId'
}

/** columns and relationships of "ContentType" */
export type ContentType = {
  readonly __typename?: 'ContentType';
  /** An array relationship */
  readonly contentItems: ReadonlyArray<ContentItem>;
  /** An aggregated array relationship */
  readonly contentItems_aggregate: ContentItem_Aggregate;
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly requiredContentItems: ReadonlyArray<RequiredContentItem>;
  /** An aggregated array relationship */
  readonly requiredContentItems_aggregate: RequiredContentItem_Aggregate;
};


/** columns and relationships of "ContentType" */
export type ContentTypeContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentType" */
export type ContentTypeContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentType" */
export type ContentTypeRequiredContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentType" */
export type ContentTypeRequiredContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};

/** aggregated selection of "ContentType" */
export type ContentType_Aggregate = {
  readonly __typename?: 'ContentType_aggregate';
  readonly aggregate?: Maybe<ContentType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentType>;
};

/** aggregate fields of "ContentType" */
export type ContentType_Aggregate_Fields = {
  readonly __typename?: 'ContentType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentType_Max_Fields>;
  readonly min?: Maybe<ContentType_Min_Fields>;
};


/** aggregate fields of "ContentType" */
export type ContentType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentType" */
export type ContentType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentType_Max_Order_By>;
  readonly min?: Maybe<ContentType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentType" */
export type ContentType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentType_Insert_Input>;
  readonly on_conflict?: Maybe<ContentType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentType". All fields are combined with a logical 'AND'. */
export type ContentType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentType_Bool_Exp>>>;
  readonly _not?: Maybe<ContentType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentType_Bool_Exp>>>;
  readonly contentItems?: Maybe<ContentItem_Bool_Exp>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Bool_Exp>;
};

/** unique or primary key constraints on table "ContentType" */
export enum ContentType_Constraint {
  /** unique or primary key constraint */
  ContentTypePkey = 'ContentType_pkey'
}

export enum ContentType_Enum {
  /** Abstract Markdown text. */
  Abstract = 'ABSTRACT',
  /** List of content groups in the system. */
  ContentGroupList = 'CONTENT_GROUP_LIST',
  /** File for an image (stored by Clowdr). */
  ImageFile = 'IMAGE_FILE',
  /** URL to an image (embedded in Clowdr UI). */
  ImageUrl = 'IMAGE_URL',
  /** A generic URL. */
  Link = 'LINK',
  /** A URL for a link button. */
  LinkButton = 'LINK_BUTTON',
  /** File for a paper (stored by Clowdr). */
  PaperFile = 'PAPER_FILE',
  /** Link for a paper (preview is not embedded in Clowdr UI). */
  PaperLink = 'PAPER_LINK',
  /** URL to a paper (preview may be embedded in Clowdr UI e.g. PDF JS viewer). */
  PaperUrl = 'PAPER_URL',
  /** File for a poster image (stored by Clowdr). */
  PosterFile = 'POSTER_FILE',
  /** URL to a poster image (embedded in Clowdr UI). */
  PosterUrl = 'POSTER_URL',
  /** General-purpose Markdown text. */
  Text = 'TEXT',
  /** Video file to be broadcast. */
  VideoBroadcast = 'VIDEO_BROADCAST',
  /** Video file for counting down to a transition in a broadcast. */
  VideoCountdown = 'VIDEO_COUNTDOWN',
  /** File for a video (stored by Clowdr). */
  VideoFile = 'VIDEO_FILE',
  /** Video file for filler loop between events/during breaks in a broadcast. */
  VideoFiller = 'VIDEO_FILLER',
  /** Link to a video (video is not embedded in Clowdr UI). */
  VideoLink = 'VIDEO_LINK',
  /** Video file to be published in advance of the conference. */
  VideoPrepublish = 'VIDEO_PREPUBLISH',
  /** Video file for sponsors filler loop between events/during breaks in a broadcast. */
  VideoSponsorsFiller = 'VIDEO_SPONSORS_FILLER',
  /** Video file for titles introducing an event during a broadcast. */
  VideoTitles = 'VIDEO_TITLES',
  /** URL for a video (video is embedded in Clowdr UI). */
  VideoUrl = 'VIDEO_URL',
  /** Schedule view for the whole conference. */
  WholeSchedule = 'WHOLE_SCHEDULE',
  /** Data for a Zoom meeting. */
  Zoom = 'ZOOM'
}

/** expression to compare columns of type ContentType_enum. All fields are combined with logical 'AND'. */
export type ContentType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<ContentType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<ContentType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<ContentType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<ContentType_Enum>>;
};

/** input type for inserting data into table "ContentType" */
export type ContentType_Insert_Input = {
  readonly contentItems?: Maybe<ContentItem_Arr_Rel_Insert_Input>;
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type ContentType_Max_Fields = {
  readonly __typename?: 'ContentType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ContentType" */
export type ContentType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentType_Min_Fields = {
  readonly __typename?: 'ContentType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ContentType" */
export type ContentType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentType" */
export type ContentType_Mutation_Response = {
  readonly __typename?: 'ContentType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentType>;
};

/** input type for inserting object relation for remote table "ContentType" */
export type ContentType_Obj_Rel_Insert_Input = {
  readonly data: ContentType_Insert_Input;
  readonly on_conflict?: Maybe<ContentType_On_Conflict>;
};

/** on conflict condition type for table "ContentType" */
export type ContentType_On_Conflict = {
  readonly constraint: ContentType_Constraint;
  readonly update_columns: ReadonlyArray<ContentType_Update_Column>;
  readonly where?: Maybe<ContentType_Bool_Exp>;
};

/** ordering options when selecting data from "ContentType" */
export type ContentType_Order_By = {
  readonly contentItems_aggregate?: Maybe<ContentItem_Aggregate_Order_By>;
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly requiredContentItems_aggregate?: Maybe<RequiredContentItem_Aggregate_Order_By>;
};

/** primary key columns input for table: "ContentType" */
export type ContentType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "ContentType" */
export enum ContentType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "ContentType" */
export type ContentType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "ContentType" */
export enum ContentType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

export type CreateContentGroupRoomOutput = {
  readonly __typename?: 'CreateContentGroupRoomOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room>;
  readonly roomId?: Maybe<Scalars['String']>;
};

export type CreateRoomDmOutput = {
  readonly __typename?: 'CreateRoomDmOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room>;
  readonly roomId?: Maybe<Scalars['uuid']>;
};

export type EchoInput = {
  readonly message: Scalars['String'];
};

export type EchoOutput = {
  readonly __typename?: 'EchoOutput';
  readonly message: Scalars['String'];
};

/** columns and relationships of "Email" */
export type Email = {
  readonly __typename?: 'Email';
  readonly createdAt: Scalars['timestamptz'];
  readonly emailAddress: Scalars['String'];
  readonly htmlContents: Scalars['String'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly invitation?: Maybe<Invitation>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents: Scalars['String'];
  readonly reason: Scalars['String'];
  readonly retriesCount: Scalars['Int'];
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregated selection of "Email" */
export type Email_Aggregate = {
  readonly __typename?: 'Email_aggregate';
  readonly aggregate?: Maybe<Email_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Email>;
};

/** aggregate fields of "Email" */
export type Email_Aggregate_Fields = {
  readonly __typename?: 'Email_aggregate_fields';
  readonly avg?: Maybe<Email_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Email_Max_Fields>;
  readonly min?: Maybe<Email_Min_Fields>;
  readonly stddev?: Maybe<Email_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Email_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Email_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Email_Sum_Fields>;
  readonly var_pop?: Maybe<Email_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Email_Var_Samp_Fields>;
  readonly variance?: Maybe<Email_Variance_Fields>;
};


/** aggregate fields of "Email" */
export type Email_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Email_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Email" */
export type Email_Aggregate_Order_By = {
  readonly avg?: Maybe<Email_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Email_Max_Order_By>;
  readonly min?: Maybe<Email_Min_Order_By>;
  readonly stddev?: Maybe<Email_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Email_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Email_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Email_Sum_Order_By>;
  readonly var_pop?: Maybe<Email_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Email_Var_Samp_Order_By>;
  readonly variance?: Maybe<Email_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Email" */
export type Email_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Email_Insert_Input>;
  readonly on_conflict?: Maybe<Email_On_Conflict>;
};

/** aggregate avg on columns */
export type Email_Avg_Fields = {
  readonly __typename?: 'Email_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Email" */
export type Email_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Email". All fields are combined with a logical 'AND'. */
export type Email_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Email_Bool_Exp>>>;
  readonly _not?: Maybe<Email_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Email_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emailAddress?: Maybe<String_Comparison_Exp>;
  readonly htmlContents?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly invitation?: Maybe<Invitation_Bool_Exp>;
  readonly invitationId?: Maybe<Uuid_Comparison_Exp>;
  readonly plainTextContents?: Maybe<String_Comparison_Exp>;
  readonly reason?: Maybe<String_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly sentAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly subject?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Email" */
export enum Email_Constraint {
  /** unique or primary key constraint */
  EmailPkey = 'Email_pkey'
}

/** input type for incrementing integer column in table "Email" */
export type Email_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Email" */
export type Email_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitation?: Maybe<Invitation_Obj_Rel_Insert_Input>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Email_Max_Fields = {
  readonly __typename?: 'Email_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Email" */
export type Email_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Email_Min_Fields = {
  readonly __typename?: 'Email_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Email" */
export type Email_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "Email" */
export type Email_Mutation_Response = {
  readonly __typename?: 'Email_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Email>;
};

/** input type for inserting object relation for remote table "Email" */
export type Email_Obj_Rel_Insert_Input = {
  readonly data: Email_Insert_Input;
  readonly on_conflict?: Maybe<Email_On_Conflict>;
};

/** on conflict condition type for table "Email" */
export type Email_On_Conflict = {
  readonly constraint: Email_Constraint;
  readonly update_columns: ReadonlyArray<Email_Update_Column>;
  readonly where?: Maybe<Email_Bool_Exp>;
};

/** ordering options when selecting data from "Email" */
export type Email_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitation?: Maybe<Invitation_Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "Email" */
export type Email_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Email" */
export enum Email_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EmailAddress = 'emailAddress',
  /** column name */
  HtmlContents = 'htmlContents',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationId = 'invitationId',
  /** column name */
  PlainTextContents = 'plainTextContents',
  /** column name */
  Reason = 'reason',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "Email" */
export type Email_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Email_Stddev_Fields = {
  readonly __typename?: 'Email_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Email" */
export type Email_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Email_Stddev_Pop_Fields = {
  readonly __typename?: 'Email_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Email" */
export type Email_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Email_Stddev_Samp_Fields = {
  readonly __typename?: 'Email_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Email" */
export type Email_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Email_Sum_Fields = {
  readonly __typename?: 'Email_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Email" */
export type Email_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "Email" */
export enum Email_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EmailAddress = 'emailAddress',
  /** column name */
  HtmlContents = 'htmlContents',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationId = 'invitationId',
  /** column name */
  PlainTextContents = 'plainTextContents',
  /** column name */
  Reason = 'reason',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** aggregate var_pop on columns */
export type Email_Var_Pop_Fields = {
  readonly __typename?: 'Email_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Email" */
export type Email_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Email_Var_Samp_Fields = {
  readonly __typename?: 'Email_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Email" */
export type Email_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Email_Variance_Fields = {
  readonly __typename?: 'Email_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Email" */
export type Email_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** columns and relationships of "Event" */
export type Event = {
  readonly __typename?: 'Event';
  /** An object relationship */
  readonly broadcastContentItem?: Maybe<BroadcastContentItem>;
  /** An array relationship */
  readonly broadcasts: ReadonlyArray<Broadcast>;
  /** An aggregated array relationship */
  readonly broadcasts_aggregate: Broadcast_Aggregate;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentGroup?: Maybe<ContentGroup>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt: Scalars['timestamptz'];
  readonly durationSeconds: Scalars['Int'];
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<EventPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: EventPerson_Aggregate;
  /** An array relationship */
  readonly eventTags: ReadonlyArray<EventTag>;
  /** An aggregated array relationship */
  readonly eventTags_aggregate: EventTag_Aggregate;
  /** An object relationship */
  readonly eventVonageSession?: Maybe<EventVonageSession>;
  /** An array relationship */
  readonly executedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** An aggregated array relationship */
  readonly executedTransitions_aggregate: ExecutedTransitions_Aggregate;
  readonly id: Scalars['uuid'];
  readonly intendedRoomModeName: RoomMode_Enum;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly roomMode: RoomMode;
  readonly startTime: Scalars['timestamptz'];
  /** An array relationship */
  readonly transitions: ReadonlyArray<Transitions>;
  /** An aggregated array relationship */
  readonly transitions_aggregate: Transitions_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Event" */
export type EventBroadcastsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventBroadcasts_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventEventTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventEventTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};

/**
 * Current streams in event Vonage sessions.
 * 
 * 
 * columns and relationships of "EventParticipantStream"
 */
export type EventParticipantStream = {
  readonly __typename?: 'EventParticipantStream';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageConnectionId: Scalars['String'];
  readonly vonageStreamId: Scalars['String'];
  readonly vonageStreamType: Scalars['String'];
};

/** aggregated selection of "EventParticipantStream" */
export type EventParticipantStream_Aggregate = {
  readonly __typename?: 'EventParticipantStream_aggregate';
  readonly aggregate?: Maybe<EventParticipantStream_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventParticipantStream>;
};

/** aggregate fields of "EventParticipantStream" */
export type EventParticipantStream_Aggregate_Fields = {
  readonly __typename?: 'EventParticipantStream_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventParticipantStream_Max_Fields>;
  readonly min?: Maybe<EventParticipantStream_Min_Fields>;
};


/** aggregate fields of "EventParticipantStream" */
export type EventParticipantStream_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventParticipantStream" */
export type EventParticipantStream_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventParticipantStream_Max_Order_By>;
  readonly min?: Maybe<EventParticipantStream_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventParticipantStream" */
export type EventParticipantStream_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventParticipantStream_Insert_Input>;
  readonly on_conflict?: Maybe<EventParticipantStream_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventParticipantStream". All fields are combined with a logical 'AND'. */
export type EventParticipantStream_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventParticipantStream_Bool_Exp>>>;
  readonly _not?: Maybe<EventParticipantStream_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventParticipantStream_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageConnectionId?: Maybe<String_Comparison_Exp>;
  readonly vonageStreamId?: Maybe<String_Comparison_Exp>;
  readonly vonageStreamType?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventParticipantStream" */
export enum EventParticipantStream_Constraint {
  /** unique or primary key constraint */
  EventParticipantStreamEventIdAttendeeIdVonageStreamIdKey = 'EventParticipantStream_eventId_attendeeId_vonageStreamId_key',
  /** unique or primary key constraint */
  EventParticipantStreamPkey = 'EventParticipantStream_pkey'
}

/** input type for inserting data into table "EventParticipantStream" */
export type EventParticipantStream_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventParticipantStream_Max_Fields = {
  readonly __typename?: 'EventParticipantStream_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "EventParticipantStream" */
export type EventParticipantStream_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventParticipantStream_Min_Fields = {
  readonly __typename?: 'EventParticipantStream_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "EventParticipantStream" */
export type EventParticipantStream_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventParticipantStream" */
export type EventParticipantStream_Mutation_Response = {
  readonly __typename?: 'EventParticipantStream_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventParticipantStream>;
};

/** input type for inserting object relation for remote table "EventParticipantStream" */
export type EventParticipantStream_Obj_Rel_Insert_Input = {
  readonly data: EventParticipantStream_Insert_Input;
  readonly on_conflict?: Maybe<EventParticipantStream_On_Conflict>;
};

/** on conflict condition type for table "EventParticipantStream" */
export type EventParticipantStream_On_Conflict = {
  readonly constraint: EventParticipantStream_Constraint;
  readonly update_columns: ReadonlyArray<EventParticipantStream_Update_Column>;
  readonly where?: Maybe<EventParticipantStream_Bool_Exp>;
};

/** ordering options when selecting data from "EventParticipantStream" */
export type EventParticipantStream_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventParticipantStream" */
export type EventParticipantStream_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "EventParticipantStream" */
export enum EventParticipantStream_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId',
  /** column name */
  VonageStreamId = 'vonageStreamId',
  /** column name */
  VonageStreamType = 'vonageStreamType'
}

/** input type for updating data in table "EventParticipantStream" */
export type EventParticipantStream_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** update columns of table "EventParticipantStream" */
export enum EventParticipantStream_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId',
  /** column name */
  VonageStreamId = 'vonageStreamId',
  /** column name */
  VonageStreamType = 'vonageStreamType'
}

/** columns and relationships of "EventPerson" */
export type EventPerson = {
  readonly __typename?: 'EventPerson';
  readonly affiliation?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly attendee?: Maybe<Attendee>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  /** An object relationship */
  readonly eventPersonRole: EventPersonRole;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roleName: EventPersonRole_Enum;
  readonly updatedAt: Scalars['timestamptz'];
};

/** columns and relationships of "EventPersonRole" */
export type EventPersonRole = {
  readonly __typename?: 'EventPersonRole';
  readonly description: Scalars['String'];
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<EventPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: EventPerson_Aggregate;
  readonly name: Scalars['String'];
};


/** columns and relationships of "EventPersonRole" */
export type EventPersonRoleEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "EventPersonRole" */
export type EventPersonRoleEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};

/** aggregated selection of "EventPersonRole" */
export type EventPersonRole_Aggregate = {
  readonly __typename?: 'EventPersonRole_aggregate';
  readonly aggregate?: Maybe<EventPersonRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventPersonRole>;
};

/** aggregate fields of "EventPersonRole" */
export type EventPersonRole_Aggregate_Fields = {
  readonly __typename?: 'EventPersonRole_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventPersonRole_Max_Fields>;
  readonly min?: Maybe<EventPersonRole_Min_Fields>;
};


/** aggregate fields of "EventPersonRole" */
export type EventPersonRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventPersonRole" */
export type EventPersonRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventPersonRole_Max_Order_By>;
  readonly min?: Maybe<EventPersonRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventPersonRole" */
export type EventPersonRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventPersonRole_Insert_Input>;
  readonly on_conflict?: Maybe<EventPersonRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventPersonRole". All fields are combined with a logical 'AND'. */
export type EventPersonRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventPersonRole_Bool_Exp>>>;
  readonly _not?: Maybe<EventPersonRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventPersonRole_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly eventPeople?: Maybe<EventPerson_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventPersonRole" */
export enum EventPersonRole_Constraint {
  /** unique or primary key constraint */
  EventPersonRolePkey = 'EventPersonRole_pkey'
}

export enum EventPersonRole_Enum {
  /** Chair/moderator of the event */
  Chair = 'CHAIR',
  /** Viewer who has been given access to the event (e.g. to ask a question). */
  Participant = 'PARTICIPANT',
  /** A presenter. */
  Presenter = 'PRESENTER'
}

/** expression to compare columns of type EventPersonRole_enum. All fields are combined with logical 'AND'. */
export type EventPersonRole_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<EventPersonRole_Enum>;
  readonly _in?: Maybe<ReadonlyArray<EventPersonRole_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<EventPersonRole_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<EventPersonRole_Enum>>;
};

/** input type for inserting data into table "EventPersonRole" */
export type EventPersonRole_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly eventPeople?: Maybe<EventPerson_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventPersonRole_Max_Fields = {
  readonly __typename?: 'EventPersonRole_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "EventPersonRole" */
export type EventPersonRole_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventPersonRole_Min_Fields = {
  readonly __typename?: 'EventPersonRole_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "EventPersonRole" */
export type EventPersonRole_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventPersonRole" */
export type EventPersonRole_Mutation_Response = {
  readonly __typename?: 'EventPersonRole_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventPersonRole>;
};

/** input type for inserting object relation for remote table "EventPersonRole" */
export type EventPersonRole_Obj_Rel_Insert_Input = {
  readonly data: EventPersonRole_Insert_Input;
  readonly on_conflict?: Maybe<EventPersonRole_On_Conflict>;
};

/** on conflict condition type for table "EventPersonRole" */
export type EventPersonRole_On_Conflict = {
  readonly constraint: EventPersonRole_Constraint;
  readonly update_columns: ReadonlyArray<EventPersonRole_Update_Column>;
  readonly where?: Maybe<EventPersonRole_Bool_Exp>;
};

/** ordering options when selecting data from "EventPersonRole" */
export type EventPersonRole_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<EventPerson_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventPersonRole" */
export type EventPersonRole_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "EventPersonRole" */
export enum EventPersonRole_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "EventPersonRole" */
export type EventPersonRole_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "EventPersonRole" */
export enum EventPersonRole_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "EventPerson" */
export type EventPerson_Aggregate = {
  readonly __typename?: 'EventPerson_aggregate';
  readonly aggregate?: Maybe<EventPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventPerson>;
};

/** aggregate fields of "EventPerson" */
export type EventPerson_Aggregate_Fields = {
  readonly __typename?: 'EventPerson_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventPerson_Max_Fields>;
  readonly min?: Maybe<EventPerson_Min_Fields>;
};


/** aggregate fields of "EventPerson" */
export type EventPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventPerson" */
export type EventPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventPerson_Max_Order_By>;
  readonly min?: Maybe<EventPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventPerson" */
export type EventPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventPerson_Insert_Input>;
  readonly on_conflict?: Maybe<EventPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventPerson". All fields are combined with a logical 'AND'. */
export type EventPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventPerson_Bool_Exp>>>;
  readonly _not?: Maybe<EventPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventPerson_Bool_Exp>>>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly roleName?: Maybe<EventPersonRole_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventPerson" */
export enum EventPerson_Constraint {
  /** unique or primary key constraint */
  EventPersonEventIdAttendeeIdRoleNameKey = 'EventPerson_eventId_attendeeId_roleName_key',
  /** unique or primary key constraint */
  EventPersonEventIdNameAffiliationKey = 'EventPerson_eventId_name_affiliation_key',
  /** unique or primary key constraint */
  EventPersonPkey = 'EventPerson_pkey'
}

/** input type for inserting data into table "EventPerson" */
export type EventPerson_Insert_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Obj_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roleName?: Maybe<EventPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventPerson_Max_Fields = {
  readonly __typename?: 'EventPerson_max_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "EventPerson" */
export type EventPerson_Max_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventPerson_Min_Fields = {
  readonly __typename?: 'EventPerson_min_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "EventPerson" */
export type EventPerson_Min_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventPerson" */
export type EventPerson_Mutation_Response = {
  readonly __typename?: 'EventPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventPerson>;
};

/** input type for inserting object relation for remote table "EventPerson" */
export type EventPerson_Obj_Rel_Insert_Input = {
  readonly data: EventPerson_Insert_Input;
  readonly on_conflict?: Maybe<EventPerson_On_Conflict>;
};

/** on conflict condition type for table "EventPerson" */
export type EventPerson_On_Conflict = {
  readonly constraint: EventPerson_Constraint;
  readonly update_columns: ReadonlyArray<EventPerson_Update_Column>;
  readonly where?: Maybe<EventPerson_Bool_Exp>;
};

/** ordering options when selecting data from "EventPerson" */
export type EventPerson_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventPerson" */
export type EventPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "EventPerson" */
export enum EventPerson_Select_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoleName = 'roleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "EventPerson" */
export type EventPerson_Set_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roleName?: Maybe<EventPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "EventPerson" */
export enum EventPerson_Update_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoleName = 'roleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "EventRoomJoinRequest" */
export type EventRoomJoinRequest = {
  readonly __typename?: 'EventRoomJoinRequest';
  readonly approved: Scalars['Boolean'];
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  /** An object relationship */
  readonly eventPersonRole: EventPersonRole;
  readonly eventPersonRoleName: EventPersonRole_Enum;
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Aggregate = {
  readonly __typename?: 'EventRoomJoinRequest_aggregate';
  readonly aggregate?: Maybe<EventRoomJoinRequest_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventRoomJoinRequest>;
};

/** aggregate fields of "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Aggregate_Fields = {
  readonly __typename?: 'EventRoomJoinRequest_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventRoomJoinRequest_Max_Fields>;
  readonly min?: Maybe<EventRoomJoinRequest_Min_Fields>;
};


/** aggregate fields of "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventRoomJoinRequest_Max_Order_By>;
  readonly min?: Maybe<EventRoomJoinRequest_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventRoomJoinRequest_Insert_Input>;
  readonly on_conflict?: Maybe<EventRoomJoinRequest_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventRoomJoinRequest". All fields are combined with a logical 'AND'. */
export type EventRoomJoinRequest_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventRoomJoinRequest_Bool_Exp>>>;
  readonly _not?: Maybe<EventRoomJoinRequest_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventRoomJoinRequest_Bool_Exp>>>;
  readonly approved?: Maybe<Boolean_Comparison_Exp>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Bool_Exp>;
  readonly eventPersonRoleName?: Maybe<EventPersonRole_Enum_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventRoomJoinRequest" */
export enum EventRoomJoinRequest_Constraint {
  /** unique or primary key constraint */
  EventRoomJoinRequestEventIdAttendeeIdKey = 'EventRoomJoinRequest_eventId_attendeeId_key',
  /** unique or primary key constraint */
  EventRoomJoinRequestPkey = 'EventRoomJoinRequest_pkey'
}

/** input type for inserting data into table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Insert_Input = {
  readonly approved?: Maybe<Scalars['Boolean']>;
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Obj_Rel_Insert_Input>;
  readonly eventPersonRoleName?: Maybe<EventPersonRole_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventRoomJoinRequest_Max_Fields = {
  readonly __typename?: 'EventRoomJoinRequest_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventRoomJoinRequest_Min_Fields = {
  readonly __typename?: 'EventRoomJoinRequest_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Mutation_Response = {
  readonly __typename?: 'EventRoomJoinRequest_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventRoomJoinRequest>;
};

/** input type for inserting object relation for remote table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Obj_Rel_Insert_Input = {
  readonly data: EventRoomJoinRequest_Insert_Input;
  readonly on_conflict?: Maybe<EventRoomJoinRequest_On_Conflict>;
};

/** on conflict condition type for table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_On_Conflict = {
  readonly constraint: EventRoomJoinRequest_Constraint;
  readonly update_columns: ReadonlyArray<EventRoomJoinRequest_Update_Column>;
  readonly where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};

/** ordering options when selecting data from "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Order_By = {
  readonly approved?: Maybe<Order_By>;
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Order_By>;
  readonly eventPersonRoleName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "EventRoomJoinRequest" */
export enum EventRoomJoinRequest_Select_Column {
  /** column name */
  Approved = 'approved',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  EventPersonRoleName = 'eventPersonRoleName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Set_Input = {
  readonly approved?: Maybe<Scalars['Boolean']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRoleName?: Maybe<EventPersonRole_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "EventRoomJoinRequest" */
export enum EventRoomJoinRequest_Update_Column {
  /** column name */
  Approved = 'approved',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  EventPersonRoleName = 'eventPersonRoleName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "EventTag" */
export type EventTag = {
  readonly __typename?: 'EventTag';
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly tag: Tag;
  readonly tagId: Scalars['uuid'];
};

/** aggregated selection of "EventTag" */
export type EventTag_Aggregate = {
  readonly __typename?: 'EventTag_aggregate';
  readonly aggregate?: Maybe<EventTag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventTag>;
};

/** aggregate fields of "EventTag" */
export type EventTag_Aggregate_Fields = {
  readonly __typename?: 'EventTag_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventTag_Max_Fields>;
  readonly min?: Maybe<EventTag_Min_Fields>;
};


/** aggregate fields of "EventTag" */
export type EventTag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventTag" */
export type EventTag_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventTag_Max_Order_By>;
  readonly min?: Maybe<EventTag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventTag" */
export type EventTag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventTag_Insert_Input>;
  readonly on_conflict?: Maybe<EventTag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventTag". All fields are combined with a logical 'AND'. */
export type EventTag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventTag_Bool_Exp>>>;
  readonly _not?: Maybe<EventTag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventTag_Bool_Exp>>>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly tag?: Maybe<Tag_Bool_Exp>;
  readonly tagId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventTag" */
export enum EventTag_Constraint {
  /** unique or primary key constraint */
  EventTagPkey = 'EventTag_pkey',
  /** unique or primary key constraint */
  EventTagTagIdEventIdKey = 'EventTag_tagId_eventId_key'
}

/** input type for inserting data into table "EventTag" */
export type EventTag_Insert_Input = {
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tag?: Maybe<Tag_Obj_Rel_Insert_Input>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type EventTag_Max_Fields = {
  readonly __typename?: 'EventTag_max_fields';
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "EventTag" */
export type EventTag_Max_Order_By = {
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventTag_Min_Fields = {
  readonly __typename?: 'EventTag_min_fields';
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "EventTag" */
export type EventTag_Min_Order_By = {
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventTag" */
export type EventTag_Mutation_Response = {
  readonly __typename?: 'EventTag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventTag>;
};

/** input type for inserting object relation for remote table "EventTag" */
export type EventTag_Obj_Rel_Insert_Input = {
  readonly data: EventTag_Insert_Input;
  readonly on_conflict?: Maybe<EventTag_On_Conflict>;
};

/** on conflict condition type for table "EventTag" */
export type EventTag_On_Conflict = {
  readonly constraint: EventTag_Constraint;
  readonly update_columns: ReadonlyArray<EventTag_Update_Column>;
  readonly where?: Maybe<EventTag_Bool_Exp>;
};

/** ordering options when selecting data from "EventTag" */
export type EventTag_Order_By = {
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tag?: Maybe<Tag_Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventTag" */
export type EventTag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "EventTag" */
export enum EventTag_Select_Column {
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** input type for updating data in table "EventTag" */
export type EventTag_Set_Input = {
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "EventTag" */
export enum EventTag_Update_Column {
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** columns and relationships of "EventVonageSession" */
export type EventVonageSession = {
  readonly __typename?: 'EventVonageSession';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly sessionId: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "EventVonageSession" */
export type EventVonageSessionLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "EventVonageSession" */
export type EventVonageSession_Aggregate = {
  readonly __typename?: 'EventVonageSession_aggregate';
  readonly aggregate?: Maybe<EventVonageSession_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventVonageSession>;
};

/** aggregate fields of "EventVonageSession" */
export type EventVonageSession_Aggregate_Fields = {
  readonly __typename?: 'EventVonageSession_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventVonageSession_Max_Fields>;
  readonly min?: Maybe<EventVonageSession_Min_Fields>;
};


/** aggregate fields of "EventVonageSession" */
export type EventVonageSession_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventVonageSession" */
export type EventVonageSession_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventVonageSession_Max_Order_By>;
  readonly min?: Maybe<EventVonageSession_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type EventVonageSession_Append_Input = {
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "EventVonageSession" */
export type EventVonageSession_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventVonageSession_Insert_Input>;
  readonly on_conflict?: Maybe<EventVonageSession_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventVonageSession". All fields are combined with a logical 'AND'. */
export type EventVonageSession_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventVonageSession_Bool_Exp>>>;
  readonly _not?: Maybe<EventVonageSession_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventVonageSession_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly sessionId?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventVonageSession" */
export enum EventVonageSession_Constraint {
  /** unique or primary key constraint */
  EventVonageSessionEventIdKey = 'EventVonageSession_eventId_key',
  /** unique or primary key constraint */
  EventVonageSessionPkey = 'EventVonageSession_pkey',
  /** unique or primary key constraint */
  EventVonageSessionSessionIdKey = 'EventVonageSession_sessionId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type EventVonageSession_Delete_At_Path_Input = {
  readonly layoutData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type EventVonageSession_Delete_Elem_Input = {
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type EventVonageSession_Delete_Key_Input = {
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "EventVonageSession" */
export type EventVonageSession_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventVonageSession_Max_Fields = {
  readonly __typename?: 'EventVonageSession_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "EventVonageSession" */
export type EventVonageSession_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventVonageSession_Min_Fields = {
  readonly __typename?: 'EventVonageSession_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "EventVonageSession" */
export type EventVonageSession_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventVonageSession" */
export type EventVonageSession_Mutation_Response = {
  readonly __typename?: 'EventVonageSession_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventVonageSession>;
};

/** input type for inserting object relation for remote table "EventVonageSession" */
export type EventVonageSession_Obj_Rel_Insert_Input = {
  readonly data: EventVonageSession_Insert_Input;
  readonly on_conflict?: Maybe<EventVonageSession_On_Conflict>;
};

/** on conflict condition type for table "EventVonageSession" */
export type EventVonageSession_On_Conflict = {
  readonly constraint: EventVonageSession_Constraint;
  readonly update_columns: ReadonlyArray<EventVonageSession_Update_Column>;
  readonly where?: Maybe<EventVonageSession_Bool_Exp>;
};

/** ordering options when selecting data from "EventVonageSession" */
export type EventVonageSession_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventVonageSession" */
export type EventVonageSession_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type EventVonageSession_Prepend_Input = {
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "EventVonageSession" */
export enum EventVonageSession_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  SessionId = 'sessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "EventVonageSession" */
export type EventVonageSession_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "EventVonageSession" */
export enum EventVonageSession_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  SessionId = 'sessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "Event" */
export type Event_Aggregate = {
  readonly __typename?: 'Event_aggregate';
  readonly aggregate?: Maybe<Event_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Event>;
};

/** aggregate fields of "Event" */
export type Event_Aggregate_Fields = {
  readonly __typename?: 'Event_aggregate_fields';
  readonly avg?: Maybe<Event_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Event_Max_Fields>;
  readonly min?: Maybe<Event_Min_Fields>;
  readonly stddev?: Maybe<Event_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Event_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Event_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Event_Sum_Fields>;
  readonly var_pop?: Maybe<Event_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Event_Var_Samp_Fields>;
  readonly variance?: Maybe<Event_Variance_Fields>;
};


/** aggregate fields of "Event" */
export type Event_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Event_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Event" */
export type Event_Aggregate_Order_By = {
  readonly avg?: Maybe<Event_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Event_Max_Order_By>;
  readonly min?: Maybe<Event_Min_Order_By>;
  readonly stddev?: Maybe<Event_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Event_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Event_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Event_Sum_Order_By>;
  readonly var_pop?: Maybe<Event_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Event_Var_Samp_Order_By>;
  readonly variance?: Maybe<Event_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Event" */
export type Event_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Event_Insert_Input>;
  readonly on_conflict?: Maybe<Event_On_Conflict>;
};

/** aggregate avg on columns */
export type Event_Avg_Fields = {
  readonly __typename?: 'Event_avg_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Event" */
export type Event_Avg_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Event". All fields are combined with a logical 'AND'. */
export type Event_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Event_Bool_Exp>>>;
  readonly _not?: Maybe<Event_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Event_Bool_Exp>>>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly broadcasts?: Maybe<Broadcast_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly durationSeconds?: Maybe<Int_Comparison_Exp>;
  readonly endTime?: Maybe<Timestamptz_Comparison_Exp>;
  readonly eventPeople?: Maybe<EventPerson_Bool_Exp>;
  readonly eventTags?: Maybe<EventTag_Bool_Exp>;
  readonly eventVonageSession?: Maybe<EventVonageSession_Bool_Exp>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly intendedRoomModeName?: Maybe<RoomMode_Enum_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly roomMode?: Maybe<RoomMode_Bool_Exp>;
  readonly startTime?: Maybe<Timestamptz_Comparison_Exp>;
  readonly transitions?: Maybe<Transitions_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Event" */
export enum Event_Constraint {
  /** unique or primary key constraint */
  EventPkey = 'Event_pkey'
}

/** input type for incrementing integer column in table "Event" */
export type Event_Inc_Input = {
  readonly durationSeconds?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Event" */
export type Event_Insert_Input = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly broadcasts?: Maybe<Broadcast_Arr_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly eventPeople?: Maybe<EventPerson_Arr_Rel_Insert_Input>;
  readonly eventTags?: Maybe<EventTag_Arr_Rel_Insert_Input>;
  readonly eventVonageSession?: Maybe<EventVonageSession_Obj_Rel_Insert_Input>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly intendedRoomModeName?: Maybe<RoomMode_Enum>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly roomMode?: Maybe<RoomMode_Obj_Rel_Insert_Input>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly transitions?: Maybe<Transitions_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Event_Max_Fields = {
  readonly __typename?: 'Event_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Event" */
export type Event_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Event_Min_Fields = {
  readonly __typename?: 'Event_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Event" */
export type Event_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Event" */
export type Event_Mutation_Response = {
  readonly __typename?: 'Event_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Event>;
};

/** input type for inserting object relation for remote table "Event" */
export type Event_Obj_Rel_Insert_Input = {
  readonly data: Event_Insert_Input;
  readonly on_conflict?: Maybe<Event_On_Conflict>;
};

/** on conflict condition type for table "Event" */
export type Event_On_Conflict = {
  readonly constraint: Event_Constraint;
  readonly update_columns: ReadonlyArray<Event_Update_Column>;
  readonly where?: Maybe<Event_Bool_Exp>;
};

/** ordering options when selecting data from "Event" */
export type Event_Order_By = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly broadcasts_aggregate?: Maybe<Broadcast_Aggregate_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<EventPerson_Aggregate_Order_By>;
  readonly eventTags_aggregate?: Maybe<EventTag_Aggregate_Order_By>;
  readonly eventVonageSession?: Maybe<EventVonageSession_Order_By>;
  readonly executedTransitions_aggregate?: Maybe<ExecutedTransitions_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly intendedRoomModeName?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly roomMode?: Maybe<RoomMode_Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly transitions_aggregate?: Maybe<Transitions_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Event" */
export type Event_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Event" */
export enum Event_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DurationSeconds = 'durationSeconds',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  Id = 'id',
  /** column name */
  IntendedRoomModeName = 'intendedRoomModeName',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Event" */
export type Event_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly intendedRoomModeName?: Maybe<RoomMode_Enum>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Event_Stddev_Fields = {
  readonly __typename?: 'Event_stddev_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Event" */
export type Event_Stddev_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Event_Stddev_Pop_Fields = {
  readonly __typename?: 'Event_stddev_pop_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Event" */
export type Event_Stddev_Pop_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Event_Stddev_Samp_Fields = {
  readonly __typename?: 'Event_stddev_samp_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Event" */
export type Event_Stddev_Samp_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Event_Sum_Fields = {
  readonly __typename?: 'Event_sum_fields';
  readonly durationSeconds?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Event" */
export type Event_Sum_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** update columns of table "Event" */
export enum Event_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DurationSeconds = 'durationSeconds',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  Id = 'id',
  /** column name */
  IntendedRoomModeName = 'intendedRoomModeName',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Event_Var_Pop_Fields = {
  readonly __typename?: 'Event_var_pop_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Event" */
export type Event_Var_Pop_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Event_Var_Samp_Fields = {
  readonly __typename?: 'Event_var_samp_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Event" */
export type Event_Var_Samp_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Event_Variance_Fields = {
  readonly __typename?: 'Event_variance_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Event" */
export type Event_Variance_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** columns and relationships of "ExecutedTransitions" */
export type ExecutedTransitions = {
  readonly __typename?: 'ExecutedTransitions';
  readonly broadcastContentId: Scalars['uuid'];
  /** An object relationship */
  readonly broadcastContentItem: BroadcastContentItem;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  readonly time: Scalars['timestamptz'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "ExecutedTransitions" */
export type ExecutedTransitions_Aggregate = {
  readonly __typename?: 'ExecutedTransitions_aggregate';
  readonly aggregate?: Maybe<ExecutedTransitions_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ExecutedTransitions>;
};

/** aggregate fields of "ExecutedTransitions" */
export type ExecutedTransitions_Aggregate_Fields = {
  readonly __typename?: 'ExecutedTransitions_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ExecutedTransitions_Max_Fields>;
  readonly min?: Maybe<ExecutedTransitions_Min_Fields>;
};


/** aggregate fields of "ExecutedTransitions" */
export type ExecutedTransitions_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ExecutedTransitions" */
export type ExecutedTransitions_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ExecutedTransitions_Max_Order_By>;
  readonly min?: Maybe<ExecutedTransitions_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ExecutedTransitions" */
export type ExecutedTransitions_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ExecutedTransitions_Insert_Input>;
  readonly on_conflict?: Maybe<ExecutedTransitions_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ExecutedTransitions". All fields are combined with a logical 'AND'. */
export type ExecutedTransitions_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ExecutedTransitions_Bool_Exp>>>;
  readonly _not?: Maybe<ExecutedTransitions_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ExecutedTransitions_Bool_Exp>>>;
  readonly broadcastContentId?: Maybe<Uuid_Comparison_Exp>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly time?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "ExecutedTransitions" */
export enum ExecutedTransitions_Constraint {
  /** unique or primary key constraint */
  ExecutedTransitionsPkey = 'ExecutedTransitions_pkey'
}

/** input type for inserting data into table "ExecutedTransitions" */
export type ExecutedTransitions_Insert_Input = {
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type ExecutedTransitions_Max_Fields = {
  readonly __typename?: 'ExecutedTransitions_max_fields';
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ExecutedTransitions" */
export type ExecutedTransitions_Max_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ExecutedTransitions_Min_Fields = {
  readonly __typename?: 'ExecutedTransitions_min_fields';
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ExecutedTransitions" */
export type ExecutedTransitions_Min_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ExecutedTransitions" */
export type ExecutedTransitions_Mutation_Response = {
  readonly __typename?: 'ExecutedTransitions_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ExecutedTransitions>;
};

/** input type for inserting object relation for remote table "ExecutedTransitions" */
export type ExecutedTransitions_Obj_Rel_Insert_Input = {
  readonly data: ExecutedTransitions_Insert_Input;
  readonly on_conflict?: Maybe<ExecutedTransitions_On_Conflict>;
};

/** on conflict condition type for table "ExecutedTransitions" */
export type ExecutedTransitions_On_Conflict = {
  readonly constraint: ExecutedTransitions_Constraint;
  readonly update_columns: ReadonlyArray<ExecutedTransitions_Update_Column>;
  readonly where?: Maybe<ExecutedTransitions_Bool_Exp>;
};

/** ordering options when selecting data from "ExecutedTransitions" */
export type ExecutedTransitions_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "ExecutedTransitions" */
export type ExecutedTransitions_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ExecutedTransitions" */
export enum ExecutedTransitions_Select_Column {
  /** column name */
  BroadcastContentId = 'broadcastContentId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "ExecutedTransitions" */
export type ExecutedTransitions_Set_Input = {
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ExecutedTransitions" */
export enum ExecutedTransitions_Update_Column {
  /** column name */
  BroadcastContentId = 'broadcastContentId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "FlatUnauthPermission" */
export type FlatUnauthPermission = {
  readonly __typename?: 'FlatUnauthPermission';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** aggregated selection of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate = {
  readonly __typename?: 'FlatUnauthPermission_aggregate';
  readonly aggregate?: Maybe<FlatUnauthPermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<FlatUnauthPermission>;
};

/** aggregate fields of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_Fields = {
  readonly __typename?: 'FlatUnauthPermission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<FlatUnauthPermission_Max_Fields>;
  readonly min?: Maybe<FlatUnauthPermission_Min_Fields>;
};


/** aggregate fields of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<FlatUnauthPermission_Max_Order_By>;
  readonly min?: Maybe<FlatUnauthPermission_Min_Order_By>;
};

/** Boolean expression to filter rows from the table "FlatUnauthPermission". All fields are combined with a logical 'AND'. */
export type FlatUnauthPermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<FlatUnauthPermission_Bool_Exp>>>;
  readonly _not?: Maybe<FlatUnauthPermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<FlatUnauthPermission_Bool_Exp>>>;
  readonly permission_name?: Maybe<String_Comparison_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type FlatUnauthPermission_Max_Fields = {
  readonly __typename?: 'FlatUnauthPermission_max_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Max_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type FlatUnauthPermission_Min_Fields = {
  readonly __typename?: 'FlatUnauthPermission_min_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Min_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** ordering options when selecting data from "FlatUnauthPermission" */
export type FlatUnauthPermission_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** select columns of table "FlatUnauthPermission" */
export enum FlatUnauthPermission_Select_Column {
  /** column name */
  PermissionName = 'permission_name',
  /** column name */
  Slug = 'slug'
}

/** columns and relationships of "FlatUserPermission" */
export type FlatUserPermission = {
  readonly __typename?: 'FlatUserPermission';
  /** An object relationship */
  readonly conference?: Maybe<Conference>;
  /** An object relationship */
  readonly permission?: Maybe<Permission>;
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** aggregated selection of "FlatUserPermission" */
export type FlatUserPermission_Aggregate = {
  readonly __typename?: 'FlatUserPermission_aggregate';
  readonly aggregate?: Maybe<FlatUserPermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<FlatUserPermission>;
};

/** aggregate fields of "FlatUserPermission" */
export type FlatUserPermission_Aggregate_Fields = {
  readonly __typename?: 'FlatUserPermission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<FlatUserPermission_Max_Fields>;
  readonly min?: Maybe<FlatUserPermission_Min_Fields>;
};


/** aggregate fields of "FlatUserPermission" */
export type FlatUserPermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FlatUserPermission" */
export type FlatUserPermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<FlatUserPermission_Max_Order_By>;
  readonly min?: Maybe<FlatUserPermission_Min_Order_By>;
};

/** Boolean expression to filter rows from the table "FlatUserPermission". All fields are combined with a logical 'AND'. */
export type FlatUserPermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<FlatUserPermission_Bool_Exp>>>;
  readonly _not?: Maybe<FlatUserPermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<FlatUserPermission_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly permission?: Maybe<Permission_Bool_Exp>;
  readonly permission_name?: Maybe<String_Comparison_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly user_id?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type FlatUserPermission_Max_Fields = {
  readonly __typename?: 'FlatUserPermission_max_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "FlatUserPermission" */
export type FlatUserPermission_Max_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type FlatUserPermission_Min_Fields = {
  readonly __typename?: 'FlatUserPermission_min_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "FlatUserPermission" */
export type FlatUserPermission_Min_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** ordering options when selecting data from "FlatUserPermission" */
export type FlatUserPermission_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly permission?: Maybe<Permission_Order_By>;
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** select columns of table "FlatUserPermission" */
export enum FlatUserPermission_Select_Column {
  /** column name */
  PermissionName = 'permission_name',
  /** column name */
  Slug = 'slug',
  /** column name */
  UserId = 'user_id'
}

/** expression to compare columns of type Float. All fields are combined with logical 'AND'. */
export type Float_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Float']>;
  readonly _gt?: Maybe<Scalars['Float']>;
  readonly _gte?: Maybe<Scalars['Float']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Float']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Float']>;
  readonly _lte?: Maybe<Scalars['Float']>;
  readonly _neq?: Maybe<Scalars['Float']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Float']>>;
};

export type GetContentItemOutput = {
  readonly __typename?: 'GetContentItemOutput';
  readonly contentGroupTitle: Scalars['String'];
  readonly contentTypeName: Scalars['String'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['String'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name: Scalars['String'];
};

export type GetUploadAgreementOutput = {
  readonly __typename?: 'GetUploadAgreementOutput';
  readonly agreementText?: Maybe<Scalars['String']>;
};

/** columns and relationships of "Group" */
export type Group = {
  readonly __typename?: 'Group';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly enabled: Scalars['Boolean'];
  /** An array relationship */
  readonly groupAttendees: ReadonlyArray<GroupAttendee>;
  /** An aggregated array relationship */
  readonly groupAttendees_aggregate: GroupAttendee_Aggregate;
  /** An array relationship */
  readonly groupRoles: ReadonlyArray<GroupRole>;
  /** An aggregated array relationship */
  readonly groupRoles_aggregate: GroupRole_Aggregate;
  readonly id: Scalars['uuid'];
  readonly includeUnauthenticated: Scalars['Boolean'];
  readonly name: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Group" */
export type GroupGroupAttendeesArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** columns and relationships of "Group" */
export type GroupGroupAttendees_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** columns and relationships of "Group" */
export type GroupGroupRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** columns and relationships of "Group" */
export type GroupGroupRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};

/** columns and relationships of "GroupAttendee" */
export type GroupAttendee = {
  readonly __typename?: 'GroupAttendee';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly group: Group;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "GroupAttendee" */
export type GroupAttendee_Aggregate = {
  readonly __typename?: 'GroupAttendee_aggregate';
  readonly aggregate?: Maybe<GroupAttendee_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<GroupAttendee>;
};

/** aggregate fields of "GroupAttendee" */
export type GroupAttendee_Aggregate_Fields = {
  readonly __typename?: 'GroupAttendee_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<GroupAttendee_Max_Fields>;
  readonly min?: Maybe<GroupAttendee_Min_Fields>;
};


/** aggregate fields of "GroupAttendee" */
export type GroupAttendee_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "GroupAttendee" */
export type GroupAttendee_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<GroupAttendee_Max_Order_By>;
  readonly min?: Maybe<GroupAttendee_Min_Order_By>;
};

/** input type for inserting array relation for remote table "GroupAttendee" */
export type GroupAttendee_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<GroupAttendee_Insert_Input>;
  readonly on_conflict?: Maybe<GroupAttendee_On_Conflict>;
};

/** Boolean expression to filter rows from the table "GroupAttendee". All fields are combined with a logical 'AND'. */
export type GroupAttendee_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<GroupAttendee_Bool_Exp>>>;
  readonly _not?: Maybe<GroupAttendee_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<GroupAttendee_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly group?: Maybe<Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "GroupAttendee" */
export enum GroupAttendee_Constraint {
  /** unique or primary key constraint */
  GroupAttendeeGroupIdAttendeeIdKey = 'GroupAttendee_groupId_attendeeId_key',
  /** unique or primary key constraint */
  GroupAttendeePkey = 'GroupAttendee_pkey'
}

/** input type for inserting data into table "GroupAttendee" */
export type GroupAttendee_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly group?: Maybe<Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type GroupAttendee_Max_Fields = {
  readonly __typename?: 'GroupAttendee_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "GroupAttendee" */
export type GroupAttendee_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type GroupAttendee_Min_Fields = {
  readonly __typename?: 'GroupAttendee_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "GroupAttendee" */
export type GroupAttendee_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "GroupAttendee" */
export type GroupAttendee_Mutation_Response = {
  readonly __typename?: 'GroupAttendee_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<GroupAttendee>;
};

/** input type for inserting object relation for remote table "GroupAttendee" */
export type GroupAttendee_Obj_Rel_Insert_Input = {
  readonly data: GroupAttendee_Insert_Input;
  readonly on_conflict?: Maybe<GroupAttendee_On_Conflict>;
};

/** on conflict condition type for table "GroupAttendee" */
export type GroupAttendee_On_Conflict = {
  readonly constraint: GroupAttendee_Constraint;
  readonly update_columns: ReadonlyArray<GroupAttendee_Update_Column>;
  readonly where?: Maybe<GroupAttendee_Bool_Exp>;
};

/** ordering options when selecting data from "GroupAttendee" */
export type GroupAttendee_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly group?: Maybe<Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "GroupAttendee" */
export type GroupAttendee_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "GroupAttendee" */
export enum GroupAttendee_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "GroupAttendee" */
export type GroupAttendee_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "GroupAttendee" */
export enum GroupAttendee_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "GroupRole" */
export type GroupRole = {
  readonly __typename?: 'GroupRole';
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly group: Group;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly role: Role;
  readonly roleId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "GroupRole" */
export type GroupRole_Aggregate = {
  readonly __typename?: 'GroupRole_aggregate';
  readonly aggregate?: Maybe<GroupRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<GroupRole>;
};

/** aggregate fields of "GroupRole" */
export type GroupRole_Aggregate_Fields = {
  readonly __typename?: 'GroupRole_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<GroupRole_Max_Fields>;
  readonly min?: Maybe<GroupRole_Min_Fields>;
};


/** aggregate fields of "GroupRole" */
export type GroupRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "GroupRole" */
export type GroupRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<GroupRole_Max_Order_By>;
  readonly min?: Maybe<GroupRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "GroupRole" */
export type GroupRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<GroupRole_Insert_Input>;
  readonly on_conflict?: Maybe<GroupRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "GroupRole". All fields are combined with a logical 'AND'. */
export type GroupRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<GroupRole_Bool_Exp>>>;
  readonly _not?: Maybe<GroupRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<GroupRole_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly group?: Maybe<Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly role?: Maybe<Role_Bool_Exp>;
  readonly roleId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "GroupRole" */
export enum GroupRole_Constraint {
  /** unique or primary key constraint */
  GroupRoleGroupIdRoleIdKey = 'GroupRole_groupId_roleId_key',
  /** unique or primary key constraint */
  GroupRolePkey = 'GroupRole_pkey'
}

/** input type for inserting data into table "GroupRole" */
export type GroupRole_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly group?: Maybe<Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly role?: Maybe<Role_Obj_Rel_Insert_Input>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type GroupRole_Max_Fields = {
  readonly __typename?: 'GroupRole_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "GroupRole" */
export type GroupRole_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type GroupRole_Min_Fields = {
  readonly __typename?: 'GroupRole_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "GroupRole" */
export type GroupRole_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "GroupRole" */
export type GroupRole_Mutation_Response = {
  readonly __typename?: 'GroupRole_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<GroupRole>;
};

/** input type for inserting object relation for remote table "GroupRole" */
export type GroupRole_Obj_Rel_Insert_Input = {
  readonly data: GroupRole_Insert_Input;
  readonly on_conflict?: Maybe<GroupRole_On_Conflict>;
};

/** on conflict condition type for table "GroupRole" */
export type GroupRole_On_Conflict = {
  readonly constraint: GroupRole_Constraint;
  readonly update_columns: ReadonlyArray<GroupRole_Update_Column>;
  readonly where?: Maybe<GroupRole_Bool_Exp>;
};

/** ordering options when selecting data from "GroupRole" */
export type GroupRole_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly group?: Maybe<Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly role?: Maybe<Role_Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "GroupRole" */
export type GroupRole_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "GroupRole" */
export enum GroupRole_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "GroupRole" */
export type GroupRole_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "GroupRole" */
export enum GroupRole_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "Group" */
export type Group_Aggregate = {
  readonly __typename?: 'Group_aggregate';
  readonly aggregate?: Maybe<Group_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Group>;
};

/** aggregate fields of "Group" */
export type Group_Aggregate_Fields = {
  readonly __typename?: 'Group_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Group_Max_Fields>;
  readonly min?: Maybe<Group_Min_Fields>;
};


/** aggregate fields of "Group" */
export type Group_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Group_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Group" */
export type Group_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Group_Max_Order_By>;
  readonly min?: Maybe<Group_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Group" */
export type Group_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Group_Insert_Input>;
  readonly on_conflict?: Maybe<Group_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Group". All fields are combined with a logical 'AND'. */
export type Group_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Group_Bool_Exp>>>;
  readonly _not?: Maybe<Group_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Group_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly enabled?: Maybe<Boolean_Comparison_Exp>;
  readonly groupAttendees?: Maybe<GroupAttendee_Bool_Exp>;
  readonly groupRoles?: Maybe<GroupRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly includeUnauthenticated?: Maybe<Boolean_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Group" */
export enum Group_Constraint {
  /** unique or primary key constraint */
  GroupConferenceIdNameKey = 'Group_conferenceId_name_key',
  /** unique or primary key constraint */
  GroupPkey = 'Group_pkey'
}

/** input type for inserting data into table "Group" */
export type Group_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly enabled?: Maybe<Scalars['Boolean']>;
  readonly groupAttendees?: Maybe<GroupAttendee_Arr_Rel_Insert_Input>;
  readonly groupRoles?: Maybe<GroupRole_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly includeUnauthenticated?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Group_Max_Fields = {
  readonly __typename?: 'Group_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Group" */
export type Group_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Group_Min_Fields = {
  readonly __typename?: 'Group_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Group" */
export type Group_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Group" */
export type Group_Mutation_Response = {
  readonly __typename?: 'Group_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Group>;
};

/** input type for inserting object relation for remote table "Group" */
export type Group_Obj_Rel_Insert_Input = {
  readonly data: Group_Insert_Input;
  readonly on_conflict?: Maybe<Group_On_Conflict>;
};

/** on conflict condition type for table "Group" */
export type Group_On_Conflict = {
  readonly constraint: Group_Constraint;
  readonly update_columns: ReadonlyArray<Group_Update_Column>;
  readonly where?: Maybe<Group_Bool_Exp>;
};

/** ordering options when selecting data from "Group" */
export type Group_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly enabled?: Maybe<Order_By>;
  readonly groupAttendees_aggregate?: Maybe<GroupAttendee_Aggregate_Order_By>;
  readonly groupRoles_aggregate?: Maybe<GroupRole_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly includeUnauthenticated?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Group" */
export type Group_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Group" */
export enum Group_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  IncludeUnauthenticated = 'includeUnauthenticated',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Group" */
export type Group_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly enabled?: Maybe<Scalars['Boolean']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly includeUnauthenticated?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Group" */
export enum Group_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  IncludeUnauthenticated = 'includeUnauthenticated',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "Hallway" */
export type Hallway = {
  readonly __typename?: 'Hallway';
  readonly colour: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroups: ReadonlyArray<ContentGroupHallway>;
  /** An aggregated array relationship */
  readonly contentGroups_aggregate: ContentGroupHallway_Aggregate;
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  readonly priority: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "Hallway" */
export type HallwayContentGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** columns and relationships of "Hallway" */
export type HallwayContentGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};

/** aggregated selection of "Hallway" */
export type Hallway_Aggregate = {
  readonly __typename?: 'Hallway_aggregate';
  readonly aggregate?: Maybe<Hallway_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Hallway>;
};

/** aggregate fields of "Hallway" */
export type Hallway_Aggregate_Fields = {
  readonly __typename?: 'Hallway_aggregate_fields';
  readonly avg?: Maybe<Hallway_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Hallway_Max_Fields>;
  readonly min?: Maybe<Hallway_Min_Fields>;
  readonly stddev?: Maybe<Hallway_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Hallway_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Hallway_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Hallway_Sum_Fields>;
  readonly var_pop?: Maybe<Hallway_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Hallway_Var_Samp_Fields>;
  readonly variance?: Maybe<Hallway_Variance_Fields>;
};


/** aggregate fields of "Hallway" */
export type Hallway_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Hallway" */
export type Hallway_Aggregate_Order_By = {
  readonly avg?: Maybe<Hallway_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Hallway_Max_Order_By>;
  readonly min?: Maybe<Hallway_Min_Order_By>;
  readonly stddev?: Maybe<Hallway_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Hallway_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Hallway_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Hallway_Sum_Order_By>;
  readonly var_pop?: Maybe<Hallway_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Hallway_Var_Samp_Order_By>;
  readonly variance?: Maybe<Hallway_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Hallway" */
export type Hallway_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Hallway_Insert_Input>;
  readonly on_conflict?: Maybe<Hallway_On_Conflict>;
};

/** aggregate avg on columns */
export type Hallway_Avg_Fields = {
  readonly __typename?: 'Hallway_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Hallway" */
export type Hallway_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Hallway". All fields are combined with a logical 'AND'. */
export type Hallway_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Hallway_Bool_Exp>>>;
  readonly _not?: Maybe<Hallway_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Hallway_Bool_Exp>>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroups?: Maybe<ContentGroupHallway_Bool_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Hallway" */
export enum Hallway_Constraint {
  /** unique or primary key constraint */
  HallwayNameConferenceIdKey = 'Hallway_name_conferenceId_key',
  /** unique or primary key constraint */
  HallwayPkey = 'Hallway_pkey'
}

/** input type for incrementing integer column in table "Hallway" */
export type Hallway_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Hallway" */
export type Hallway_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroups?: Maybe<ContentGroupHallway_Arr_Rel_Insert_Input>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Hallway_Max_Fields = {
  readonly __typename?: 'Hallway_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Hallway" */
export type Hallway_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Hallway_Min_Fields = {
  readonly __typename?: 'Hallway_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Hallway" */
export type Hallway_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "Hallway" */
export type Hallway_Mutation_Response = {
  readonly __typename?: 'Hallway_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Hallway>;
};

/** input type for inserting object relation for remote table "Hallway" */
export type Hallway_Obj_Rel_Insert_Input = {
  readonly data: Hallway_Insert_Input;
  readonly on_conflict?: Maybe<Hallway_On_Conflict>;
};

/** on conflict condition type for table "Hallway" */
export type Hallway_On_Conflict = {
  readonly constraint: Hallway_Constraint;
  readonly update_columns: ReadonlyArray<Hallway_Update_Column>;
  readonly where?: Maybe<Hallway_Bool_Exp>;
};

/** ordering options when selecting data from "Hallway" */
export type Hallway_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroups_aggregate?: Maybe<ContentGroupHallway_Aggregate_Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "Hallway" */
export type Hallway_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Hallway" */
export enum Hallway_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "Hallway" */
export type Hallway_Set_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Hallway_Stddev_Fields = {
  readonly __typename?: 'Hallway_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Hallway" */
export type Hallway_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Hallway_Stddev_Pop_Fields = {
  readonly __typename?: 'Hallway_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Hallway" */
export type Hallway_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Hallway_Stddev_Samp_Fields = {
  readonly __typename?: 'Hallway_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Hallway" */
export type Hallway_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Hallway_Sum_Fields = {
  readonly __typename?: 'Hallway_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Hallway" */
export type Hallway_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "Hallway" */
export enum Hallway_Update_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Hallway_Var_Pop_Fields = {
  readonly __typename?: 'Hallway_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Hallway" */
export type Hallway_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Hallway_Var_Samp_Fields = {
  readonly __typename?: 'Hallway_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Hallway" */
export type Hallway_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Hallway_Variance_Fields = {
  readonly __typename?: 'Hallway_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Hallway" */
export type Hallway_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "InputType" */
export type InputType = {
  readonly __typename?: 'InputType';
  /** An array relationship */
  readonly broadcastContentItems: ReadonlyArray<BroadcastContentItem>;
  /** An aggregated array relationship */
  readonly broadcastContentItems_aggregate: BroadcastContentItem_Aggregate;
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};


/** columns and relationships of "InputType" */
export type InputTypeBroadcastContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** columns and relationships of "InputType" */
export type InputTypeBroadcastContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};

/** aggregated selection of "InputType" */
export type InputType_Aggregate = {
  readonly __typename?: 'InputType_aggregate';
  readonly aggregate?: Maybe<InputType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<InputType>;
};

/** aggregate fields of "InputType" */
export type InputType_Aggregate_Fields = {
  readonly __typename?: 'InputType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<InputType_Max_Fields>;
  readonly min?: Maybe<InputType_Min_Fields>;
};


/** aggregate fields of "InputType" */
export type InputType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "InputType" */
export type InputType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<InputType_Max_Order_By>;
  readonly min?: Maybe<InputType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "InputType" */
export type InputType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<InputType_Insert_Input>;
  readonly on_conflict?: Maybe<InputType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "InputType". All fields are combined with a logical 'AND'. */
export type InputType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<InputType_Bool_Exp>>>;
  readonly _not?: Maybe<InputType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<InputType_Bool_Exp>>>;
  readonly broadcastContentItems?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "InputType" */
export enum InputType_Constraint {
  /** unique or primary key constraint */
  InputTypeNamePkey = 'InputTypeName_pkey'
}

export enum InputType_Enum {
  /** GIF image. */
  Gif = 'GIF',
  /** JPEG image (jay-peg). */
  Jpeg = 'JPEG',
  /** MP4 video file. */
  Mp4 = 'MP4',
  /** PNG image. */
  Png = 'PNG',
  /** RTMP stream in push mode. */
  RtmpPush = 'RTMP_PUSH',
  /** RTMP push from a Vonage Video API session. */
  VonageSession = 'VONAGE_SESSION'
}

/** expression to compare columns of type InputType_enum. All fields are combined with logical 'AND'. */
export type InputType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<InputType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<InputType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<InputType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<InputType_Enum>>;
};

/** input type for inserting data into table "InputType" */
export type InputType_Insert_Input = {
  readonly broadcastContentItems?: Maybe<BroadcastContentItem_Arr_Rel_Insert_Input>;
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type InputType_Max_Fields = {
  readonly __typename?: 'InputType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "InputType" */
export type InputType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type InputType_Min_Fields = {
  readonly __typename?: 'InputType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "InputType" */
export type InputType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "InputType" */
export type InputType_Mutation_Response = {
  readonly __typename?: 'InputType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<InputType>;
};

/** input type for inserting object relation for remote table "InputType" */
export type InputType_Obj_Rel_Insert_Input = {
  readonly data: InputType_Insert_Input;
  readonly on_conflict?: Maybe<InputType_On_Conflict>;
};

/** on conflict condition type for table "InputType" */
export type InputType_On_Conflict = {
  readonly constraint: InputType_Constraint;
  readonly update_columns: ReadonlyArray<InputType_Update_Column>;
  readonly where?: Maybe<InputType_Bool_Exp>;
};

/** ordering options when selecting data from "InputType" */
export type InputType_Order_By = {
  readonly broadcastContentItems_aggregate?: Maybe<BroadcastContentItem_Aggregate_Order_By>;
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "InputType" */
export type InputType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "InputType" */
export enum InputType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "InputType" */
export type InputType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "InputType" */
export enum InputType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** expression to compare columns of type Int. All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Int']>;
  readonly _gt?: Maybe<Scalars['Int']>;
  readonly _gte?: Maybe<Scalars['Int']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Int']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Int']>;
  readonly _lte?: Maybe<Scalars['Int']>;
  readonly _neq?: Maybe<Scalars['Int']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Int']>>;
};

/** columns and relationships of "Invitation" */
export type Invitation = {
  readonly __typename?: 'Invitation';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly emails: ReadonlyArray<Email>;
  /** An aggregated array relationship */
  readonly emails_aggregate: Email_Aggregate;
  /** A computed field, executes function "invitationhash" */
  readonly hash?: Maybe<Scalars['String']>;
  readonly id: Scalars['uuid'];
  readonly inviteCode: Scalars['uuid'];
  readonly invitedEmailAddress: Scalars['String'];
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
};


/** columns and relationships of "Invitation" */
export type InvitationEmailsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "Invitation" */
export type InvitationEmails_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};

export type InvitationConfirmationEmailInput = {
  readonly inviteCode: Scalars['uuid'];
};

export type InvitationConfirmationEmailOutput = {
  readonly __typename?: 'InvitationConfirmationEmailOutput';
  readonly sent: Scalars['Boolean'];
};

export type InvitationSendEmailResult = {
  readonly __typename?: 'InvitationSendEmailResult';
  readonly attendeeId: Scalars['String'];
  readonly sent: Scalars['Boolean'];
};

/** aggregated selection of "Invitation" */
export type Invitation_Aggregate = {
  readonly __typename?: 'Invitation_aggregate';
  readonly aggregate?: Maybe<Invitation_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Invitation>;
};

/** aggregate fields of "Invitation" */
export type Invitation_Aggregate_Fields = {
  readonly __typename?: 'Invitation_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Invitation_Max_Fields>;
  readonly min?: Maybe<Invitation_Min_Fields>;
};


/** aggregate fields of "Invitation" */
export type Invitation_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Invitation" */
export type Invitation_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Invitation_Max_Order_By>;
  readonly min?: Maybe<Invitation_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Invitation" */
export type Invitation_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Invitation_Insert_Input>;
  readonly on_conflict?: Maybe<Invitation_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Invitation". All fields are combined with a logical 'AND'. */
export type Invitation_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Invitation_Bool_Exp>>>;
  readonly _not?: Maybe<Invitation_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Invitation_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly confirmationCode?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emails?: Maybe<Email_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly inviteCode?: Maybe<Uuid_Comparison_Exp>;
  readonly invitedEmailAddress?: Maybe<String_Comparison_Exp>;
  readonly linkToUserId?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
};

/** unique or primary key constraints on table "Invitation" */
export enum Invitation_Constraint {
  /** unique or primary key constraint */
  InivitationAttendeeIdKey = 'Inivitation_attendeeId_key',
  /** unique or primary key constraint */
  InivitationConfirmationCodeKey = 'Inivitation_confirmationCode_key',
  /** unique or primary key constraint */
  InivitationInviteCodeKey = 'Inivitation_inviteCode_key',
  /** unique or primary key constraint */
  InivitationPkey = 'Inivitation_pkey'
}

/** input type for inserting data into table "Invitation" */
export type Invitation_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emails?: Maybe<Email_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Invitation_Max_Fields = {
  readonly __typename?: 'Invitation_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Invitation" */
export type Invitation_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Invitation_Min_Fields = {
  readonly __typename?: 'Invitation_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Invitation" */
export type Invitation_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Invitation" */
export type Invitation_Mutation_Response = {
  readonly __typename?: 'Invitation_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Invitation>;
};

/** input type for inserting object relation for remote table "Invitation" */
export type Invitation_Obj_Rel_Insert_Input = {
  readonly data: Invitation_Insert_Input;
  readonly on_conflict?: Maybe<Invitation_On_Conflict>;
};

/** on conflict condition type for table "Invitation" */
export type Invitation_On_Conflict = {
  readonly constraint: Invitation_Constraint;
  readonly update_columns: ReadonlyArray<Invitation_Update_Column>;
  readonly where?: Maybe<Invitation_Bool_Exp>;
};

/** ordering options when selecting data from "Invitation" */
export type Invitation_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly emails_aggregate?: Maybe<Email_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
};

/** primary key columns input for table: "Invitation" */
export type Invitation_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Invitation" */
export enum Invitation_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConfirmationCode = 'confirmationCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  InviteCode = 'inviteCode',
  /** column name */
  InvitedEmailAddress = 'invitedEmailAddress',
  /** column name */
  LinkToUserId = 'linkToUserId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Invitation" */
export type Invitation_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Invitation" */
export enum Invitation_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConfirmationCode = 'confirmationCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  InviteCode = 'inviteCode',
  /** column name */
  InvitedEmailAddress = 'invitedEmailAddress',
  /** column name */
  LinkToUserId = 'linkToUserId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "JobStatus" */
export type JobStatus = {
  readonly __typename?: 'JobStatus';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "JobStatus" */
export type JobStatus_Aggregate = {
  readonly __typename?: 'JobStatus_aggregate';
  readonly aggregate?: Maybe<JobStatus_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<JobStatus>;
};

/** aggregate fields of "JobStatus" */
export type JobStatus_Aggregate_Fields = {
  readonly __typename?: 'JobStatus_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<JobStatus_Max_Fields>;
  readonly min?: Maybe<JobStatus_Min_Fields>;
};


/** aggregate fields of "JobStatus" */
export type JobStatus_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "JobStatus" */
export type JobStatus_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<JobStatus_Max_Order_By>;
  readonly min?: Maybe<JobStatus_Min_Order_By>;
};

/** input type for inserting array relation for remote table "JobStatus" */
export type JobStatus_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<JobStatus_Insert_Input>;
  readonly on_conflict?: Maybe<JobStatus_On_Conflict>;
};

/** Boolean expression to filter rows from the table "JobStatus". All fields are combined with a logical 'AND'. */
export type JobStatus_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<JobStatus_Bool_Exp>>>;
  readonly _not?: Maybe<JobStatus_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<JobStatus_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "JobStatus" */
export enum JobStatus_Constraint {
  /** unique or primary key constraint */
  JobStatusPkey = 'JobStatus_pkey'
}

export enum JobStatus_Enum {
  /** Job completed successfully. */
  Completed = 'COMPLETED',
  /** Job is no longer valid. */
  Expired = 'EXPIRED',
  /** Job failed during execution. */
  Failed = 'FAILED',
  /** Job is currently in progress. */
  InProgress = 'IN_PROGRESS',
  /** Job has not yet started execution. */
  New = 'NEW'
}

/** expression to compare columns of type JobStatus_enum. All fields are combined with logical 'AND'. */
export type JobStatus_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<JobStatus_Enum>;
  readonly _in?: Maybe<ReadonlyArray<JobStatus_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<JobStatus_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<JobStatus_Enum>>;
};

/** input type for inserting data into table "JobStatus" */
export type JobStatus_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type JobStatus_Max_Fields = {
  readonly __typename?: 'JobStatus_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "JobStatus" */
export type JobStatus_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type JobStatus_Min_Fields = {
  readonly __typename?: 'JobStatus_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "JobStatus" */
export type JobStatus_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "JobStatus" */
export type JobStatus_Mutation_Response = {
  readonly __typename?: 'JobStatus_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<JobStatus>;
};

/** input type for inserting object relation for remote table "JobStatus" */
export type JobStatus_Obj_Rel_Insert_Input = {
  readonly data: JobStatus_Insert_Input;
  readonly on_conflict?: Maybe<JobStatus_On_Conflict>;
};

/** on conflict condition type for table "JobStatus" */
export type JobStatus_On_Conflict = {
  readonly constraint: JobStatus_Constraint;
  readonly update_columns: ReadonlyArray<JobStatus_Update_Column>;
  readonly where?: Maybe<JobStatus_Bool_Exp>;
};

/** ordering options when selecting data from "JobStatus" */
export type JobStatus_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "JobStatus" */
export type JobStatus_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "JobStatus" */
export enum JobStatus_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "JobStatus" */
export type JobStatus_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "JobStatus" */
export enum JobStatus_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

export type JoinEventVonageSessionOutput = {
  readonly __typename?: 'JoinEventVonageSessionOutput';
  readonly accessToken?: Maybe<Scalars['String']>;
};

export type JoinRoomVonageSessionOutput = {
  readonly __typename?: 'JoinRoomVonageSessionOutput';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly sessionId?: Maybe<Scalars['String']>;
};

/** columns and relationships of "MediaLiveChannel" */
export type MediaLiveChannel = {
  readonly __typename?: 'MediaLiveChannel';
  readonly cloudFrontDistributionId: Scalars['String'];
  readonly cloudFrontDomain: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly endpointUri: Scalars['String'];
  readonly id: Scalars['uuid'];
  readonly loopingMp4InputAttachmentName: Scalars['String'];
  readonly mediaLiveChannelId: Scalars['String'];
  readonly mediaPackageChannelId: Scalars['String'];
  readonly mp4InputAttachmentName: Scalars['String'];
  readonly mp4InputId: Scalars['String'];
  /** An object relationship */
  readonly room?: Maybe<Room>;
  readonly rtmpInputId: Scalars['String'];
  readonly rtmpInputUri: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageInputAttachmentName: Scalars['String'];
};

/** aggregated selection of "MediaLiveChannel" */
export type MediaLiveChannel_Aggregate = {
  readonly __typename?: 'MediaLiveChannel_aggregate';
  readonly aggregate?: Maybe<MediaLiveChannel_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<MediaLiveChannel>;
};

/** aggregate fields of "MediaLiveChannel" */
export type MediaLiveChannel_Aggregate_Fields = {
  readonly __typename?: 'MediaLiveChannel_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<MediaLiveChannel_Max_Fields>;
  readonly min?: Maybe<MediaLiveChannel_Min_Fields>;
};


/** aggregate fields of "MediaLiveChannel" */
export type MediaLiveChannel_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "MediaLiveChannel" */
export type MediaLiveChannel_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<MediaLiveChannel_Max_Order_By>;
  readonly min?: Maybe<MediaLiveChannel_Min_Order_By>;
};

/** input type for inserting array relation for remote table "MediaLiveChannel" */
export type MediaLiveChannel_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<MediaLiveChannel_Insert_Input>;
  readonly on_conflict?: Maybe<MediaLiveChannel_On_Conflict>;
};

/** Boolean expression to filter rows from the table "MediaLiveChannel". All fields are combined with a logical 'AND'. */
export type MediaLiveChannel_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<MediaLiveChannel_Bool_Exp>>>;
  readonly _not?: Maybe<MediaLiveChannel_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<MediaLiveChannel_Bool_Exp>>>;
  readonly cloudFrontDistributionId?: Maybe<String_Comparison_Exp>;
  readonly cloudFrontDomain?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endpointUri?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly loopingMp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mediaLiveChannelId?: Maybe<String_Comparison_Exp>;
  readonly mediaPackageChannelId?: Maybe<String_Comparison_Exp>;
  readonly mp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mp4InputId?: Maybe<String_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly rtmpInputId?: Maybe<String_Comparison_Exp>;
  readonly rtmpInputUri?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageInputAttachmentName?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "MediaLiveChannel" */
export enum MediaLiveChannel_Constraint {
  /** unique or primary key constraint */
  MediaLiveChannelPkey = 'MediaLiveChannel_pkey'
}

/** input type for inserting data into table "MediaLiveChannel" */
export type MediaLiveChannel_Insert_Input = {
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly rtmpInputId?: Maybe<Scalars['String']>;
  readonly rtmpInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageInputAttachmentName?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type MediaLiveChannel_Max_Fields = {
  readonly __typename?: 'MediaLiveChannel_max_fields';
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly rtmpInputId?: Maybe<Scalars['String']>;
  readonly rtmpInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageInputAttachmentName?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "MediaLiveChannel" */
export type MediaLiveChannel_Max_Order_By = {
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly rtmpInputId?: Maybe<Order_By>;
  readonly rtmpInputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageInputAttachmentName?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type MediaLiveChannel_Min_Fields = {
  readonly __typename?: 'MediaLiveChannel_min_fields';
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly rtmpInputId?: Maybe<Scalars['String']>;
  readonly rtmpInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageInputAttachmentName?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "MediaLiveChannel" */
export type MediaLiveChannel_Min_Order_By = {
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly rtmpInputId?: Maybe<Order_By>;
  readonly rtmpInputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageInputAttachmentName?: Maybe<Order_By>;
};

/** response of any mutation on the table "MediaLiveChannel" */
export type MediaLiveChannel_Mutation_Response = {
  readonly __typename?: 'MediaLiveChannel_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<MediaLiveChannel>;
};

/** input type for inserting object relation for remote table "MediaLiveChannel" */
export type MediaLiveChannel_Obj_Rel_Insert_Input = {
  readonly data: MediaLiveChannel_Insert_Input;
  readonly on_conflict?: Maybe<MediaLiveChannel_On_Conflict>;
};

/** on conflict condition type for table "MediaLiveChannel" */
export type MediaLiveChannel_On_Conflict = {
  readonly constraint: MediaLiveChannel_Constraint;
  readonly update_columns: ReadonlyArray<MediaLiveChannel_Update_Column>;
  readonly where?: Maybe<MediaLiveChannel_Bool_Exp>;
};

/** ordering options when selecting data from "MediaLiveChannel" */
export type MediaLiveChannel_Order_By = {
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly rtmpInputId?: Maybe<Order_By>;
  readonly rtmpInputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageInputAttachmentName?: Maybe<Order_By>;
};

/** primary key columns input for table: "MediaLiveChannel" */
export type MediaLiveChannel_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "MediaLiveChannel" */
export enum MediaLiveChannel_Select_Column {
  /** column name */
  CloudFrontDistributionId = 'cloudFrontDistributionId',
  /** column name */
  CloudFrontDomain = 'cloudFrontDomain',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndpointUri = 'endpointUri',
  /** column name */
  Id = 'id',
  /** column name */
  LoopingMp4InputAttachmentName = 'loopingMp4InputAttachmentName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  MediaPackageChannelId = 'mediaPackageChannelId',
  /** column name */
  Mp4InputAttachmentName = 'mp4InputAttachmentName',
  /** column name */
  Mp4InputId = 'mp4InputId',
  /** column name */
  RtmpInputId = 'rtmpInputId',
  /** column name */
  RtmpInputUri = 'rtmpInputUri',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageInputAttachmentName = 'vonageInputAttachmentName'
}

/** input type for updating data in table "MediaLiveChannel" */
export type MediaLiveChannel_Set_Input = {
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly rtmpInputId?: Maybe<Scalars['String']>;
  readonly rtmpInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageInputAttachmentName?: Maybe<Scalars['String']>;
};

/** update columns of table "MediaLiveChannel" */
export enum MediaLiveChannel_Update_Column {
  /** column name */
  CloudFrontDistributionId = 'cloudFrontDistributionId',
  /** column name */
  CloudFrontDomain = 'cloudFrontDomain',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndpointUri = 'endpointUri',
  /** column name */
  Id = 'id',
  /** column name */
  LoopingMp4InputAttachmentName = 'loopingMp4InputAttachmentName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  MediaPackageChannelId = 'mediaPackageChannelId',
  /** column name */
  Mp4InputAttachmentName = 'mp4InputAttachmentName',
  /** column name */
  Mp4InputId = 'mp4InputId',
  /** column name */
  RtmpInputId = 'rtmpInputId',
  /** column name */
  RtmpInputUri = 'rtmpInputUri',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageInputAttachmentName = 'vonageInputAttachmentName'
}

/** columns and relationships of "OnlineStatus" */
export type OnlineStatus = {
  readonly __typename?: 'OnlineStatus';
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly isIncognito: Scalars['Boolean'];
  readonly lastSeen: Scalars['timestamptz'];
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user: User;
  readonly userId: Scalars['String'];
};

/** aggregated selection of "OnlineStatus" */
export type OnlineStatus_Aggregate = {
  readonly __typename?: 'OnlineStatus_aggregate';
  readonly aggregate?: Maybe<OnlineStatus_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<OnlineStatus>;
};

/** aggregate fields of "OnlineStatus" */
export type OnlineStatus_Aggregate_Fields = {
  readonly __typename?: 'OnlineStatus_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<OnlineStatus_Max_Fields>;
  readonly min?: Maybe<OnlineStatus_Min_Fields>;
};


/** aggregate fields of "OnlineStatus" */
export type OnlineStatus_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "OnlineStatus" */
export type OnlineStatus_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<OnlineStatus_Max_Order_By>;
  readonly min?: Maybe<OnlineStatus_Min_Order_By>;
};

/** input type for inserting array relation for remote table "OnlineStatus" */
export type OnlineStatus_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<OnlineStatus_Insert_Input>;
  readonly on_conflict?: Maybe<OnlineStatus_On_Conflict>;
};

/** Boolean expression to filter rows from the table "OnlineStatus". All fields are combined with a logical 'AND'. */
export type OnlineStatus_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<OnlineStatus_Bool_Exp>>>;
  readonly _not?: Maybe<OnlineStatus_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<OnlineStatus_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isIncognito?: Maybe<Boolean_Comparison_Exp>;
  readonly lastSeen?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "OnlineStatus" */
export enum OnlineStatus_Constraint {
  /** unique or primary key constraint */
  OnlineStatusPkey = 'OnlineStatus_pkey',
  /** unique or primary key constraint */
  OnlineStatusUserIdKey = 'OnlineStatus_userId_key'
}

/** input type for inserting data into table "OnlineStatus" */
export type OnlineStatus_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isIncognito?: Maybe<Scalars['Boolean']>;
  readonly lastSeen?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type OnlineStatus_Max_Fields = {
  readonly __typename?: 'OnlineStatus_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly lastSeen?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "OnlineStatus" */
export type OnlineStatus_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly lastSeen?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type OnlineStatus_Min_Fields = {
  readonly __typename?: 'OnlineStatus_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly lastSeen?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "OnlineStatus" */
export type OnlineStatus_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly lastSeen?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "OnlineStatus" */
export type OnlineStatus_Mutation_Response = {
  readonly __typename?: 'OnlineStatus_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<OnlineStatus>;
};

/** input type for inserting object relation for remote table "OnlineStatus" */
export type OnlineStatus_Obj_Rel_Insert_Input = {
  readonly data: OnlineStatus_Insert_Input;
  readonly on_conflict?: Maybe<OnlineStatus_On_Conflict>;
};

/** on conflict condition type for table "OnlineStatus" */
export type OnlineStatus_On_Conflict = {
  readonly constraint: OnlineStatus_Constraint;
  readonly update_columns: ReadonlyArray<OnlineStatus_Update_Column>;
  readonly where?: Maybe<OnlineStatus_Bool_Exp>;
};

/** ordering options when selecting data from "OnlineStatus" */
export type OnlineStatus_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isIncognito?: Maybe<Order_By>;
  readonly lastSeen?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "OnlineStatus" */
export type OnlineStatus_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "OnlineStatus" */
export enum OnlineStatus_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsIncognito = 'isIncognito',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "OnlineStatus" */
export type OnlineStatus_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isIncognito?: Maybe<Scalars['Boolean']>;
  readonly lastSeen?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** update columns of table "OnlineStatus" */
export enum OnlineStatus_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsIncognito = 'isIncognito',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** columns and relationships of "OriginatingData" */
export type OriginatingData = {
  readonly __typename?: 'OriginatingData';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroups: ReadonlyArray<ContentGroup>;
  /** An aggregated array relationship */
  readonly contentGroups_aggregate: ContentGroup_Aggregate;
  /** An array relationship */
  readonly contentItems: ReadonlyArray<ContentItem>;
  /** An aggregated array relationship */
  readonly contentItems_aggregate: ContentItem_Aggregate;
  /** An array relationship */
  readonly contentPeople: ReadonlyArray<ContentPerson>;
  /** An aggregated array relationship */
  readonly contentPeople_aggregate: ContentPerson_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly data?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<EventPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: EventPerson_Aggregate;
  /** An array relationship */
  readonly events: ReadonlyArray<Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Event_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly requiredContentItems: ReadonlyArray<RequiredContentItem>;
  /** An aggregated array relationship */
  readonly requiredContentItems_aggregate: RequiredContentItem_Aggregate;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Aggregate;
  readonly sourceId: Scalars['String'];
  /** An array relationship */
  readonly tags: ReadonlyArray<Tag>;
  /** An aggregated array relationship */
  readonly tags_aggregate: Tag_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataRequiredContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataRequiredContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};

/** aggregated selection of "OriginatingData" */
export type OriginatingData_Aggregate = {
  readonly __typename?: 'OriginatingData_aggregate';
  readonly aggregate?: Maybe<OriginatingData_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<OriginatingData>;
};

/** aggregate fields of "OriginatingData" */
export type OriginatingData_Aggregate_Fields = {
  readonly __typename?: 'OriginatingData_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<OriginatingData_Max_Fields>;
  readonly min?: Maybe<OriginatingData_Min_Fields>;
};


/** aggregate fields of "OriginatingData" */
export type OriginatingData_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "OriginatingData" */
export type OriginatingData_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<OriginatingData_Max_Order_By>;
  readonly min?: Maybe<OriginatingData_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type OriginatingData_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "OriginatingData" */
export type OriginatingData_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<OriginatingData_Insert_Input>;
  readonly on_conflict?: Maybe<OriginatingData_On_Conflict>;
};

/** Boolean expression to filter rows from the table "OriginatingData". All fields are combined with a logical 'AND'. */
export type OriginatingData_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<OriginatingData_Bool_Exp>>>;
  readonly _not?: Maybe<OriginatingData_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<OriginatingData_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroups?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentItems?: Maybe<ContentItem_Bool_Exp>;
  readonly contentPeople?: Maybe<ContentPerson_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly eventPeople?: Maybe<EventPerson_Bool_Exp>;
  readonly events?: Maybe<Event_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly rooms?: Maybe<Room_Bool_Exp>;
  readonly sourceId?: Maybe<String_Comparison_Exp>;
  readonly tags?: Maybe<Tag_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "OriginatingData" */
export enum OriginatingData_Constraint {
  /** unique or primary key constraint */
  OriginatingDataPkey = 'OriginatingData_pkey',
  /** unique or primary key constraint */
  OriginatingDataSourceIdConferenceIdKey = 'OriginatingData_sourceId_conferenceId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type OriginatingData_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type OriginatingData_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type OriginatingData_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "OriginatingData" */
export type OriginatingData_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroups?: Maybe<ContentGroup_Arr_Rel_Insert_Input>;
  readonly contentItems?: Maybe<ContentItem_Arr_Rel_Insert_Input>;
  readonly contentPeople?: Maybe<ContentPerson_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly eventPeople?: Maybe<EventPerson_Arr_Rel_Insert_Input>;
  readonly events?: Maybe<Event_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Arr_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Arr_Rel_Insert_Input>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly tags?: Maybe<Tag_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type OriginatingData_Max_Fields = {
  readonly __typename?: 'OriginatingData_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "OriginatingData" */
export type OriginatingData_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type OriginatingData_Min_Fields = {
  readonly __typename?: 'OriginatingData_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "OriginatingData" */
export type OriginatingData_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "OriginatingData" */
export type OriginatingData_Mutation_Response = {
  readonly __typename?: 'OriginatingData_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<OriginatingData>;
};

/** input type for inserting object relation for remote table "OriginatingData" */
export type OriginatingData_Obj_Rel_Insert_Input = {
  readonly data: OriginatingData_Insert_Input;
  readonly on_conflict?: Maybe<OriginatingData_On_Conflict>;
};

/** on conflict condition type for table "OriginatingData" */
export type OriginatingData_On_Conflict = {
  readonly constraint: OriginatingData_Constraint;
  readonly update_columns: ReadonlyArray<OriginatingData_Update_Column>;
  readonly where?: Maybe<OriginatingData_Bool_Exp>;
};

/** ordering options when selecting data from "OriginatingData" */
export type OriginatingData_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroups_aggregate?: Maybe<ContentGroup_Aggregate_Order_By>;
  readonly contentItems_aggregate?: Maybe<ContentItem_Aggregate_Order_By>;
  readonly contentPeople_aggregate?: Maybe<ContentPerson_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<EventPerson_Aggregate_Order_By>;
  readonly events_aggregate?: Maybe<Event_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly requiredContentItems_aggregate?: Maybe<RequiredContentItem_Aggregate_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Aggregate_Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly tags_aggregate?: Maybe<Tag_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "OriginatingData" */
export type OriginatingData_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type OriginatingData_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "OriginatingData" */
export enum OriginatingData_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "OriginatingData" */
export type OriginatingData_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "OriginatingData" */
export enum OriginatingData_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "Permission" */
export type Permission = {
  readonly __typename?: 'Permission';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rolePermissions: ReadonlyArray<RolePermission>;
  /** An aggregated array relationship */
  readonly rolePermissions_aggregate: RolePermission_Aggregate;
};


/** columns and relationships of "Permission" */
export type PermissionRolePermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** columns and relationships of "Permission" */
export type PermissionRolePermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};

/** aggregated selection of "Permission" */
export type Permission_Aggregate = {
  readonly __typename?: 'Permission_aggregate';
  readonly aggregate?: Maybe<Permission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permission>;
};

/** aggregate fields of "Permission" */
export type Permission_Aggregate_Fields = {
  readonly __typename?: 'Permission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Permission_Max_Fields>;
  readonly min?: Maybe<Permission_Min_Fields>;
};


/** aggregate fields of "Permission" */
export type Permission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Permission" */
export type Permission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permission_Max_Order_By>;
  readonly min?: Maybe<Permission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Permission" */
export type Permission_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permission_Insert_Input>;
  readonly on_conflict?: Maybe<Permission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Permission". All fields are combined with a logical 'AND'. */
export type Permission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Permission_Bool_Exp>>>;
  readonly _not?: Maybe<Permission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Permission_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rolePermissions?: Maybe<RolePermission_Bool_Exp>;
};

/** unique or primary key constraints on table "Permission" */
export enum Permission_Constraint {
  /** unique or primary key constraint */
  PermissionPkey = 'Permission_pkey'
}

export enum Permission_Enum {
  /** Manage (create/update/delete) conference attendees. */
  ConferenceManageAttendees = 'CONFERENCE_MANAGE_ATTENDEES',
  /** Manage Content tables. */
  ConferenceManageContent = 'CONFERENCE_MANAGE_CONTENT',
  /** Manage groups of a conference. */
  ConferenceManageGroups = 'CONFERENCE_MANAGE_GROUPS',
  /** Manage (update only) conference name, short name and slug. */
  ConferenceManageName = 'CONFERENCE_MANAGE_NAME',
  /** Manage roles of a conference. */
  ConferenceManageRoles = 'CONFERENCE_MANAGE_ROLES',
  /** Manage Schedule tables. */
  ConferenceManageSchedule = 'CONFERENCE_MANAGE_SCHEDULE',
  /** Moderate (update only) conference attendees. */
  ConferenceModerateAttendees = 'CONFERENCE_MODERATE_ATTENDEES',
  /** View the conference. */
  ConferenceView = 'CONFERENCE_VIEW',
  /** View conference attendees. */
  ConferenceViewAttendees = 'CONFERENCE_VIEW_ATTENDEES'
}

/** expression to compare columns of type Permission_enum. All fields are combined with logical 'AND'. */
export type Permission_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Permission_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Permission_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Permission_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Permission_Enum>>;
};

/** input type for inserting data into table "Permission" */
export type Permission_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rolePermissions?: Maybe<RolePermission_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Permission_Max_Fields = {
  readonly __typename?: 'Permission_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Permission" */
export type Permission_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permission_Min_Fields = {
  readonly __typename?: 'Permission_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Permission" */
export type Permission_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "Permission" */
export type Permission_Mutation_Response = {
  readonly __typename?: 'Permission_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Permission>;
};

/** input type for inserting object relation for remote table "Permission" */
export type Permission_Obj_Rel_Insert_Input = {
  readonly data: Permission_Insert_Input;
  readonly on_conflict?: Maybe<Permission_On_Conflict>;
};

/** on conflict condition type for table "Permission" */
export type Permission_On_Conflict = {
  readonly constraint: Permission_Constraint;
  readonly update_columns: ReadonlyArray<Permission_Update_Column>;
  readonly where?: Maybe<Permission_Bool_Exp>;
};

/** ordering options when selecting data from "Permission" */
export type Permission_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rolePermissions_aggregate?: Maybe<RolePermission_Aggregate_Order_By>;
};

/** primary key columns input for table: "Permission" */
export type Permission_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "Permission" */
export enum Permission_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "Permission" */
export type Permission_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "Permission" */
export enum Permission_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

export type ProfilePhotoUrlResponse = {
  readonly __typename?: 'ProfilePhotoURLResponse';
  readonly url: Scalars['String'];
};

export type ProtectedEchoOutput = {
  readonly __typename?: 'ProtectedEchoOutput';
  readonly message: Scalars['String'];
};

/** columns and relationships of "RequiredContentItem" */
export type RequiredContentItem = {
  readonly __typename?: 'RequiredContentItem';
  readonly accessToken?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentGroup: ContentGroup;
  readonly contentGroupId: Scalars['uuid'];
  /** A computed field, executes function "requireditem_content_group_title" */
  readonly contentGroupTitle?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly contentItem?: Maybe<ContentItem>;
  /** An object relationship */
  readonly contentType: ContentType;
  readonly contentTypeName: ContentType_Enum;
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly isHidden: Scalars['Boolean'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly uploaders: ReadonlyArray<Uploader>;
  /** An aggregated array relationship */
  readonly uploaders_aggregate: Uploader_Aggregate;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "RequiredContentItem" */
export type RequiredContentItemUploadersArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** columns and relationships of "RequiredContentItem" */
export type RequiredContentItemUploaders_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};

/** aggregated selection of "RequiredContentItem" */
export type RequiredContentItem_Aggregate = {
  readonly __typename?: 'RequiredContentItem_aggregate';
  readonly aggregate?: Maybe<RequiredContentItem_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RequiredContentItem>;
};

/** aggregate fields of "RequiredContentItem" */
export type RequiredContentItem_Aggregate_Fields = {
  readonly __typename?: 'RequiredContentItem_aggregate_fields';
  readonly avg?: Maybe<RequiredContentItem_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RequiredContentItem_Max_Fields>;
  readonly min?: Maybe<RequiredContentItem_Min_Fields>;
  readonly stddev?: Maybe<RequiredContentItem_Stddev_Fields>;
  readonly stddev_pop?: Maybe<RequiredContentItem_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<RequiredContentItem_Stddev_Samp_Fields>;
  readonly sum?: Maybe<RequiredContentItem_Sum_Fields>;
  readonly var_pop?: Maybe<RequiredContentItem_Var_Pop_Fields>;
  readonly var_samp?: Maybe<RequiredContentItem_Var_Samp_Fields>;
  readonly variance?: Maybe<RequiredContentItem_Variance_Fields>;
};


/** aggregate fields of "RequiredContentItem" */
export type RequiredContentItem_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RequiredContentItem" */
export type RequiredContentItem_Aggregate_Order_By = {
  readonly avg?: Maybe<RequiredContentItem_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RequiredContentItem_Max_Order_By>;
  readonly min?: Maybe<RequiredContentItem_Min_Order_By>;
  readonly stddev?: Maybe<RequiredContentItem_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<RequiredContentItem_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<RequiredContentItem_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<RequiredContentItem_Sum_Order_By>;
  readonly var_pop?: Maybe<RequiredContentItem_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<RequiredContentItem_Var_Samp_Order_By>;
  readonly variance?: Maybe<RequiredContentItem_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "RequiredContentItem" */
export type RequiredContentItem_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RequiredContentItem_Insert_Input>;
  readonly on_conflict?: Maybe<RequiredContentItem_On_Conflict>;
};

/** aggregate avg on columns */
export type RequiredContentItem_Avg_Fields = {
  readonly __typename?: 'RequiredContentItem_avg_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Avg_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "RequiredContentItem". All fields are combined with a logical 'AND'. */
export type RequiredContentItem_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RequiredContentItem_Bool_Exp>>>;
  readonly _not?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RequiredContentItem_Bool_Exp>>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItem?: Maybe<ContentItem_Bool_Exp>;
  readonly contentType?: Maybe<ContentType_Bool_Exp>;
  readonly contentTypeName?: Maybe<ContentType_Enum_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploaders?: Maybe<Uploader_Bool_Exp>;
  readonly uploadsRemaining?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "RequiredContentItem" */
export enum RequiredContentItem_Constraint {
  /** unique or primary key constraint */
  RequiredContentItemPkey = 'RequiredContentItem_pkey'
}

/** input type for incrementing integer column in table "RequiredContentItem" */
export type RequiredContentItem_Inc_Input = {
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "RequiredContentItem" */
export type RequiredContentItem_Insert_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly contentItem?: Maybe<ContentItem_Obj_Rel_Insert_Input>;
  readonly contentType?: Maybe<ContentType_Obj_Rel_Insert_Input>;
  readonly contentTypeName?: Maybe<ContentType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploaders?: Maybe<Uploader_Arr_Rel_Insert_Input>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type RequiredContentItem_Max_Fields = {
  readonly __typename?: 'RequiredContentItem_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Max_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RequiredContentItem_Min_Fields = {
  readonly __typename?: 'RequiredContentItem_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Min_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** response of any mutation on the table "RequiredContentItem" */
export type RequiredContentItem_Mutation_Response = {
  readonly __typename?: 'RequiredContentItem_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RequiredContentItem>;
};

/** input type for inserting object relation for remote table "RequiredContentItem" */
export type RequiredContentItem_Obj_Rel_Insert_Input = {
  readonly data: RequiredContentItem_Insert_Input;
  readonly on_conflict?: Maybe<RequiredContentItem_On_Conflict>;
};

/** on conflict condition type for table "RequiredContentItem" */
export type RequiredContentItem_On_Conflict = {
  readonly constraint: RequiredContentItem_Constraint;
  readonly update_columns: ReadonlyArray<RequiredContentItem_Update_Column>;
  readonly where?: Maybe<RequiredContentItem_Bool_Exp>;
};

/** ordering options when selecting data from "RequiredContentItem" */
export type RequiredContentItem_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly contentItem?: Maybe<ContentItem_Order_By>;
  readonly contentType?: Maybe<ContentType_Order_By>;
  readonly contentTypeName?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploaders_aggregate?: Maybe<Uploader_Aggregate_Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** primary key columns input for table: "RequiredContentItem" */
export type RequiredContentItem_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "RequiredContentItem" */
export enum RequiredContentItem_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ContentTypeName = 'contentTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** input type for updating data in table "RequiredContentItem" */
export type RequiredContentItem_Set_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly contentTypeName?: Maybe<ContentType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type RequiredContentItem_Stddev_Fields = {
  readonly __typename?: 'RequiredContentItem_stddev_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Stddev_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type RequiredContentItem_Stddev_Pop_Fields = {
  readonly __typename?: 'RequiredContentItem_stddev_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Stddev_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type RequiredContentItem_Stddev_Samp_Fields = {
  readonly __typename?: 'RequiredContentItem_stddev_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Stddev_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type RequiredContentItem_Sum_Fields = {
  readonly __typename?: 'RequiredContentItem_sum_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Sum_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** update columns of table "RequiredContentItem" */
export enum RequiredContentItem_Update_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ContentTypeName = 'contentTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** aggregate var_pop on columns */
export type RequiredContentItem_Var_Pop_Fields = {
  readonly __typename?: 'RequiredContentItem_var_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Var_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type RequiredContentItem_Var_Samp_Fields = {
  readonly __typename?: 'RequiredContentItem_var_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Var_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type RequiredContentItem_Variance_Fields = {
  readonly __typename?: 'RequiredContentItem_variance_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Variance_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** columns and relationships of "Role" */
export type Role = {
  readonly __typename?: 'Role';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly groupRoles: ReadonlyArray<GroupRole>;
  /** An aggregated array relationship */
  readonly groupRoles_aggregate: GroupRole_Aggregate;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rolePermissions: ReadonlyArray<RolePermission>;
  /** An aggregated array relationship */
  readonly rolePermissions_aggregate: RolePermission_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Role" */
export type RoleGroupRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** columns and relationships of "Role" */
export type RoleGroupRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** columns and relationships of "Role" */
export type RoleRolePermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** columns and relationships of "Role" */
export type RoleRolePermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};

/** columns and relationships of "RolePermission" */
export type RolePermission = {
  readonly __typename?: 'RolePermission';
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly permission: Permission;
  readonly permissionName: Permission_Enum;
  /** An object relationship */
  readonly role: Role;
  readonly roleId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "RolePermission" */
export type RolePermission_Aggregate = {
  readonly __typename?: 'RolePermission_aggregate';
  readonly aggregate?: Maybe<RolePermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RolePermission>;
};

/** aggregate fields of "RolePermission" */
export type RolePermission_Aggregate_Fields = {
  readonly __typename?: 'RolePermission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RolePermission_Max_Fields>;
  readonly min?: Maybe<RolePermission_Min_Fields>;
};


/** aggregate fields of "RolePermission" */
export type RolePermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RolePermission" */
export type RolePermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RolePermission_Max_Order_By>;
  readonly min?: Maybe<RolePermission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RolePermission" */
export type RolePermission_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RolePermission_Insert_Input>;
  readonly on_conflict?: Maybe<RolePermission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RolePermission". All fields are combined with a logical 'AND'. */
export type RolePermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RolePermission_Bool_Exp>>>;
  readonly _not?: Maybe<RolePermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RolePermission_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly permission?: Maybe<Permission_Bool_Exp>;
  readonly permissionName?: Maybe<Permission_Enum_Comparison_Exp>;
  readonly role?: Maybe<Role_Bool_Exp>;
  readonly roleId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "RolePermission" */
export enum RolePermission_Constraint {
  /** unique or primary key constraint */
  RolePermissionPkey = 'RolePermission_pkey',
  /** unique or primary key constraint */
  RolePermissionRoleIdPermissionKey = 'RolePermission_roleId_permission_key'
}

/** input type for inserting data into table "RolePermission" */
export type RolePermission_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permission?: Maybe<Permission_Obj_Rel_Insert_Input>;
  readonly permissionName?: Maybe<Permission_Enum>;
  readonly role?: Maybe<Role_Obj_Rel_Insert_Input>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type RolePermission_Max_Fields = {
  readonly __typename?: 'RolePermission_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "RolePermission" */
export type RolePermission_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RolePermission_Min_Fields = {
  readonly __typename?: 'RolePermission_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "RolePermission" */
export type RolePermission_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "RolePermission" */
export type RolePermission_Mutation_Response = {
  readonly __typename?: 'RolePermission_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RolePermission>;
};

/** input type for inserting object relation for remote table "RolePermission" */
export type RolePermission_Obj_Rel_Insert_Input = {
  readonly data: RolePermission_Insert_Input;
  readonly on_conflict?: Maybe<RolePermission_On_Conflict>;
};

/** on conflict condition type for table "RolePermission" */
export type RolePermission_On_Conflict = {
  readonly constraint: RolePermission_Constraint;
  readonly update_columns: ReadonlyArray<RolePermission_Update_Column>;
  readonly where?: Maybe<RolePermission_Bool_Exp>;
};

/** ordering options when selecting data from "RolePermission" */
export type RolePermission_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permission?: Maybe<Permission_Order_By>;
  readonly permissionName?: Maybe<Order_By>;
  readonly role?: Maybe<Role_Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "RolePermission" */
export type RolePermission_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "RolePermission" */
export enum RolePermission_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionName = 'permissionName',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "RolePermission" */
export type RolePermission_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionName?: Maybe<Permission_Enum>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "RolePermission" */
export enum RolePermission_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionName = 'permissionName',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "Role" */
export type Role_Aggregate = {
  readonly __typename?: 'Role_aggregate';
  readonly aggregate?: Maybe<Role_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Role>;
};

/** aggregate fields of "Role" */
export type Role_Aggregate_Fields = {
  readonly __typename?: 'Role_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Role_Max_Fields>;
  readonly min?: Maybe<Role_Min_Fields>;
};


/** aggregate fields of "Role" */
export type Role_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Role_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Role" */
export type Role_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Role_Max_Order_By>;
  readonly min?: Maybe<Role_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Role" */
export type Role_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Role_Insert_Input>;
  readonly on_conflict?: Maybe<Role_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Role". All fields are combined with a logical 'AND'. */
export type Role_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Role_Bool_Exp>>>;
  readonly _not?: Maybe<Role_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Role_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly groupRoles?: Maybe<GroupRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rolePermissions?: Maybe<RolePermission_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Role" */
export enum Role_Constraint {
  /** unique or primary key constraint */
  RoleConferenceNameKey = 'Role_conference_name_key',
  /** unique or primary key constraint */
  RolePkey = 'Role_pkey'
}

/** input type for inserting data into table "Role" */
export type Role_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupRoles?: Maybe<GroupRole_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rolePermissions?: Maybe<RolePermission_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Role_Max_Fields = {
  readonly __typename?: 'Role_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Role" */
export type Role_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Role_Min_Fields = {
  readonly __typename?: 'Role_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Role" */
export type Role_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Role" */
export type Role_Mutation_Response = {
  readonly __typename?: 'Role_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Role>;
};

/** input type for inserting object relation for remote table "Role" */
export type Role_Obj_Rel_Insert_Input = {
  readonly data: Role_Insert_Input;
  readonly on_conflict?: Maybe<Role_On_Conflict>;
};

/** on conflict condition type for table "Role" */
export type Role_On_Conflict = {
  readonly constraint: Role_Constraint;
  readonly update_columns: ReadonlyArray<Role_Update_Column>;
  readonly where?: Maybe<Role_Bool_Exp>;
};

/** ordering options when selecting data from "Role" */
export type Role_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly groupRoles_aggregate?: Maybe<GroupRole_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rolePermissions_aggregate?: Maybe<RolePermission_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Role" */
export type Role_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Role" */
export enum Role_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Role" */
export type Role_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Role" */
export enum Role_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "Room" */
export type Room = {
  readonly __typename?: 'Room';
  readonly capacity?: Maybe<Scalars['Int']>;
  /** An object relationship */
  readonly chat?: Maybe<Chat_Chat>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly currentMode: RoomMode;
  readonly currentModeName: RoomMode_Enum;
  /** An array relationship */
  readonly events: ReadonlyArray<Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Event_Aggregate;
  /** An array relationship */
  readonly executedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** An aggregated array relationship */
  readonly executedTransitions_aggregate: ExecutedTransitions_Aggregate;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly mediaLiveChannel?: Maybe<MediaLiveChannel>;
  readonly mediaLiveChannelId?: Maybe<Scalars['uuid']>;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingContentGroup?: Maybe<ContentGroup>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly originatingEvent?: Maybe<Event>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly participants: ReadonlyArray<RoomParticipant>;
  /** An aggregated array relationship */
  readonly participants_aggregate: RoomParticipant_Aggregate;
  readonly priority: Scalars['Int'];
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly roomPeople: ReadonlyArray<RoomPerson>;
  /** An aggregated array relationship */
  readonly roomPeople_aggregate: RoomPerson_Aggregate;
  /** An object relationship */
  readonly roomPrivacy: RoomPrivacy;
  readonly roomPrivacyName: RoomPrivacy_Enum;
  /** An array relationship */
  readonly shuffleRooms: ReadonlyArray<Room_ShuffleRoom>;
  /** An aggregated array relationship */
  readonly shuffleRooms_aggregate: Room_ShuffleRoom_Aggregate;
  /** An array relationship */
  readonly transitions: ReadonlyArray<Transitions>;
  /** An aggregated array relationship */
  readonly transitions_aggregate: Transitions_Aggregate;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "Room" */
export type RoomEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomParticipantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomParticipants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomRoomPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomRoomPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomShuffleRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomShuffleRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};

/** columns and relationships of "RoomMode" */
export type RoomMode = {
  readonly __typename?: 'RoomMode';
  readonly description: Scalars['String'];
  /** An array relationship */
  readonly events: ReadonlyArray<Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Event_Aggregate;
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Aggregate;
};


/** columns and relationships of "RoomMode" */
export type RoomModeEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "RoomMode" */
export type RoomModeEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "RoomMode" */
export type RoomModeRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "RoomMode" */
export type RoomModeRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};

/** aggregated selection of "RoomMode" */
export type RoomMode_Aggregate = {
  readonly __typename?: 'RoomMode_aggregate';
  readonly aggregate?: Maybe<RoomMode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomMode>;
};

/** aggregate fields of "RoomMode" */
export type RoomMode_Aggregate_Fields = {
  readonly __typename?: 'RoomMode_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomMode_Max_Fields>;
  readonly min?: Maybe<RoomMode_Min_Fields>;
};


/** aggregate fields of "RoomMode" */
export type RoomMode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomMode" */
export type RoomMode_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomMode_Max_Order_By>;
  readonly min?: Maybe<RoomMode_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomMode" */
export type RoomMode_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomMode_Insert_Input>;
  readonly on_conflict?: Maybe<RoomMode_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomMode". All fields are combined with a logical 'AND'. */
export type RoomMode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomMode_Bool_Exp>>>;
  readonly _not?: Maybe<RoomMode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomMode_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly events?: Maybe<Event_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rooms?: Maybe<Room_Bool_Exp>;
};

/** unique or primary key constraints on table "RoomMode" */
export enum RoomMode_Constraint {
  /** unique or primary key constraint */
  RoomModePkey = 'RoomMode_pkey'
}

export enum RoomMode_Enum {
  /** Users may participate in the general video chat. */
  Breakout = 'BREAKOUT',
  /** Pre-recorded content should be played out to attendees. The breakout and Q&A video chats may also be available to relevant users. */
  Prerecorded = 'PRERECORDED',
  /** A live presentation should be delivered in the Q&A video chat. The breakout video chat may also be available to relevant users. */
  Presentation = 'PRESENTATION',
  /** A live Q&A/discussion should be delivered in the Q&A video chat. The breakout video chat may also be available to relevant users. */
  QAndA = 'Q_AND_A',
  /** Event is taking place in a Zoom room. */
  Zoom = 'ZOOM'
}

/** expression to compare columns of type RoomMode_enum. All fields are combined with logical 'AND'. */
export type RoomMode_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<RoomMode_Enum>;
  readonly _in?: Maybe<ReadonlyArray<RoomMode_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<RoomMode_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<RoomMode_Enum>>;
};

/** input type for inserting data into table "RoomMode" */
export type RoomMode_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly events?: Maybe<Event_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rooms?: Maybe<Room_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type RoomMode_Max_Fields = {
  readonly __typename?: 'RoomMode_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "RoomMode" */
export type RoomMode_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomMode_Min_Fields = {
  readonly __typename?: 'RoomMode_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "RoomMode" */
export type RoomMode_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomMode" */
export type RoomMode_Mutation_Response = {
  readonly __typename?: 'RoomMode_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomMode>;
};

/** input type for inserting object relation for remote table "RoomMode" */
export type RoomMode_Obj_Rel_Insert_Input = {
  readonly data: RoomMode_Insert_Input;
  readonly on_conflict?: Maybe<RoomMode_On_Conflict>;
};

/** on conflict condition type for table "RoomMode" */
export type RoomMode_On_Conflict = {
  readonly constraint: RoomMode_Constraint;
  readonly update_columns: ReadonlyArray<RoomMode_Update_Column>;
  readonly where?: Maybe<RoomMode_Bool_Exp>;
};

/** ordering options when selecting data from "RoomMode" */
export type RoomMode_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Event_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Aggregate_Order_By>;
};

/** primary key columns input for table: "RoomMode" */
export type RoomMode_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "RoomMode" */
export enum RoomMode_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "RoomMode" */
export type RoomMode_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "RoomMode" */
export enum RoomMode_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "RoomParticipant" */
export type RoomParticipant = {
  readonly __typename?: 'RoomParticipant';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageConnectionId: Scalars['String'];
};

/** aggregated selection of "RoomParticipant" */
export type RoomParticipant_Aggregate = {
  readonly __typename?: 'RoomParticipant_aggregate';
  readonly aggregate?: Maybe<RoomParticipant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomParticipant>;
};

/** aggregate fields of "RoomParticipant" */
export type RoomParticipant_Aggregate_Fields = {
  readonly __typename?: 'RoomParticipant_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomParticipant_Max_Fields>;
  readonly min?: Maybe<RoomParticipant_Min_Fields>;
};


/** aggregate fields of "RoomParticipant" */
export type RoomParticipant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomParticipant" */
export type RoomParticipant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomParticipant_Max_Order_By>;
  readonly min?: Maybe<RoomParticipant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomParticipant" */
export type RoomParticipant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomParticipant_Insert_Input>;
  readonly on_conflict?: Maybe<RoomParticipant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomParticipant". All fields are combined with a logical 'AND'. */
export type RoomParticipant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomParticipant_Bool_Exp>>>;
  readonly _not?: Maybe<RoomParticipant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomParticipant_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageConnectionId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "RoomParticipant" */
export enum RoomParticipant_Constraint {
  /** unique or primary key constraint */
  RoomParticipantPkey = 'RoomParticipant_pkey',
  /** unique or primary key constraint */
  RoomParticipantRoomIdAttendeeIdKey = 'RoomParticipant_roomId_attendeeId_key'
}

/** input type for inserting data into table "RoomParticipant" */
export type RoomParticipant_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type RoomParticipant_Max_Fields = {
  readonly __typename?: 'RoomParticipant_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "RoomParticipant" */
export type RoomParticipant_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomParticipant_Min_Fields = {
  readonly __typename?: 'RoomParticipant_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "RoomParticipant" */
export type RoomParticipant_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomParticipant" */
export type RoomParticipant_Mutation_Response = {
  readonly __typename?: 'RoomParticipant_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomParticipant>;
};

/** input type for inserting object relation for remote table "RoomParticipant" */
export type RoomParticipant_Obj_Rel_Insert_Input = {
  readonly data: RoomParticipant_Insert_Input;
  readonly on_conflict?: Maybe<RoomParticipant_On_Conflict>;
};

/** on conflict condition type for table "RoomParticipant" */
export type RoomParticipant_On_Conflict = {
  readonly constraint: RoomParticipant_Constraint;
  readonly update_columns: ReadonlyArray<RoomParticipant_Update_Column>;
  readonly where?: Maybe<RoomParticipant_Bool_Exp>;
};

/** ordering options when selecting data from "RoomParticipant" */
export type RoomParticipant_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** primary key columns input for table: "RoomParticipant" */
export type RoomParticipant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "RoomParticipant" */
export enum RoomParticipant_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId'
}

/** input type for updating data in table "RoomParticipant" */
export type RoomParticipant_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** update columns of table "RoomParticipant" */
export enum RoomParticipant_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId'
}

/** columns and relationships of "RoomPerson" */
export type RoomPerson = {
  readonly __typename?: 'RoomPerson';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly roomPersonRole: RoomPersonRole;
  readonly roomPersonRoleName: RoomPersonRole_Enum;
  readonly updatedAt: Scalars['timestamptz'];
};

/** columns and relationships of "RoomPersonRole" */
export type RoomPersonRole = {
  readonly __typename?: 'RoomPersonRole';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "RoomPersonRole" */
export type RoomPersonRole_Aggregate = {
  readonly __typename?: 'RoomPersonRole_aggregate';
  readonly aggregate?: Maybe<RoomPersonRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomPersonRole>;
};

/** aggregate fields of "RoomPersonRole" */
export type RoomPersonRole_Aggregate_Fields = {
  readonly __typename?: 'RoomPersonRole_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomPersonRole_Max_Fields>;
  readonly min?: Maybe<RoomPersonRole_Min_Fields>;
};


/** aggregate fields of "RoomPersonRole" */
export type RoomPersonRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomPersonRole" */
export type RoomPersonRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomPersonRole_Max_Order_By>;
  readonly min?: Maybe<RoomPersonRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomPersonRole" */
export type RoomPersonRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomPersonRole_Insert_Input>;
  readonly on_conflict?: Maybe<RoomPersonRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomPersonRole". All fields are combined with a logical 'AND'. */
export type RoomPersonRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomPersonRole_Bool_Exp>>>;
  readonly _not?: Maybe<RoomPersonRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomPersonRole_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "RoomPersonRole" */
export enum RoomPersonRole_Constraint {
  /** unique or primary key constraint */
  RoomPersonRolePkey = 'RoomPersonRole_pkey'
}

export enum RoomPersonRole_Enum {
  /** User has control over the room. */
  Admin = 'ADMIN',
  /** User can participate in the room. */
  Participant = 'PARTICIPANT'
}

/** expression to compare columns of type RoomPersonRole_enum. All fields are combined with logical 'AND'. */
export type RoomPersonRole_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<RoomPersonRole_Enum>;
  readonly _in?: Maybe<ReadonlyArray<RoomPersonRole_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<RoomPersonRole_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<RoomPersonRole_Enum>>;
};

/** input type for inserting data into table "RoomPersonRole" */
export type RoomPersonRole_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type RoomPersonRole_Max_Fields = {
  readonly __typename?: 'RoomPersonRole_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "RoomPersonRole" */
export type RoomPersonRole_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomPersonRole_Min_Fields = {
  readonly __typename?: 'RoomPersonRole_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "RoomPersonRole" */
export type RoomPersonRole_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomPersonRole" */
export type RoomPersonRole_Mutation_Response = {
  readonly __typename?: 'RoomPersonRole_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomPersonRole>;
};

/** input type for inserting object relation for remote table "RoomPersonRole" */
export type RoomPersonRole_Obj_Rel_Insert_Input = {
  readonly data: RoomPersonRole_Insert_Input;
  readonly on_conflict?: Maybe<RoomPersonRole_On_Conflict>;
};

/** on conflict condition type for table "RoomPersonRole" */
export type RoomPersonRole_On_Conflict = {
  readonly constraint: RoomPersonRole_Constraint;
  readonly update_columns: ReadonlyArray<RoomPersonRole_Update_Column>;
  readonly where?: Maybe<RoomPersonRole_Bool_Exp>;
};

/** ordering options when selecting data from "RoomPersonRole" */
export type RoomPersonRole_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "RoomPersonRole" */
export type RoomPersonRole_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "RoomPersonRole" */
export enum RoomPersonRole_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "RoomPersonRole" */
export type RoomPersonRole_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "RoomPersonRole" */
export enum RoomPersonRole_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "RoomPerson" */
export type RoomPerson_Aggregate = {
  readonly __typename?: 'RoomPerson_aggregate';
  readonly aggregate?: Maybe<RoomPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomPerson>;
};

/** aggregate fields of "RoomPerson" */
export type RoomPerson_Aggregate_Fields = {
  readonly __typename?: 'RoomPerson_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomPerson_Max_Fields>;
  readonly min?: Maybe<RoomPerson_Min_Fields>;
};


/** aggregate fields of "RoomPerson" */
export type RoomPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomPerson" */
export type RoomPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomPerson_Max_Order_By>;
  readonly min?: Maybe<RoomPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomPerson" */
export type RoomPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomPerson_Insert_Input>;
  readonly on_conflict?: Maybe<RoomPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomPerson". All fields are combined with a logical 'AND'. */
export type RoomPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomPerson_Bool_Exp>>>;
  readonly _not?: Maybe<RoomPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomPerson_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly roomPersonRole?: Maybe<RoomPersonRole_Bool_Exp>;
  readonly roomPersonRoleName?: Maybe<RoomPersonRole_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "RoomPerson" */
export enum RoomPerson_Constraint {
  /** unique or primary key constraint */
  RoomPersonAttendeeIdRoomIdKey = 'RoomPerson_attendeeId_roomId_key',
  /** unique or primary key constraint */
  RoomPersonPkey = 'RoomPerson_pkey'
}

/** input type for inserting data into table "RoomPerson" */
export type RoomPerson_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly roomPersonRole?: Maybe<RoomPersonRole_Obj_Rel_Insert_Input>;
  readonly roomPersonRoleName?: Maybe<RoomPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type RoomPerson_Max_Fields = {
  readonly __typename?: 'RoomPerson_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "RoomPerson" */
export type RoomPerson_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomPerson_Min_Fields = {
  readonly __typename?: 'RoomPerson_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "RoomPerson" */
export type RoomPerson_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomPerson" */
export type RoomPerson_Mutation_Response = {
  readonly __typename?: 'RoomPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomPerson>;
};

/** input type for inserting object relation for remote table "RoomPerson" */
export type RoomPerson_Obj_Rel_Insert_Input = {
  readonly data: RoomPerson_Insert_Input;
  readonly on_conflict?: Maybe<RoomPerson_On_Conflict>;
};

/** on conflict condition type for table "RoomPerson" */
export type RoomPerson_On_Conflict = {
  readonly constraint: RoomPerson_Constraint;
  readonly update_columns: ReadonlyArray<RoomPerson_Update_Column>;
  readonly where?: Maybe<RoomPerson_Bool_Exp>;
};

/** ordering options when selecting data from "RoomPerson" */
export type RoomPerson_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly roomPersonRole?: Maybe<RoomPersonRole_Order_By>;
  readonly roomPersonRoleName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "RoomPerson" */
export type RoomPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "RoomPerson" */
export enum RoomPerson_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RoomPersonRoleName = 'roomPersonRoleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "RoomPerson" */
export type RoomPerson_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly roomPersonRoleName?: Maybe<RoomPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "RoomPerson" */
export enum RoomPerson_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RoomPersonRoleName = 'roomPersonRoleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "RoomPrivacy" */
export type RoomPrivacy = {
  readonly __typename?: 'RoomPrivacy';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "RoomPrivacy" */
export type RoomPrivacy_Aggregate = {
  readonly __typename?: 'RoomPrivacy_aggregate';
  readonly aggregate?: Maybe<RoomPrivacy_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomPrivacy>;
};

/** aggregate fields of "RoomPrivacy" */
export type RoomPrivacy_Aggregate_Fields = {
  readonly __typename?: 'RoomPrivacy_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomPrivacy_Max_Fields>;
  readonly min?: Maybe<RoomPrivacy_Min_Fields>;
};


/** aggregate fields of "RoomPrivacy" */
export type RoomPrivacy_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomPrivacy" */
export type RoomPrivacy_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomPrivacy_Max_Order_By>;
  readonly min?: Maybe<RoomPrivacy_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomPrivacy" */
export type RoomPrivacy_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomPrivacy_Insert_Input>;
  readonly on_conflict?: Maybe<RoomPrivacy_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomPrivacy". All fields are combined with a logical 'AND'. */
export type RoomPrivacy_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomPrivacy_Bool_Exp>>>;
  readonly _not?: Maybe<RoomPrivacy_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomPrivacy_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "RoomPrivacy" */
export enum RoomPrivacy_Constraint {
  /** unique or primary key constraint */
  RoomPrivacyPkey = 'RoomPrivacy_pkey'
}

export enum RoomPrivacy_Enum {
  /** Room is a direct message between two attendees. No new attendees can be added. */
  Dm = 'DM',
  /** Room access is automatically controlled by the system. */
  Managed = 'MANAGED',
  /** Room is only visible to attendees who have been given access. New attendees can be added. */
  Private = 'PRIVATE',
  /** Room is visible to all attendees at the conference. */
  Public = 'PUBLIC'
}

/** expression to compare columns of type RoomPrivacy_enum. All fields are combined with logical 'AND'. */
export type RoomPrivacy_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<RoomPrivacy_Enum>;
  readonly _in?: Maybe<ReadonlyArray<RoomPrivacy_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<RoomPrivacy_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<RoomPrivacy_Enum>>;
};

/** input type for inserting data into table "RoomPrivacy" */
export type RoomPrivacy_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type RoomPrivacy_Max_Fields = {
  readonly __typename?: 'RoomPrivacy_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "RoomPrivacy" */
export type RoomPrivacy_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomPrivacy_Min_Fields = {
  readonly __typename?: 'RoomPrivacy_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "RoomPrivacy" */
export type RoomPrivacy_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomPrivacy" */
export type RoomPrivacy_Mutation_Response = {
  readonly __typename?: 'RoomPrivacy_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomPrivacy>;
};

/** input type for inserting object relation for remote table "RoomPrivacy" */
export type RoomPrivacy_Obj_Rel_Insert_Input = {
  readonly data: RoomPrivacy_Insert_Input;
  readonly on_conflict?: Maybe<RoomPrivacy_On_Conflict>;
};

/** on conflict condition type for table "RoomPrivacy" */
export type RoomPrivacy_On_Conflict = {
  readonly constraint: RoomPrivacy_Constraint;
  readonly update_columns: ReadonlyArray<RoomPrivacy_Update_Column>;
  readonly where?: Maybe<RoomPrivacy_Bool_Exp>;
};

/** ordering options when selecting data from "RoomPrivacy" */
export type RoomPrivacy_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "RoomPrivacy" */
export type RoomPrivacy_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "RoomPrivacy" */
export enum RoomPrivacy_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "RoomPrivacy" */
export type RoomPrivacy_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "RoomPrivacy" */
export enum RoomPrivacy_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "Room" */
export type Room_Aggregate = {
  readonly __typename?: 'Room_aggregate';
  readonly aggregate?: Maybe<Room_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room>;
};

/** aggregate fields of "Room" */
export type Room_Aggregate_Fields = {
  readonly __typename?: 'Room_aggregate_fields';
  readonly avg?: Maybe<Room_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_Max_Fields>;
  readonly min?: Maybe<Room_Min_Fields>;
  readonly stddev?: Maybe<Room_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_Sum_Fields>;
  readonly var_pop?: Maybe<Room_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_Variance_Fields>;
};


/** aggregate fields of "Room" */
export type Room_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Room" */
export type Room_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_Max_Order_By>;
  readonly min?: Maybe<Room_Min_Order_By>;
  readonly stddev?: Maybe<Room_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Room" */
export type Room_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_Insert_Input>;
  readonly on_conflict?: Maybe<Room_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_Avg_Fields = {
  readonly __typename?: 'Room_avg_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Room" */
export type Room_Avg_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Room". All fields are combined with a logical 'AND'. */
export type Room_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_Bool_Exp>>>;
  readonly _not?: Maybe<Room_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_Bool_Exp>>>;
  readonly capacity?: Maybe<Int_Comparison_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly currentMode?: Maybe<RoomMode_Bool_Exp>;
  readonly currentModeName?: Maybe<RoomMode_Enum_Comparison_Exp>;
  readonly events?: Maybe<Event_Bool_Exp>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly mediaLiveChannel?: Maybe<MediaLiveChannel_Bool_Exp>;
  readonly mediaLiveChannelId?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingContentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly originatingContentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingEvent?: Maybe<Event_Bool_Exp>;
  readonly originatingEventId?: Maybe<Uuid_Comparison_Exp>;
  readonly participants?: Maybe<RoomParticipant_Bool_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly publicVonageSessionId?: Maybe<String_Comparison_Exp>;
  readonly roomPeople?: Maybe<RoomPerson_Bool_Exp>;
  readonly roomPrivacy?: Maybe<RoomPrivacy_Bool_Exp>;
  readonly roomPrivacyName?: Maybe<RoomPrivacy_Enum_Comparison_Exp>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly transitions?: Maybe<Transitions_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Room" */
export enum Room_Constraint {
  /** unique or primary key constraint */
  RoomConferenceIdNameKey = 'Room_conferenceId_name_key',
  /** unique or primary key constraint */
  RoomMediaLiveChannelIdKey = 'Room_mediaLiveChannelId_key',
  /** unique or primary key constraint */
  RoomOriginatingEventIdKey = 'Room_originatingEventId_key',
  /** unique or primary key constraint */
  RoomPkey = 'Room_pkey'
}

/** input type for incrementing integer column in table "Room" */
export type Room_Inc_Input = {
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Room" */
export type Room_Insert_Input = {
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly currentMode?: Maybe<RoomMode_Obj_Rel_Insert_Input>;
  readonly currentModeName?: Maybe<RoomMode_Enum>;
  readonly events?: Maybe<Event_Arr_Rel_Insert_Input>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannel?: Maybe<MediaLiveChannel_Obj_Rel_Insert_Input>;
  readonly mediaLiveChannelId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingContentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEvent?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly participants?: Maybe<RoomParticipant_Arr_Rel_Insert_Input>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly roomPeople?: Maybe<RoomPerson_Arr_Rel_Insert_Input>;
  readonly roomPrivacy?: Maybe<RoomPrivacy_Obj_Rel_Insert_Input>;
  readonly roomPrivacyName?: Maybe<RoomPrivacy_Enum>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Arr_Rel_Insert_Input>;
  readonly transitions?: Maybe<Transitions_Arr_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_Max_Fields = {
  readonly __typename?: 'Room_max_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Room" */
export type Room_Max_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingContentGroupId?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_Min_Fields = {
  readonly __typename?: 'Room_min_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Room" */
export type Room_Min_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingContentGroupId?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "Room" */
export type Room_Mutation_Response = {
  readonly __typename?: 'Room_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room>;
};

/** input type for inserting object relation for remote table "Room" */
export type Room_Obj_Rel_Insert_Input = {
  readonly data: Room_Insert_Input;
  readonly on_conflict?: Maybe<Room_On_Conflict>;
};

/** on conflict condition type for table "Room" */
export type Room_On_Conflict = {
  readonly constraint: Room_Constraint;
  readonly update_columns: ReadonlyArray<Room_Update_Column>;
  readonly where?: Maybe<Room_Bool_Exp>;
};

/** ordering options when selecting data from "Room" */
export type Room_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly currentMode?: Maybe<RoomMode_Order_By>;
  readonly currentModeName?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Event_Aggregate_Order_By>;
  readonly executedTransitions_aggregate?: Maybe<ExecutedTransitions_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaLiveChannel?: Maybe<MediaLiveChannel_Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingContentGroup?: Maybe<ContentGroup_Order_By>;
  readonly originatingContentGroupId?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEvent?: Maybe<Event_Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly participants_aggregate?: Maybe<RoomParticipant_Aggregate_Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly roomPeople_aggregate?: Maybe<RoomPerson_Aggregate_Order_By>;
  readonly roomPrivacy?: Maybe<RoomPrivacy_Order_By>;
  readonly roomPrivacyName?: Maybe<Order_By>;
  readonly shuffleRooms_aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Order_By>;
  readonly transitions_aggregate?: Maybe<Transitions_Aggregate_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "Room" */
export type Room_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Room" */
export enum Room_Select_Column {
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentModeName = 'currentModeName',
  /** column name */
  Id = 'id',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingContentGroupId = 'originatingContentGroupId',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  OriginatingEventId = 'originatingEventId',
  /** column name */
  Priority = 'priority',
  /** column name */
  PublicVonageSessionId = 'publicVonageSessionId',
  /** column name */
  RoomPrivacyName = 'roomPrivacyName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "Room" */
export type Room_Set_Input = {
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly currentModeName?: Maybe<RoomMode_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly roomPrivacyName?: Maybe<RoomPrivacy_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_Stddev_Fields = {
  readonly __typename?: 'Room_stddev_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Room" */
export type Room_Stddev_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_Stddev_Pop_Fields = {
  readonly __typename?: 'Room_stddev_pop_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Room" */
export type Room_Stddev_Pop_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_Stddev_Samp_Fields = {
  readonly __typename?: 'Room_stddev_samp_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Room" */
export type Room_Stddev_Samp_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_Sum_Fields = {
  readonly __typename?: 'Room_sum_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Room" */
export type Room_Sum_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "Room" */
export enum Room_Update_Column {
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentModeName = 'currentModeName',
  /** column name */
  Id = 'id',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingContentGroupId = 'originatingContentGroupId',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  OriginatingEventId = 'originatingEventId',
  /** column name */
  Priority = 'priority',
  /** column name */
  PublicVonageSessionId = 'publicVonageSessionId',
  /** column name */
  RoomPrivacyName = 'roomPrivacyName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_Var_Pop_Fields = {
  readonly __typename?: 'Room_var_pop_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Room" */
export type Room_Var_Pop_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_Var_Samp_Fields = {
  readonly __typename?: 'Room_var_samp_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Room" */
export type Room_Var_Samp_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_Variance_Fields = {
  readonly __typename?: 'Room_variance_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Room" */
export type Room_Variance_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

export type SampleInput = {
  readonly password: Scalars['String'];
  readonly username: Scalars['String'];
};

export type SampleOutput = {
  readonly __typename?: 'SampleOutput';
  readonly accessToken: Scalars['String'];
};

export type StopEventBroadcastOutput = {
  readonly __typename?: 'StopEventBroadcastOutput';
  readonly broadcastsStopped: Scalars['Int'];
};

/** expression to compare columns of type String. All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['String']>;
  readonly _gt?: Maybe<Scalars['String']>;
  readonly _gte?: Maybe<Scalars['String']>;
  readonly _ilike?: Maybe<Scalars['String']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _like?: Maybe<Scalars['String']>;
  readonly _lt?: Maybe<Scalars['String']>;
  readonly _lte?: Maybe<Scalars['String']>;
  readonly _neq?: Maybe<Scalars['String']>;
  readonly _nilike?: Maybe<Scalars['String']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _nlike?: Maybe<Scalars['String']>;
  readonly _nsimilar?: Maybe<Scalars['String']>;
  readonly _similar?: Maybe<Scalars['String']>;
};

export type SubmitContentItemInput = {
  readonly contentItemData: Scalars['jsonb'];
};

export type SubmitContentItemOutput = {
  readonly __typename?: 'SubmitContentItemOutput';
  readonly message: Scalars['String'];
  readonly success: Scalars['Boolean'];
};

export type SubmitUpdatedSubtitlesInput = {
  readonly accessToken: Scalars['String'];
  readonly contentItemId: Scalars['String'];
  readonly subtitleText: Scalars['String'];
};

export type SubmitUpdatedSubtitlesOutput = {
  readonly __typename?: 'SubmitUpdatedSubtitlesOutput';
  readonly message: Scalars['String'];
  readonly success: Scalars['Boolean'];
};

/** columns and relationships of "Tag" */
export type Tag = {
  readonly __typename?: 'Tag';
  readonly colour: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroupTags: ReadonlyArray<ContentGroupTag>;
  /** An aggregated array relationship */
  readonly contentGroupTags_aggregate: ContentGroupTag_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly eventTags: ReadonlyArray<EventTag>;
  /** An aggregated array relationship */
  readonly eventTags_aggregate: EventTag_Aggregate;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Tag" */
export type TagContentGroupTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** columns and relationships of "Tag" */
export type TagContentGroupTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** columns and relationships of "Tag" */
export type TagEventTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** columns and relationships of "Tag" */
export type TagEventTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};

/** aggregated selection of "Tag" */
export type Tag_Aggregate = {
  readonly __typename?: 'Tag_aggregate';
  readonly aggregate?: Maybe<Tag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Tag>;
};

/** aggregate fields of "Tag" */
export type Tag_Aggregate_Fields = {
  readonly __typename?: 'Tag_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Tag_Max_Fields>;
  readonly min?: Maybe<Tag_Min_Fields>;
};


/** aggregate fields of "Tag" */
export type Tag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Tag" */
export type Tag_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Tag_Max_Order_By>;
  readonly min?: Maybe<Tag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Tag" */
export type Tag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Tag_Insert_Input>;
  readonly on_conflict?: Maybe<Tag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Tag". All fields are combined with a logical 'AND'. */
export type Tag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Tag_Bool_Exp>>>;
  readonly _not?: Maybe<Tag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Tag_Bool_Exp>>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroupTags?: Maybe<ContentGroupTag_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly eventTags?: Maybe<EventTag_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Tag" */
export enum Tag_Constraint {
  /** unique or primary key constraint */
  TagPkey = 'Tag_pkey'
}

/** input type for inserting data into table "Tag" */
export type Tag_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupTags?: Maybe<ContentGroupTag_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventTags?: Maybe<EventTag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Tag_Max_Fields = {
  readonly __typename?: 'Tag_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Tag" */
export type Tag_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tag_Min_Fields = {
  readonly __typename?: 'Tag_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Tag" */
export type Tag_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Tag" */
export type Tag_Mutation_Response = {
  readonly __typename?: 'Tag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Tag>;
};

/** input type for inserting object relation for remote table "Tag" */
export type Tag_Obj_Rel_Insert_Input = {
  readonly data: Tag_Insert_Input;
  readonly on_conflict?: Maybe<Tag_On_Conflict>;
};

/** on conflict condition type for table "Tag" */
export type Tag_On_Conflict = {
  readonly constraint: Tag_Constraint;
  readonly update_columns: ReadonlyArray<Tag_Update_Column>;
  readonly where?: Maybe<Tag_Bool_Exp>;
};

/** ordering options when selecting data from "Tag" */
export type Tag_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupTags_aggregate?: Maybe<ContentGroupTag_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventTags_aggregate?: Maybe<EventTag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Tag" */
export type Tag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Tag" */
export enum Tag_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Tag" */
export type Tag_Set_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Tag" */
export enum Tag_Update_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "TranscriptionJob" */
export type TranscriptionJob = {
  readonly __typename?: 'TranscriptionJob';
  readonly awsTranscribeJobName: Scalars['String'];
  readonly contentItemId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly languageCode: Scalars['String'];
  readonly transcriptionS3Url: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly videoS3Url: Scalars['String'];
};

/** aggregated selection of "TranscriptionJob" */
export type TranscriptionJob_Aggregate = {
  readonly __typename?: 'TranscriptionJob_aggregate';
  readonly aggregate?: Maybe<TranscriptionJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<TranscriptionJob>;
};

/** aggregate fields of "TranscriptionJob" */
export type TranscriptionJob_Aggregate_Fields = {
  readonly __typename?: 'TranscriptionJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<TranscriptionJob_Max_Fields>;
  readonly min?: Maybe<TranscriptionJob_Min_Fields>;
};


/** aggregate fields of "TranscriptionJob" */
export type TranscriptionJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "TranscriptionJob" */
export type TranscriptionJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<TranscriptionJob_Max_Order_By>;
  readonly min?: Maybe<TranscriptionJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "TranscriptionJob" */
export type TranscriptionJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<TranscriptionJob_Insert_Input>;
  readonly on_conflict?: Maybe<TranscriptionJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "TranscriptionJob". All fields are combined with a logical 'AND'. */
export type TranscriptionJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<TranscriptionJob_Bool_Exp>>>;
  readonly _not?: Maybe<TranscriptionJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<TranscriptionJob_Bool_Exp>>>;
  readonly awsTranscribeJobName?: Maybe<String_Comparison_Exp>;
  readonly contentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly languageCode?: Maybe<String_Comparison_Exp>;
  readonly transcriptionS3Url?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoS3Url?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "TranscriptionJob" */
export enum TranscriptionJob_Constraint {
  /** unique or primary key constraint */
  TranscriptionJobAwsTranscribeJobNameKey = 'TranscriptionJob_awsTranscribeJobName_key',
  /** unique or primary key constraint */
  TranscriptionJobPkey = 'TranscriptionJob_pkey'
}

/** input type for inserting data into table "TranscriptionJob" */
export type TranscriptionJob_Insert_Input = {
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type TranscriptionJob_Max_Fields = {
  readonly __typename?: 'TranscriptionJob_max_fields';
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "TranscriptionJob" */
export type TranscriptionJob_Max_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type TranscriptionJob_Min_Fields = {
  readonly __typename?: 'TranscriptionJob_min_fields';
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "TranscriptionJob" */
export type TranscriptionJob_Min_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** response of any mutation on the table "TranscriptionJob" */
export type TranscriptionJob_Mutation_Response = {
  readonly __typename?: 'TranscriptionJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<TranscriptionJob>;
};

/** input type for inserting object relation for remote table "TranscriptionJob" */
export type TranscriptionJob_Obj_Rel_Insert_Input = {
  readonly data: TranscriptionJob_Insert_Input;
  readonly on_conflict?: Maybe<TranscriptionJob_On_Conflict>;
};

/** on conflict condition type for table "TranscriptionJob" */
export type TranscriptionJob_On_Conflict = {
  readonly constraint: TranscriptionJob_Constraint;
  readonly update_columns: ReadonlyArray<TranscriptionJob_Update_Column>;
  readonly where?: Maybe<TranscriptionJob_Bool_Exp>;
};

/** ordering options when selecting data from "TranscriptionJob" */
export type TranscriptionJob_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** primary key columns input for table: "TranscriptionJob" */
export type TranscriptionJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "TranscriptionJob" */
export enum TranscriptionJob_Select_Column {
  /** column name */
  AwsTranscribeJobName = 'awsTranscribeJobName',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  TranscriptionS3Url = 'transcriptionS3Url',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoS3Url = 'videoS3Url'
}

/** input type for updating data in table "TranscriptionJob" */
export type TranscriptionJob_Set_Input = {
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** update columns of table "TranscriptionJob" */
export enum TranscriptionJob_Update_Column {
  /** column name */
  AwsTranscribeJobName = 'awsTranscribeJobName',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  TranscriptionS3Url = 'transcriptionS3Url',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoS3Url = 'videoS3Url'
}

/** columns and relationships of "Transitions" */
export type Transitions = {
  readonly __typename?: 'Transitions';
  readonly broadcastContentId: Scalars['uuid'];
  /** An object relationship */
  readonly broadcastContentItem: BroadcastContentItem;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly fallbackBroadcastContentItem?: Maybe<BroadcastContentItem>;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  readonly time: Scalars['timestamptz'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "Transitions" */
export type Transitions_Aggregate = {
  readonly __typename?: 'Transitions_aggregate';
  readonly aggregate?: Maybe<Transitions_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Transitions>;
};

/** aggregate fields of "Transitions" */
export type Transitions_Aggregate_Fields = {
  readonly __typename?: 'Transitions_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Transitions_Max_Fields>;
  readonly min?: Maybe<Transitions_Min_Fields>;
};


/** aggregate fields of "Transitions" */
export type Transitions_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Transitions" */
export type Transitions_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Transitions_Max_Order_By>;
  readonly min?: Maybe<Transitions_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Transitions" */
export type Transitions_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Transitions_Insert_Input>;
  readonly on_conflict?: Maybe<Transitions_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Transitions". All fields are combined with a logical 'AND'. */
export type Transitions_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Transitions_Bool_Exp>>>;
  readonly _not?: Maybe<Transitions_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Transitions_Bool_Exp>>>;
  readonly broadcastContentId?: Maybe<Uuid_Comparison_Exp>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly fallbackBroadcastContentId?: Maybe<Uuid_Comparison_Exp>;
  readonly fallbackBroadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly time?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Transitions" */
export enum Transitions_Constraint {
  /** unique or primary key constraint */
  TransitionsPkey = 'Transitions_pkey'
}

/** input type for inserting data into table "Transitions" */
export type Transitions_Insert_Input = {
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Transitions_Max_Fields = {
  readonly __typename?: 'Transitions_max_fields';
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Transitions" */
export type Transitions_Max_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly fallbackBroadcastContentId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Transitions_Min_Fields = {
  readonly __typename?: 'Transitions_min_fields';
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Transitions" */
export type Transitions_Min_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly fallbackBroadcastContentId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Transitions" */
export type Transitions_Mutation_Response = {
  readonly __typename?: 'Transitions_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Transitions>;
};

/** input type for inserting object relation for remote table "Transitions" */
export type Transitions_Obj_Rel_Insert_Input = {
  readonly data: Transitions_Insert_Input;
  readonly on_conflict?: Maybe<Transitions_On_Conflict>;
};

/** on conflict condition type for table "Transitions" */
export type Transitions_On_Conflict = {
  readonly constraint: Transitions_Constraint;
  readonly update_columns: ReadonlyArray<Transitions_Update_Column>;
  readonly where?: Maybe<Transitions_Bool_Exp>;
};

/** ordering options when selecting data from "Transitions" */
export type Transitions_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly fallbackBroadcastContentId?: Maybe<Order_By>;
  readonly fallbackBroadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Transitions" */
export type Transitions_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Transitions" */
export enum Transitions_Select_Column {
  /** column name */
  BroadcastContentId = 'broadcastContentId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  FallbackBroadcastContentId = 'fallbackBroadcastContentId',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Transitions" */
export type Transitions_Set_Input = {
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Transitions" */
export enum Transitions_Update_Column {
  /** column name */
  BroadcastContentId = 'broadcastContentId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  FallbackBroadcastContentId = 'fallbackBroadcastContentId',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type UpdateProfilePhotoResponse = {
  readonly __typename?: 'UpdateProfilePhotoResponse';
  readonly ok: Scalars['Boolean'];
};

/** columns and relationships of "Uploader" */
export type Uploader = {
  readonly __typename?: 'Uploader';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly email: Scalars['String'];
  readonly emailsSentCount: Scalars['Int'];
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly requiredContentItem: RequiredContentItem;
  readonly requiredContentItemId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

export type UploaderSendSubmissionRequestResult = {
  readonly __typename?: 'UploaderSendSubmissionRequestResult';
  readonly sent: Scalars['Boolean'];
  readonly uploaderId: Scalars['uuid'];
};

/** aggregated selection of "Uploader" */
export type Uploader_Aggregate = {
  readonly __typename?: 'Uploader_aggregate';
  readonly aggregate?: Maybe<Uploader_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Uploader>;
};

/** aggregate fields of "Uploader" */
export type Uploader_Aggregate_Fields = {
  readonly __typename?: 'Uploader_aggregate_fields';
  readonly avg?: Maybe<Uploader_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Uploader_Max_Fields>;
  readonly min?: Maybe<Uploader_Min_Fields>;
  readonly stddev?: Maybe<Uploader_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Uploader_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Uploader_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Uploader_Sum_Fields>;
  readonly var_pop?: Maybe<Uploader_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Uploader_Var_Samp_Fields>;
  readonly variance?: Maybe<Uploader_Variance_Fields>;
};


/** aggregate fields of "Uploader" */
export type Uploader_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Uploader" */
export type Uploader_Aggregate_Order_By = {
  readonly avg?: Maybe<Uploader_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Uploader_Max_Order_By>;
  readonly min?: Maybe<Uploader_Min_Order_By>;
  readonly stddev?: Maybe<Uploader_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Uploader_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Uploader_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Uploader_Sum_Order_By>;
  readonly var_pop?: Maybe<Uploader_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Uploader_Var_Samp_Order_By>;
  readonly variance?: Maybe<Uploader_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Uploader" */
export type Uploader_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Uploader_Insert_Input>;
  readonly on_conflict?: Maybe<Uploader_On_Conflict>;
};

/** aggregate avg on columns */
export type Uploader_Avg_Fields = {
  readonly __typename?: 'Uploader_avg_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Uploader" */
export type Uploader_Avg_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Uploader". All fields are combined with a logical 'AND'. */
export type Uploader_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Uploader_Bool_Exp>>>;
  readonly _not?: Maybe<Uploader_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Uploader_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly emailsSentCount?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly requiredContentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Uploader" */
export enum Uploader_Constraint {
  /** unique or primary key constraint */
  UploaderEmailRequiredContentItemIdKey = 'Uploader_email_requiredContentItemId_key',
  /** unique or primary key constraint */
  UploaderPkey = 'Uploader_pkey'
}

/** input type for incrementing integer column in table "Uploader" */
export type Uploader_Inc_Input = {
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Uploader" */
export type Uploader_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Obj_Rel_Insert_Input>;
  readonly requiredContentItemId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Uploader_Max_Fields = {
  readonly __typename?: 'Uploader_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItemId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Uploader" */
export type Uploader_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly requiredContentItemId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Uploader_Min_Fields = {
  readonly __typename?: 'Uploader_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItemId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Uploader" */
export type Uploader_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly requiredContentItemId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Uploader" */
export type Uploader_Mutation_Response = {
  readonly __typename?: 'Uploader_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Uploader>;
};

/** input type for inserting object relation for remote table "Uploader" */
export type Uploader_Obj_Rel_Insert_Input = {
  readonly data: Uploader_Insert_Input;
  readonly on_conflict?: Maybe<Uploader_On_Conflict>;
};

/** on conflict condition type for table "Uploader" */
export type Uploader_On_Conflict = {
  readonly constraint: Uploader_Constraint;
  readonly update_columns: ReadonlyArray<Uploader_Update_Column>;
  readonly where?: Maybe<Uploader_Bool_Exp>;
};

/** ordering options when selecting data from "Uploader" */
export type Uploader_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Order_By>;
  readonly requiredContentItemId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Uploader" */
export type Uploader_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Uploader" */
export enum Uploader_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  EmailsSentCount = 'emailsSentCount',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  RequiredContentItemId = 'requiredContentItemId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Uploader" */
export type Uploader_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItemId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Uploader_Stddev_Fields = {
  readonly __typename?: 'Uploader_stddev_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Uploader" */
export type Uploader_Stddev_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Uploader_Stddev_Pop_Fields = {
  readonly __typename?: 'Uploader_stddev_pop_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Uploader" */
export type Uploader_Stddev_Pop_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Uploader_Stddev_Samp_Fields = {
  readonly __typename?: 'Uploader_stddev_samp_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Uploader" */
export type Uploader_Stddev_Samp_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Uploader_Sum_Fields = {
  readonly __typename?: 'Uploader_sum_fields';
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Uploader" */
export type Uploader_Sum_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** update columns of table "Uploader" */
export enum Uploader_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  EmailsSentCount = 'emailsSentCount',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  RequiredContentItemId = 'requiredContentItemId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Uploader_Var_Pop_Fields = {
  readonly __typename?: 'Uploader_var_pop_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Uploader" */
export type Uploader_Var_Pop_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Uploader_Var_Samp_Fields = {
  readonly __typename?: 'Uploader_var_samp_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Uploader" */
export type Uploader_Var_Samp_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Uploader_Variance_Fields = {
  readonly __typename?: 'Uploader_variance_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Uploader" */
export type Uploader_Variance_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** columns and relationships of "User" */
export type User = {
  readonly __typename?: 'User';
  /** An array relationship */
  readonly attendees: ReadonlyArray<Attendee>;
  /** An aggregated array relationship */
  readonly attendees_aggregate: Attendee_Aggregate;
  /** An array relationship */
  readonly conferenceDemoCodes: ReadonlyArray<ConferenceDemoCode>;
  /** An aggregated array relationship */
  readonly conferenceDemoCodes_aggregate: ConferenceDemoCode_Aggregate;
  /** An array relationship */
  readonly conferencesCreated: ReadonlyArray<Conference>;
  /** An aggregated array relationship */
  readonly conferencesCreated_aggregate: Conference_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly email?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly emails: ReadonlyArray<Email>;
  /** An aggregated array relationship */
  readonly emails_aggregate: Email_Aggregate;
  readonly firstName: Scalars['String'];
  readonly id: Scalars['String'];
  /** An array relationship */
  readonly invitationsPendingConfirmation: ReadonlyArray<Invitation>;
  /** An aggregated array relationship */
  readonly invitationsPendingConfirmation_aggregate: Invitation_Aggregate;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName: Scalars['String'];
  /** An object relationship */
  readonly onlineStatus?: Maybe<OnlineStatus>;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "User" */
export type UserAttendeesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserAttendees_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferenceDemoCodesArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferenceDemoCodes_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferencesCreatedArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferencesCreated_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserEmailsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserEmails_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserInvitationsPendingConfirmationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserInvitationsPendingConfirmation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};

/** aggregated selection of "User" */
export type User_Aggregate = {
  readonly __typename?: 'User_aggregate';
  readonly aggregate?: Maybe<User_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<User>;
};

/** aggregate fields of "User" */
export type User_Aggregate_Fields = {
  readonly __typename?: 'User_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<User_Max_Fields>;
  readonly min?: Maybe<User_Min_Fields>;
};


/** aggregate fields of "User" */
export type User_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<User_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "User" */
export type User_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<User_Max_Order_By>;
  readonly min?: Maybe<User_Min_Order_By>;
};

/** input type for inserting array relation for remote table "User" */
export type User_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<User_Insert_Input>;
  readonly on_conflict?: Maybe<User_On_Conflict>;
};

/** Boolean expression to filter rows from the table "User". All fields are combined with a logical 'AND'. */
export type User_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<User_Bool_Exp>>>;
  readonly _not?: Maybe<User_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<User_Bool_Exp>>>;
  readonly attendees?: Maybe<Attendee_Bool_Exp>;
  readonly conferenceDemoCodes?: Maybe<ConferenceDemoCode_Bool_Exp>;
  readonly conferencesCreated?: Maybe<Conference_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly emails?: Maybe<Email_Bool_Exp>;
  readonly firstName?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<String_Comparison_Exp>;
  readonly invitationsPendingConfirmation?: Maybe<Invitation_Bool_Exp>;
  readonly lastLoggedInAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly lastName?: Maybe<String_Comparison_Exp>;
  readonly onlineStatus?: Maybe<OnlineStatus_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "User" */
export enum User_Constraint {
  /** unique or primary key constraint */
  UserEmailKey = 'user_email_key',
  /** unique or primary key constraint */
  UserPkey = 'user_pkey'
}

/** input type for inserting data into table "User" */
export type User_Insert_Input = {
  readonly attendees?: Maybe<Attendee_Arr_Rel_Insert_Input>;
  readonly conferenceDemoCodes?: Maybe<ConferenceDemoCode_Arr_Rel_Insert_Input>;
  readonly conferencesCreated?: Maybe<Conference_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emails?: Maybe<Email_Arr_Rel_Insert_Input>;
  readonly firstName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly invitationsPendingConfirmation?: Maybe<Invitation_Arr_Rel_Insert_Input>;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName?: Maybe<Scalars['String']>;
  readonly onlineStatus?: Maybe<OnlineStatus_Obj_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type User_Max_Fields = {
  readonly __typename?: 'User_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly firstName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "User" */
export type User_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly firstName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly lastLoggedInAt?: Maybe<Order_By>;
  readonly lastName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type User_Min_Fields = {
  readonly __typename?: 'User_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly firstName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "User" */
export type User_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly firstName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly lastLoggedInAt?: Maybe<Order_By>;
  readonly lastName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "User" */
export type User_Mutation_Response = {
  readonly __typename?: 'User_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<User>;
};

/** input type for inserting object relation for remote table "User" */
export type User_Obj_Rel_Insert_Input = {
  readonly data: User_Insert_Input;
  readonly on_conflict?: Maybe<User_On_Conflict>;
};

/** on conflict condition type for table "User" */
export type User_On_Conflict = {
  readonly constraint: User_Constraint;
  readonly update_columns: ReadonlyArray<User_Update_Column>;
  readonly where?: Maybe<User_Bool_Exp>;
};

/** ordering options when selecting data from "User" */
export type User_Order_By = {
  readonly attendees_aggregate?: Maybe<Attendee_Aggregate_Order_By>;
  readonly conferenceDemoCodes_aggregate?: Maybe<ConferenceDemoCode_Aggregate_Order_By>;
  readonly conferencesCreated_aggregate?: Maybe<Conference_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emails_aggregate?: Maybe<Email_Aggregate_Order_By>;
  readonly firstName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationsPendingConfirmation_aggregate?: Maybe<Invitation_Aggregate_Order_By>;
  readonly lastLoggedInAt?: Maybe<Order_By>;
  readonly lastName?: Maybe<Order_By>;
  readonly onlineStatus?: Maybe<OnlineStatus_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "User" */
export type User_Pk_Columns_Input = {
  readonly id: Scalars['String'];
};

/** select columns of table "User" */
export enum User_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastLoggedInAt = 'lastLoggedInAt',
  /** column name */
  LastName = 'lastName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "User" */
export type User_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly firstName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "User" */
export enum User_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastLoggedInAt = 'lastLoggedInAt',
  /** column name */
  LastName = 'lastName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "VideoRenderJob" */
export type VideoRenderJob = {
  readonly __typename?: 'VideoRenderJob';
  /** An object relationship */
  readonly broadcastContentItem: BroadcastContentItem;
  readonly broadcastContentItemId: Scalars['uuid'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly conferencePrepareJob: ConferencePrepareJob;
  readonly conferencePrepareJobId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: JobStatus;
  readonly jobStatusName: JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "VideoRenderJob" */
export type VideoRenderJobDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "VideoRenderJob" */
export type VideoRenderJob_Aggregate = {
  readonly __typename?: 'VideoRenderJob_aggregate';
  readonly aggregate?: Maybe<VideoRenderJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<VideoRenderJob>;
};

/** aggregate fields of "VideoRenderJob" */
export type VideoRenderJob_Aggregate_Fields = {
  readonly __typename?: 'VideoRenderJob_aggregate_fields';
  readonly avg?: Maybe<VideoRenderJob_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<VideoRenderJob_Max_Fields>;
  readonly min?: Maybe<VideoRenderJob_Min_Fields>;
  readonly stddev?: Maybe<VideoRenderJob_Stddev_Fields>;
  readonly stddev_pop?: Maybe<VideoRenderJob_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<VideoRenderJob_Stddev_Samp_Fields>;
  readonly sum?: Maybe<VideoRenderJob_Sum_Fields>;
  readonly var_pop?: Maybe<VideoRenderJob_Var_Pop_Fields>;
  readonly var_samp?: Maybe<VideoRenderJob_Var_Samp_Fields>;
  readonly variance?: Maybe<VideoRenderJob_Variance_Fields>;
};


/** aggregate fields of "VideoRenderJob" */
export type VideoRenderJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "VideoRenderJob" */
export type VideoRenderJob_Aggregate_Order_By = {
  readonly avg?: Maybe<VideoRenderJob_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<VideoRenderJob_Max_Order_By>;
  readonly min?: Maybe<VideoRenderJob_Min_Order_By>;
  readonly stddev?: Maybe<VideoRenderJob_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<VideoRenderJob_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<VideoRenderJob_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<VideoRenderJob_Sum_Order_By>;
  readonly var_pop?: Maybe<VideoRenderJob_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<VideoRenderJob_Var_Samp_Order_By>;
  readonly variance?: Maybe<VideoRenderJob_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type VideoRenderJob_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "VideoRenderJob" */
export type VideoRenderJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<VideoRenderJob_Insert_Input>;
  readonly on_conflict?: Maybe<VideoRenderJob_On_Conflict>;
};

/** aggregate avg on columns */
export type VideoRenderJob_Avg_Fields = {
  readonly __typename?: 'VideoRenderJob_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "VideoRenderJob". All fields are combined with a logical 'AND'. */
export type VideoRenderJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<VideoRenderJob_Bool_Exp>>>;
  readonly _not?: Maybe<VideoRenderJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<VideoRenderJob_Bool_Exp>>>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly broadcastContentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly conferencePrepareJob?: Maybe<ConferencePrepareJob_Bool_Exp>;
  readonly conferencePrepareJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "VideoRenderJob" */
export enum VideoRenderJob_Constraint {
  /** unique or primary key constraint */
  VideoRenderJobPkey = 'VideoRenderJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type VideoRenderJob_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type VideoRenderJob_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type VideoRenderJob_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "VideoRenderJob" */
export type VideoRenderJob_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "VideoRenderJob" */
export type VideoRenderJob_Insert_Input = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly broadcastContentItemId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJob?: Maybe<ConferencePrepareJob_Obj_Rel_Insert_Input>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type VideoRenderJob_Max_Fields = {
  readonly __typename?: 'VideoRenderJob_max_fields';
  readonly broadcastContentItemId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Max_Order_By = {
  readonly broadcastContentItemId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type VideoRenderJob_Min_Fields = {
  readonly __typename?: 'VideoRenderJob_min_fields';
  readonly broadcastContentItemId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Min_Order_By = {
  readonly broadcastContentItemId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "VideoRenderJob" */
export type VideoRenderJob_Mutation_Response = {
  readonly __typename?: 'VideoRenderJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<VideoRenderJob>;
};

/** input type for inserting object relation for remote table "VideoRenderJob" */
export type VideoRenderJob_Obj_Rel_Insert_Input = {
  readonly data: VideoRenderJob_Insert_Input;
  readonly on_conflict?: Maybe<VideoRenderJob_On_Conflict>;
};

/** on conflict condition type for table "VideoRenderJob" */
export type VideoRenderJob_On_Conflict = {
  readonly constraint: VideoRenderJob_Constraint;
  readonly update_columns: ReadonlyArray<VideoRenderJob_Update_Column>;
  readonly where?: Maybe<VideoRenderJob_Bool_Exp>;
};

/** ordering options when selecting data from "VideoRenderJob" */
export type VideoRenderJob_Order_By = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly broadcastContentItemId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJob?: Maybe<ConferencePrepareJob_Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "VideoRenderJob" */
export type VideoRenderJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type VideoRenderJob_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "VideoRenderJob" */
export enum VideoRenderJob_Select_Column {
  /** column name */
  BroadcastContentItemId = 'broadcastContentItemId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConferencePrepareJobId = 'conferencePrepareJobId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "VideoRenderJob" */
export type VideoRenderJob_Set_Input = {
  readonly broadcastContentItemId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type VideoRenderJob_Stddev_Fields = {
  readonly __typename?: 'VideoRenderJob_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type VideoRenderJob_Stddev_Pop_Fields = {
  readonly __typename?: 'VideoRenderJob_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type VideoRenderJob_Stddev_Samp_Fields = {
  readonly __typename?: 'VideoRenderJob_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type VideoRenderJob_Sum_Fields = {
  readonly __typename?: 'VideoRenderJob_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "VideoRenderJob" */
export enum VideoRenderJob_Update_Column {
  /** column name */
  BroadcastContentItemId = 'broadcastContentItemId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConferencePrepareJobId = 'conferencePrepareJobId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type VideoRenderJob_Var_Pop_Fields = {
  readonly __typename?: 'VideoRenderJob_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type VideoRenderJob_Var_Samp_Fields = {
  readonly __typename?: 'VideoRenderJob_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type VideoRenderJob_Variance_Fields = {
  readonly __typename?: 'VideoRenderJob_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};


/** expression to compare columns of type bigint. All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['bigint']>;
  readonly _gt?: Maybe<Scalars['bigint']>;
  readonly _gte?: Maybe<Scalars['bigint']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['bigint']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['bigint']>;
  readonly _lte?: Maybe<Scalars['bigint']>;
  readonly _neq?: Maybe<Scalars['bigint']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['bigint']>>;
};

/** columns and relationships of "chat.Chat" */
export type Chat_Chat = {
  readonly __typename?: 'chat_Chat';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroup: ReadonlyArray<ContentGroup>;
  /** An aggregated array relationship */
  readonly contentGroup_aggregate: ContentGroup_Aggregate;
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly duplicateTo?: Maybe<Chat_Chat>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly duplicatesFrom: ReadonlyArray<Chat_Chat>;
  /** An aggregated array relationship */
  readonly duplicatesFrom_aggregate: Chat_Chat_Aggregate;
  readonly enableAutoPin: Scalars['Boolean'];
  readonly enableAutoSubscribe: Scalars['Boolean'];
  readonly enableMandatoryPin: Scalars['Boolean'];
  readonly enableMandatorySubscribe: Scalars['Boolean'];
  /** An array relationship */
  readonly flags: ReadonlyArray<Chat_Flag>;
  /** An aggregated array relationship */
  readonly flags_aggregate: Chat_Flag_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly messages: ReadonlyArray<Chat_Message>;
  /** An aggregated array relationship */
  readonly messages_aggregate: Chat_Message_Aggregate;
  /** An array relationship */
  readonly pins: ReadonlyArray<Chat_Pin>;
  /** An aggregated array relationship */
  readonly pins_aggregate: Chat_Pin_Aggregate;
  /** An array relationship */
  readonly readUpToIndices: ReadonlyArray<Chat_ReadUpToIndex>;
  /** An aggregated array relationship */
  readonly readUpToIndices_aggregate: Chat_ReadUpToIndex_Aggregate;
  readonly restrictToAdmins: Scalars['Boolean'];
  /** An array relationship */
  readonly room: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly room_aggregate: Room_Aggregate;
  /** An array relationship */
  readonly subscriptions: ReadonlyArray<Chat_Subscription>;
  /** An aggregated array relationship */
  readonly subscriptions_aggregate: Chat_Subscription_Aggregate;
  /** An array relationship */
  readonly typers: ReadonlyArray<Chat_Typer>;
  /** An aggregated array relationship */
  readonly typers_aggregate: Chat_Typer_Aggregate;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatContentGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatContentGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatDuplicatesFromArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatDuplicatesFrom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatFlagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatFlags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatMessagesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatMessages_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatPinsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatPins_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatReadUpToIndicesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatReadUpToIndices_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatSubscriptionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatSubscriptions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatTypersArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Typer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Typer_Order_By>>;
  where?: Maybe<Chat_Typer_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatTypers_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Typer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Typer_Order_By>>;
  where?: Maybe<Chat_Typer_Bool_Exp>;
};

/** aggregated selection of "chat.Chat" */
export type Chat_Chat_Aggregate = {
  readonly __typename?: 'chat_Chat_aggregate';
  readonly aggregate?: Maybe<Chat_Chat_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Chat>;
};

/** aggregate fields of "chat.Chat" */
export type Chat_Chat_Aggregate_Fields = {
  readonly __typename?: 'chat_Chat_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Chat_Max_Fields>;
  readonly min?: Maybe<Chat_Chat_Min_Fields>;
};


/** aggregate fields of "chat.Chat" */
export type Chat_Chat_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Chat" */
export type Chat_Chat_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Chat_Max_Order_By>;
  readonly min?: Maybe<Chat_Chat_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Chat" */
export type Chat_Chat_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Chat_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Chat". All fields are combined with a logical 'AND'. */
export type Chat_Chat_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Chat_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Chat_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Chat_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly duplicateTo?: Maybe<Chat_Chat_Bool_Exp>;
  readonly duplicateToId?: Maybe<Uuid_Comparison_Exp>;
  readonly duplicatesFrom?: Maybe<Chat_Chat_Bool_Exp>;
  readonly enableAutoPin?: Maybe<Boolean_Comparison_Exp>;
  readonly enableAutoSubscribe?: Maybe<Boolean_Comparison_Exp>;
  readonly enableMandatoryPin?: Maybe<Boolean_Comparison_Exp>;
  readonly enableMandatorySubscribe?: Maybe<Boolean_Comparison_Exp>;
  readonly flags?: Maybe<Chat_Flag_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly messages?: Maybe<Chat_Message_Bool_Exp>;
  readonly pins?: Maybe<Chat_Pin_Bool_Exp>;
  readonly readUpToIndices?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
  readonly restrictToAdmins?: Maybe<Boolean_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly subscriptions?: Maybe<Chat_Subscription_Bool_Exp>;
  readonly typers?: Maybe<Chat_Typer_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Chat" */
export enum Chat_Chat_Constraint {
  /** unique or primary key constraint */
  ChatPkey = 'Chat_pkey'
}

/** input type for inserting data into table "chat.Chat" */
export type Chat_Chat_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Arr_Rel_Insert_Input>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateTo?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly duplicatesFrom?: Maybe<Chat_Chat_Arr_Rel_Insert_Input>;
  readonly enableAutoPin?: Maybe<Scalars['Boolean']>;
  readonly enableAutoSubscribe?: Maybe<Scalars['Boolean']>;
  readonly enableMandatoryPin?: Maybe<Scalars['Boolean']>;
  readonly enableMandatorySubscribe?: Maybe<Scalars['Boolean']>;
  readonly flags?: Maybe<Chat_Flag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly messages?: Maybe<Chat_Message_Arr_Rel_Insert_Input>;
  readonly pins?: Maybe<Chat_Pin_Arr_Rel_Insert_Input>;
  readonly readUpToIndices?: Maybe<Chat_ReadUpToIndex_Arr_Rel_Insert_Input>;
  readonly restrictToAdmins?: Maybe<Scalars['Boolean']>;
  readonly room?: Maybe<Room_Arr_Rel_Insert_Input>;
  readonly subscriptions?: Maybe<Chat_Subscription_Arr_Rel_Insert_Input>;
  readonly typers?: Maybe<Chat_Typer_Arr_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Chat_Max_Fields = {
  readonly __typename?: 'chat_Chat_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Chat" */
export type Chat_Chat_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Chat_Min_Fields = {
  readonly __typename?: 'chat_Chat_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Chat" */
export type Chat_Chat_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Chat" */
export type Chat_Chat_Mutation_Response = {
  readonly __typename?: 'chat_Chat_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Chat>;
};

/** input type for inserting object relation for remote table "chat.Chat" */
export type Chat_Chat_Obj_Rel_Insert_Input = {
  readonly data: Chat_Chat_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};

/** on conflict condition type for table "chat.Chat" */
export type Chat_Chat_On_Conflict = {
  readonly constraint: Chat_Chat_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Chat_Update_Column>;
  readonly where?: Maybe<Chat_Chat_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Chat" */
export type Chat_Chat_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup_aggregate?: Maybe<ContentGroup_Aggregate_Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateTo?: Maybe<Chat_Chat_Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly duplicatesFrom_aggregate?: Maybe<Chat_Chat_Aggregate_Order_By>;
  readonly enableAutoPin?: Maybe<Order_By>;
  readonly enableAutoSubscribe?: Maybe<Order_By>;
  readonly enableMandatoryPin?: Maybe<Order_By>;
  readonly enableMandatorySubscribe?: Maybe<Order_By>;
  readonly flags_aggregate?: Maybe<Chat_Flag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messages_aggregate?: Maybe<Chat_Message_Aggregate_Order_By>;
  readonly pins_aggregate?: Maybe<Chat_Pin_Aggregate_Order_By>;
  readonly readUpToIndices_aggregate?: Maybe<Chat_ReadUpToIndex_Aggregate_Order_By>;
  readonly restrictToAdmins?: Maybe<Order_By>;
  readonly room_aggregate?: Maybe<Room_Aggregate_Order_By>;
  readonly subscriptions_aggregate?: Maybe<Chat_Subscription_Aggregate_Order_By>;
  readonly typers_aggregate?: Maybe<Chat_Typer_Aggregate_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Chat" */
export type Chat_Chat_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "chat.Chat" */
export enum Chat_Chat_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuplicateToId = 'duplicateToId',
  /** column name */
  EnableAutoPin = 'enableAutoPin',
  /** column name */
  EnableAutoSubscribe = 'enableAutoSubscribe',
  /** column name */
  EnableMandatoryPin = 'enableMandatoryPin',
  /** column name */
  EnableMandatorySubscribe = 'enableMandatorySubscribe',
  /** column name */
  Id = 'id',
  /** column name */
  RestrictToAdmins = 'restrictToAdmins',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Chat" */
export type Chat_Chat_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly enableAutoPin?: Maybe<Scalars['Boolean']>;
  readonly enableAutoSubscribe?: Maybe<Scalars['Boolean']>;
  readonly enableMandatoryPin?: Maybe<Scalars['Boolean']>;
  readonly enableMandatorySubscribe?: Maybe<Scalars['Boolean']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly restrictToAdmins?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.Chat" */
export enum Chat_Chat_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuplicateToId = 'duplicateToId',
  /** column name */
  EnableAutoPin = 'enableAutoPin',
  /** column name */
  EnableAutoSubscribe = 'enableAutoSubscribe',
  /** column name */
  EnableMandatoryPin = 'enableMandatoryPin',
  /** column name */
  EnableMandatorySubscribe = 'enableMandatorySubscribe',
  /** column name */
  Id = 'id',
  /** column name */
  RestrictToAdmins = 'restrictToAdmins',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "chat.Flag" */
export type Chat_Flag = {
  readonly __typename?: 'chat_Flag';
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly discussionChat?: Maybe<Chat_Chat>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly flaggedBy?: Maybe<Attendee>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['Int'];
  /** An object relationship */
  readonly message: Chat_Message;
  readonly messageId: Scalars['Int'];
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type: Chat_FlagType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "chat.FlagType" */
export type Chat_FlagType = {
  readonly __typename?: 'chat_FlagType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.FlagType" */
export type Chat_FlagType_Aggregate = {
  readonly __typename?: 'chat_FlagType_aggregate';
  readonly aggregate?: Maybe<Chat_FlagType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_FlagType>;
};

/** aggregate fields of "chat.FlagType" */
export type Chat_FlagType_Aggregate_Fields = {
  readonly __typename?: 'chat_FlagType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_FlagType_Max_Fields>;
  readonly min?: Maybe<Chat_FlagType_Min_Fields>;
};


/** aggregate fields of "chat.FlagType" */
export type Chat_FlagType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.FlagType" */
export type Chat_FlagType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_FlagType_Max_Order_By>;
  readonly min?: Maybe<Chat_FlagType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.FlagType" */
export type Chat_FlagType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_FlagType_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.FlagType". All fields are combined with a logical 'AND'. */
export type Chat_FlagType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_FlagType_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_FlagType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_FlagType_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.FlagType" */
export enum Chat_FlagType_Constraint {
  /** unique or primary key constraint */
  FlagTypePkey = 'FlagType_pkey'
}

export enum Chat_FlagType_Enum {
  /** It's abusive or harmful. */
  Abusive = 'Abusive',
  /** It contains false information and is intended to mislead readers. */
  Disinformation = 'Disinformation',
  /** It gives the wrong idea or impression. */
  Misleading = 'Misleading',
  /** It expresses intentions of self-harm or suicide. */
  RiskToLife = 'Risk_To_Life',
  /** It's spam, suspicious or annoying. */
  Spam = 'Spam'
}

/** expression to compare columns of type chat_FlagType_enum. All fields are combined with logical 'AND'. */
export type Chat_FlagType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_FlagType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_FlagType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_FlagType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_FlagType_Enum>>;
};

/** input type for inserting data into table "chat.FlagType" */
export type Chat_FlagType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_FlagType_Max_Fields = {
  readonly __typename?: 'chat_FlagType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "chat.FlagType" */
export type Chat_FlagType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_FlagType_Min_Fields = {
  readonly __typename?: 'chat_FlagType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "chat.FlagType" */
export type Chat_FlagType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.FlagType" */
export type Chat_FlagType_Mutation_Response = {
  readonly __typename?: 'chat_FlagType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_FlagType>;
};

/** input type for inserting object relation for remote table "chat.FlagType" */
export type Chat_FlagType_Obj_Rel_Insert_Input = {
  readonly data: Chat_FlagType_Insert_Input;
  readonly on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};

/** on conflict condition type for table "chat.FlagType" */
export type Chat_FlagType_On_Conflict = {
  readonly constraint: Chat_FlagType_Constraint;
  readonly update_columns: ReadonlyArray<Chat_FlagType_Update_Column>;
  readonly where?: Maybe<Chat_FlagType_Bool_Exp>;
};

/** ordering options when selecting data from "chat.FlagType" */
export type Chat_FlagType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.FlagType" */
export type Chat_FlagType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.FlagType" */
export enum Chat_FlagType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.FlagType" */
export type Chat_FlagType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.FlagType" */
export enum Chat_FlagType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Flag" */
export type Chat_Flag_Aggregate = {
  readonly __typename?: 'chat_Flag_aggregate';
  readonly aggregate?: Maybe<Chat_Flag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Flag>;
};

/** aggregate fields of "chat.Flag" */
export type Chat_Flag_Aggregate_Fields = {
  readonly __typename?: 'chat_Flag_aggregate_fields';
  readonly avg?: Maybe<Chat_Flag_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Flag_Max_Fields>;
  readonly min?: Maybe<Chat_Flag_Min_Fields>;
  readonly stddev?: Maybe<Chat_Flag_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_Flag_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_Flag_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_Flag_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_Flag_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_Flag_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_Flag_Variance_Fields>;
};


/** aggregate fields of "chat.Flag" */
export type Chat_Flag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Flag" */
export type Chat_Flag_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_Flag_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Flag_Max_Order_By>;
  readonly min?: Maybe<Chat_Flag_Min_Order_By>;
  readonly stddev?: Maybe<Chat_Flag_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_Flag_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_Flag_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_Flag_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_Flag_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_Flag_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_Flag_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Flag" */
export type Chat_Flag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Flag_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_Flag_Avg_Fields = {
  readonly __typename?: 'chat_Flag_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.Flag" */
export type Chat_Flag_Avg_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.Flag". All fields are combined with a logical 'AND'. */
export type Chat_Flag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Flag_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Flag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Flag_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly discussionChat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly discussionChatId?: Maybe<Uuid_Comparison_Exp>;
  readonly flaggedBy?: Maybe<Attendee_Bool_Exp>;
  readonly flaggedById?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly message?: Maybe<Chat_Message_Bool_Exp>;
  readonly messageId?: Maybe<Int_Comparison_Exp>;
  readonly notes?: Maybe<String_Comparison_Exp>;
  readonly resolution?: Maybe<String_Comparison_Exp>;
  readonly resolved_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly type?: Maybe<Chat_FlagType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Flag" */
export enum Chat_Flag_Constraint {
  /** unique or primary key constraint */
  FlagMessageIdFlaggedByIdTypeKey = 'Flag_messageId_flaggedById_type_key',
  /** unique or primary key constraint */
  FlagPkey = 'Flag_pkey'
}

/** input type for incrementing integer column in table "chat.Flag" */
export type Chat_Flag_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.Flag" */
export type Chat_Flag_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedBy?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type?: Maybe<Chat_FlagType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Flag_Max_Fields = {
  readonly __typename?: 'chat_Flag_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Flag" */
export type Chat_Flag_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Flag_Min_Fields = {
  readonly __typename?: 'chat_Flag_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Flag" */
export type Chat_Flag_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Flag" */
export type Chat_Flag_Mutation_Response = {
  readonly __typename?: 'chat_Flag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Flag>;
};

/** input type for inserting object relation for remote table "chat.Flag" */
export type Chat_Flag_Obj_Rel_Insert_Input = {
  readonly data: Chat_Flag_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};

/** on conflict condition type for table "chat.Flag" */
export type Chat_Flag_On_Conflict = {
  readonly constraint: Chat_Flag_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Flag_Update_Column>;
  readonly where?: Maybe<Chat_Flag_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Flag" */
export type Chat_Flag_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChat?: Maybe<Chat_Chat_Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedBy?: Maybe<Attendee_Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Chat_Message_Order_By>;
  readonly messageId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Flag" */
export type Chat_Flag_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** select columns of table "chat.Flag" */
export enum Chat_Flag_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscussionChatId = 'discussionChatId',
  /** column name */
  FlaggedById = 'flaggedById',
  /** column name */
  Id = 'id',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolution = 'resolution',
  /** column name */
  ResolvedAt = 'resolved_at',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Flag" */
export type Chat_Flag_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type?: Maybe<Chat_FlagType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_Flag_Stddev_Fields = {
  readonly __typename?: 'chat_Flag_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_Flag_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_Flag_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_Flag_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_Flag_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_Flag_Sum_Fields = {
  readonly __typename?: 'chat_Flag_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.Flag" */
export type Chat_Flag_Sum_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** update columns of table "chat.Flag" */
export enum Chat_Flag_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscussionChatId = 'discussionChatId',
  /** column name */
  FlaggedById = 'flaggedById',
  /** column name */
  Id = 'id',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolution = 'resolution',
  /** column name */
  ResolvedAt = 'resolved_at',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_Flag_Var_Pop_Fields = {
  readonly __typename?: 'chat_Flag_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.Flag" */
export type Chat_Flag_Var_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_Flag_Var_Samp_Fields = {
  readonly __typename?: 'chat_Flag_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.Flag" */
export type Chat_Flag_Var_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_Flag_Variance_Fields = {
  readonly __typename?: 'chat_Flag_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.Flag" */
export type Chat_Flag_Variance_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 * 
 * 
 * columns and relationships of "chat.Message"
 */
export type Chat_Message = {
  readonly __typename?: 'chat_Message';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly chatTitle: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly duplicateIncoming?: Maybe<Chat_Message>;
  /** An object relationship */
  readonly duplicateOutgoing?: Maybe<Chat_Message>;
  readonly duplicatedMessageId?: Maybe<Scalars['Int']>;
  /** An array relationship */
  readonly flags: ReadonlyArray<Chat_Flag>;
  /** An aggregated array relationship */
  readonly flags_aggregate: Chat_Flag_Aggregate;
  readonly id: Scalars['Int'];
  readonly isPinned: Scalars['Boolean'];
  readonly message: Scalars['String'];
  /** An array relationship */
  readonly reactions: ReadonlyArray<Chat_Reaction>;
  /** An aggregated array relationship */
  readonly reactions_aggregate: Chat_Reaction_Aggregate;
  /** An object relationship */
  readonly sender?: Maybe<Attendee>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly senderName: Scalars['String'];
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type: Chat_MessageType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 * 
 * 
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 * 
 * 
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageFlagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 * 
 * 
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageFlags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 * 
 * 
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageReactionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 * 
 * 
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageReactions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** columns and relationships of "chat.MessageType" */
export type Chat_MessageType = {
  readonly __typename?: 'chat_MessageType';
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.MessageType" */
export type Chat_MessageType_Aggregate = {
  readonly __typename?: 'chat_MessageType_aggregate';
  readonly aggregate?: Maybe<Chat_MessageType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_MessageType>;
};

/** aggregate fields of "chat.MessageType" */
export type Chat_MessageType_Aggregate_Fields = {
  readonly __typename?: 'chat_MessageType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_MessageType_Max_Fields>;
  readonly min?: Maybe<Chat_MessageType_Min_Fields>;
};


/** aggregate fields of "chat.MessageType" */
export type Chat_MessageType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.MessageType" */
export type Chat_MessageType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_MessageType_Max_Order_By>;
  readonly min?: Maybe<Chat_MessageType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.MessageType" */
export type Chat_MessageType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_MessageType_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.MessageType". All fields are combined with a logical 'AND'. */
export type Chat_MessageType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_MessageType_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_MessageType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_MessageType_Bool_Exp>>>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.MessageType" */
export enum Chat_MessageType_Constraint {
  /** unique or primary key constraint */
  MessageTypePkey = 'MessageType_pkey'
}

export enum Chat_MessageType_Enum {
  Answer = 'ANSWER',
  DuplicationMarker = 'DUPLICATION_MARKER',
  Emote = 'EMOTE',
  Message = 'MESSAGE',
  Poll = 'POLL',
  PollResults = 'POLL_RESULTS',
  Question = 'QUESTION'
}

/** expression to compare columns of type chat_MessageType_enum. All fields are combined with logical 'AND'. */
export type Chat_MessageType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_MessageType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_MessageType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_MessageType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_MessageType_Enum>>;
};

/** input type for inserting data into table "chat.MessageType" */
export type Chat_MessageType_Insert_Input = {
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_MessageType_Max_Fields = {
  readonly __typename?: 'chat_MessageType_max_fields';
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "chat.MessageType" */
export type Chat_MessageType_Max_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_MessageType_Min_Fields = {
  readonly __typename?: 'chat_MessageType_min_fields';
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "chat.MessageType" */
export type Chat_MessageType_Min_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.MessageType" */
export type Chat_MessageType_Mutation_Response = {
  readonly __typename?: 'chat_MessageType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_MessageType>;
};

/** input type for inserting object relation for remote table "chat.MessageType" */
export type Chat_MessageType_Obj_Rel_Insert_Input = {
  readonly data: Chat_MessageType_Insert_Input;
  readonly on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};

/** on conflict condition type for table "chat.MessageType" */
export type Chat_MessageType_On_Conflict = {
  readonly constraint: Chat_MessageType_Constraint;
  readonly update_columns: ReadonlyArray<Chat_MessageType_Update_Column>;
  readonly where?: Maybe<Chat_MessageType_Bool_Exp>;
};

/** ordering options when selecting data from "chat.MessageType" */
export type Chat_MessageType_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.MessageType" */
export type Chat_MessageType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.MessageType" */
export enum Chat_MessageType_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.MessageType" */
export type Chat_MessageType_Set_Input = {
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.MessageType" */
export enum Chat_MessageType_Update_Column {
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Message" */
export type Chat_Message_Aggregate = {
  readonly __typename?: 'chat_Message_aggregate';
  readonly aggregate?: Maybe<Chat_Message_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Message>;
};

/** aggregate fields of "chat.Message" */
export type Chat_Message_Aggregate_Fields = {
  readonly __typename?: 'chat_Message_aggregate_fields';
  readonly avg?: Maybe<Chat_Message_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Message_Max_Fields>;
  readonly min?: Maybe<Chat_Message_Min_Fields>;
  readonly stddev?: Maybe<Chat_Message_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_Message_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_Message_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_Message_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_Message_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_Message_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_Message_Variance_Fields>;
};


/** aggregate fields of "chat.Message" */
export type Chat_Message_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Message" */
export type Chat_Message_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_Message_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Message_Max_Order_By>;
  readonly min?: Maybe<Chat_Message_Min_Order_By>;
  readonly stddev?: Maybe<Chat_Message_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_Message_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_Message_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_Message_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_Message_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_Message_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_Message_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chat_Message_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "chat.Message" */
export type Chat_Message_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Message_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Message_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_Message_Avg_Fields = {
  readonly __typename?: 'chat_Message_avg_fields';
  readonly duplicatedMessageId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.Message" */
export type Chat_Message_Avg_Order_By = {
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.Message". All fields are combined with a logical 'AND'. */
export type Chat_Message_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Message_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Message_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Message_Bool_Exp>>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly chatTitle?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Bool_Exp>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Bool_Exp>;
  readonly duplicatedMessageId?: Maybe<Int_Comparison_Exp>;
  readonly flags?: Maybe<Chat_Flag_Bool_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly isPinned?: Maybe<Boolean_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly reactions?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly sender?: Maybe<Attendee_Bool_Exp>;
  readonly senderId?: Maybe<Uuid_Comparison_Exp>;
  readonly senderName?: Maybe<String_Comparison_Exp>;
  readonly systemId?: Maybe<String_Comparison_Exp>;
  readonly type?: Maybe<Chat_MessageType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Message" */
export enum Chat_Message_Constraint {
  /** unique or primary key constraint */
  MessageDuplicatedMessageIdKey = 'Message_duplicatedMessageId_key',
  /** unique or primary key constraint */
  MessagePkey = 'Message_pkey',
  /** unique or primary key constraint */
  MessageSystemIdKey = 'Message_systemId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chat_Message_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chat_Message_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chat_Message_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "chat.Message" */
export type Chat_Message_Inc_Input = {
  readonly duplicatedMessageId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.Message" */
export type Chat_Message_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly chatTitle?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly duplicatedMessageId?: Maybe<Scalars['Int']>;
  readonly flags?: Maybe<Chat_Flag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly isPinned?: Maybe<Scalars['Boolean']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly reactions?: Maybe<Chat_Reaction_Arr_Rel_Insert_Input>;
  readonly sender?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly senderName?: Maybe<Scalars['String']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Message_Max_Fields = {
  readonly __typename?: 'chat_Message_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly chatTitle?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicatedMessageId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly senderName?: Maybe<Scalars['String']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Message" */
export type Chat_Message_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly chatTitle?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly senderName?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Message_Min_Fields = {
  readonly __typename?: 'chat_Message_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly chatTitle?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicatedMessageId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly senderName?: Maybe<Scalars['String']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Message" */
export type Chat_Message_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly chatTitle?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly senderName?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Message" */
export type Chat_Message_Mutation_Response = {
  readonly __typename?: 'chat_Message_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Message>;
};

/** input type for inserting object relation for remote table "chat.Message" */
export type Chat_Message_Obj_Rel_Insert_Input = {
  readonly data: Chat_Message_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Message_On_Conflict>;
};

/** on conflict condition type for table "chat.Message" */
export type Chat_Message_On_Conflict = {
  readonly constraint: Chat_Message_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Message_Update_Column>;
  readonly where?: Maybe<Chat_Message_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Message" */
export type Chat_Message_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly chatTitle?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Order_By>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Order_By>;
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly flags_aggregate?: Maybe<Chat_Flag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isPinned?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly reactions_aggregate?: Maybe<Chat_Reaction_Aggregate_Order_By>;
  readonly sender?: Maybe<Attendee_Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly senderName?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Message" */
export type Chat_Message_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chat_Message_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "chat.Message" */
export enum Chat_Message_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ChatTitle = 'chatTitle',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicatedMessageId = 'duplicatedMessageId',
  /** column name */
  Id = 'id',
  /** column name */
  IsPinned = 'isPinned',
  /** column name */
  Message = 'message',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  SenderName = 'senderName',
  /** column name */
  SystemId = 'systemId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Message" */
export type Chat_Message_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly chatTitle?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicatedMessageId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly isPinned?: Maybe<Scalars['Boolean']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly senderName?: Maybe<Scalars['String']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_Message_Stddev_Fields = {
  readonly __typename?: 'chat_Message_stddev_fields';
  readonly duplicatedMessageId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Order_By = {
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_Message_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_Message_stddev_pop_fields';
  readonly duplicatedMessageId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Pop_Order_By = {
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_Message_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_Message_stddev_samp_fields';
  readonly duplicatedMessageId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Samp_Order_By = {
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_Message_Sum_Fields = {
  readonly __typename?: 'chat_Message_sum_fields';
  readonly duplicatedMessageId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.Message" */
export type Chat_Message_Sum_Order_By = {
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "chat.Message" */
export enum Chat_Message_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ChatTitle = 'chatTitle',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicatedMessageId = 'duplicatedMessageId',
  /** column name */
  Id = 'id',
  /** column name */
  IsPinned = 'isPinned',
  /** column name */
  Message = 'message',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  SenderName = 'senderName',
  /** column name */
  SystemId = 'systemId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_Message_Var_Pop_Fields = {
  readonly __typename?: 'chat_Message_var_pop_fields';
  readonly duplicatedMessageId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.Message" */
export type Chat_Message_Var_Pop_Order_By = {
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_Message_Var_Samp_Fields = {
  readonly __typename?: 'chat_Message_var_samp_fields';
  readonly duplicatedMessageId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.Message" */
export type Chat_Message_Var_Samp_Order_By = {
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_Message_Variance_Fields = {
  readonly __typename?: 'chat_Message_variance_fields';
  readonly duplicatedMessageId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.Message" */
export type Chat_Message_Variance_Order_By = {
  readonly duplicatedMessageId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/**
 * Pin a chat to the sidebar.
 * 
 * 
 * columns and relationships of "chat.Pin"
 */
export type Chat_Pin = {
  readonly __typename?: 'chat_Pin';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly wasManuallyPinned: Scalars['Boolean'];
};

/** aggregated selection of "chat.Pin" */
export type Chat_Pin_Aggregate = {
  readonly __typename?: 'chat_Pin_aggregate';
  readonly aggregate?: Maybe<Chat_Pin_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Pin>;
};

/** aggregate fields of "chat.Pin" */
export type Chat_Pin_Aggregate_Fields = {
  readonly __typename?: 'chat_Pin_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Pin_Max_Fields>;
  readonly min?: Maybe<Chat_Pin_Min_Fields>;
};


/** aggregate fields of "chat.Pin" */
export type Chat_Pin_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Pin" */
export type Chat_Pin_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Pin_Max_Order_By>;
  readonly min?: Maybe<Chat_Pin_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Pin" */
export type Chat_Pin_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Pin_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Pin". All fields are combined with a logical 'AND'. */
export type Chat_Pin_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Pin_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Pin_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Pin_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly wasManuallyPinned?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Pin" */
export enum Chat_Pin_Constraint {
  /** unique or primary key constraint */
  ChatPinPkey = 'ChatPin_pkey'
}

/** input type for inserting data into table "chat.Pin" */
export type Chat_Pin_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly wasManuallyPinned?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Chat_Pin_Max_Fields = {
  readonly __typename?: 'chat_Pin_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Pin" */
export type Chat_Pin_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Pin_Min_Fields = {
  readonly __typename?: 'chat_Pin_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Pin" */
export type Chat_Pin_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Pin" */
export type Chat_Pin_Mutation_Response = {
  readonly __typename?: 'chat_Pin_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Pin>;
};

/** input type for inserting object relation for remote table "chat.Pin" */
export type Chat_Pin_Obj_Rel_Insert_Input = {
  readonly data: Chat_Pin_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};

/** on conflict condition type for table "chat.Pin" */
export type Chat_Pin_On_Conflict = {
  readonly constraint: Chat_Pin_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Pin_Update_Column>;
  readonly where?: Maybe<Chat_Pin_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Pin" */
export type Chat_Pin_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly wasManuallyPinned?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Pin" */
export type Chat_Pin_Pk_Columns_Input = {
  readonly attendeeId: Scalars['uuid'];
  readonly chatId: Scalars['uuid'];
};

/** select columns of table "chat.Pin" */
export enum Chat_Pin_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  WasManuallyPinned = 'wasManuallyPinned'
}

/** input type for updating data in table "chat.Pin" */
export type Chat_Pin_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly wasManuallyPinned?: Maybe<Scalars['Boolean']>;
};

/** update columns of table "chat.Pin" */
export enum Chat_Pin_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  WasManuallyPinned = 'wasManuallyPinned'
}

/** columns and relationships of "chat.Reaction" */
export type Chat_Reaction = {
  readonly __typename?: 'chat_Reaction';
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly duplicate?: Maybe<Chat_Reaction>;
  readonly duplicateId?: Maybe<Scalars['Int']>;
  /** An array relationship */
  readonly duplicates: ReadonlyArray<Chat_Reaction>;
  /** An aggregated array relationship */
  readonly duplicates_aggregate: Chat_Reaction_Aggregate;
  readonly id: Scalars['Int'];
  /** An object relationship */
  readonly message: Chat_Message;
  readonly messageId: Scalars['Int'];
  /** An object relationship */
  readonly sender: Attendee;
  readonly senderId: Scalars['uuid'];
  readonly symbol: Scalars['String'];
  readonly type: Chat_ReactionType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDuplicatesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDuplicates_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** columns and relationships of "chat.ReactionType" */
export type Chat_ReactionType = {
  readonly __typename?: 'chat_ReactionType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate = {
  readonly __typename?: 'chat_ReactionType_aggregate';
  readonly aggregate?: Maybe<Chat_ReactionType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_ReactionType>;
};

/** aggregate fields of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_Fields = {
  readonly __typename?: 'chat_ReactionType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_ReactionType_Max_Fields>;
  readonly min?: Maybe<Chat_ReactionType_Min_Fields>;
};


/** aggregate fields of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_ReactionType_Max_Order_By>;
  readonly min?: Maybe<Chat_ReactionType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.ReactionType" */
export type Chat_ReactionType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_ReactionType_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.ReactionType". All fields are combined with a logical 'AND'. */
export type Chat_ReactionType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_ReactionType_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_ReactionType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_ReactionType_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.ReactionType" */
export enum Chat_ReactionType_Constraint {
  /** unique or primary key constraint */
  ReactionTypePkey = 'ReactionType_pkey'
}

export enum Chat_ReactionType_Enum {
  /** Link to a message that answers the question. */
  Answer = 'ANSWER',
  /** A plain emoji reaction */
  Emoji = 'EMOJI',
  /** A vote in a poll */
  PollChoice = 'POLL_CHOICE',
  /** Stop accepting new responses to the poll */
  PollClosed = 'POLL_CLOSED',
  /** Make the poll results visible */
  PollComplete = 'POLL_COMPLETE'
}

/** expression to compare columns of type chat_ReactionType_enum. All fields are combined with logical 'AND'. */
export type Chat_ReactionType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_ReactionType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_ReactionType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_ReactionType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_ReactionType_Enum>>;
};

/** input type for inserting data into table "chat.ReactionType" */
export type Chat_ReactionType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_ReactionType_Max_Fields = {
  readonly __typename?: 'chat_ReactionType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "chat.ReactionType" */
export type Chat_ReactionType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_ReactionType_Min_Fields = {
  readonly __typename?: 'chat_ReactionType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "chat.ReactionType" */
export type Chat_ReactionType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.ReactionType" */
export type Chat_ReactionType_Mutation_Response = {
  readonly __typename?: 'chat_ReactionType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_ReactionType>;
};

/** input type for inserting object relation for remote table "chat.ReactionType" */
export type Chat_ReactionType_Obj_Rel_Insert_Input = {
  readonly data: Chat_ReactionType_Insert_Input;
  readonly on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};

/** on conflict condition type for table "chat.ReactionType" */
export type Chat_ReactionType_On_Conflict = {
  readonly constraint: Chat_ReactionType_Constraint;
  readonly update_columns: ReadonlyArray<Chat_ReactionType_Update_Column>;
  readonly where?: Maybe<Chat_ReactionType_Bool_Exp>;
};

/** ordering options when selecting data from "chat.ReactionType" */
export type Chat_ReactionType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.ReactionType" */
export type Chat_ReactionType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.ReactionType" */
export enum Chat_ReactionType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.ReactionType" */
export type Chat_ReactionType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.ReactionType" */
export enum Chat_ReactionType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Reaction" */
export type Chat_Reaction_Aggregate = {
  readonly __typename?: 'chat_Reaction_aggregate';
  readonly aggregate?: Maybe<Chat_Reaction_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Reaction>;
};

/** aggregate fields of "chat.Reaction" */
export type Chat_Reaction_Aggregate_Fields = {
  readonly __typename?: 'chat_Reaction_aggregate_fields';
  readonly avg?: Maybe<Chat_Reaction_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Reaction_Max_Fields>;
  readonly min?: Maybe<Chat_Reaction_Min_Fields>;
  readonly stddev?: Maybe<Chat_Reaction_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_Reaction_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_Reaction_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_Reaction_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_Reaction_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_Reaction_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_Reaction_Variance_Fields>;
};


/** aggregate fields of "chat.Reaction" */
export type Chat_Reaction_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Reaction" */
export type Chat_Reaction_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_Reaction_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Reaction_Max_Order_By>;
  readonly min?: Maybe<Chat_Reaction_Min_Order_By>;
  readonly stddev?: Maybe<Chat_Reaction_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_Reaction_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_Reaction_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_Reaction_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_Reaction_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_Reaction_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_Reaction_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chat_Reaction_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "chat.Reaction" */
export type Chat_Reaction_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Reaction_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_Reaction_Avg_Fields = {
  readonly __typename?: 'chat_Reaction_avg_fields';
  readonly duplicateId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.Reaction" */
export type Chat_Reaction_Avg_Order_By = {
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.Reaction". All fields are combined with a logical 'AND'. */
export type Chat_Reaction_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Reaction_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Reaction_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly duplicate?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly duplicateId?: Maybe<Int_Comparison_Exp>;
  readonly duplicates?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly message?: Maybe<Chat_Message_Bool_Exp>;
  readonly messageId?: Maybe<Int_Comparison_Exp>;
  readonly sender?: Maybe<Attendee_Bool_Exp>;
  readonly senderId?: Maybe<Uuid_Comparison_Exp>;
  readonly symbol?: Maybe<String_Comparison_Exp>;
  readonly type?: Maybe<Chat_ReactionType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Reaction" */
export enum Chat_Reaction_Constraint {
  /** unique or primary key constraint */
  ReactionPkey = 'Reaction_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chat_Reaction_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chat_Reaction_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chat_Reaction_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "chat.Reaction" */
export type Chat_Reaction_Inc_Input = {
  readonly duplicateId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.Reaction" */
export type Chat_Reaction_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicate?: Maybe<Chat_Reaction_Obj_Rel_Insert_Input>;
  readonly duplicateId?: Maybe<Scalars['Int']>;
  readonly duplicates?: Maybe<Chat_Reaction_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly sender?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_ReactionType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Reaction_Max_Fields = {
  readonly __typename?: 'chat_Reaction_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Reaction" */
export type Chat_Reaction_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Reaction_Min_Fields = {
  readonly __typename?: 'chat_Reaction_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Reaction" */
export type Chat_Reaction_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Reaction" */
export type Chat_Reaction_Mutation_Response = {
  readonly __typename?: 'chat_Reaction_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Reaction>;
};

/** input type for inserting object relation for remote table "chat.Reaction" */
export type Chat_Reaction_Obj_Rel_Insert_Input = {
  readonly data: Chat_Reaction_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};

/** on conflict condition type for table "chat.Reaction" */
export type Chat_Reaction_On_Conflict = {
  readonly constraint: Chat_Reaction_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Reaction_Update_Column>;
  readonly where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Reaction" */
export type Chat_Reaction_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly duplicate?: Maybe<Chat_Reaction_Order_By>;
  readonly duplicateId?: Maybe<Order_By>;
  readonly duplicates_aggregate?: Maybe<Chat_Reaction_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Chat_Message_Order_By>;
  readonly messageId?: Maybe<Order_By>;
  readonly sender?: Maybe<Attendee_Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Reaction" */
export type Chat_Reaction_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chat_Reaction_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "chat.Reaction" */
export enum Chat_Reaction_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicateId = 'duplicateId',
  /** column name */
  Id = 'id',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Reaction" */
export type Chat_Reaction_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicateId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_ReactionType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_Reaction_Stddev_Fields = {
  readonly __typename?: 'chat_Reaction_stddev_fields';
  readonly duplicateId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.Reaction" */
export type Chat_Reaction_Stddev_Order_By = {
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_Reaction_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_Reaction_stddev_pop_fields';
  readonly duplicateId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.Reaction" */
export type Chat_Reaction_Stddev_Pop_Order_By = {
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_Reaction_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_Reaction_stddev_samp_fields';
  readonly duplicateId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.Reaction" */
export type Chat_Reaction_Stddev_Samp_Order_By = {
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_Reaction_Sum_Fields = {
  readonly __typename?: 'chat_Reaction_sum_fields';
  readonly duplicateId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.Reaction" */
export type Chat_Reaction_Sum_Order_By = {
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** update columns of table "chat.Reaction" */
export enum Chat_Reaction_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicateId = 'duplicateId',
  /** column name */
  Id = 'id',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_Reaction_Var_Pop_Fields = {
  readonly __typename?: 'chat_Reaction_var_pop_fields';
  readonly duplicateId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.Reaction" */
export type Chat_Reaction_Var_Pop_Order_By = {
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_Reaction_Var_Samp_Fields = {
  readonly __typename?: 'chat_Reaction_var_samp_fields';
  readonly duplicateId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.Reaction" */
export type Chat_Reaction_Var_Samp_Order_By = {
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_Reaction_Variance_Fields = {
  readonly __typename?: 'chat_Reaction_variance_fields';
  readonly duplicateId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
  readonly messageId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.Reaction" */
export type Chat_Reaction_Variance_Order_By = {
  readonly duplicateId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
};

/** columns and relationships of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex = {
  readonly __typename?: 'chat_ReadUpToIndex';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly messageId: Scalars['Int'];
  readonly notifiedUpToMessageId: Scalars['Int'];
  /** A computed field, executes function "chat.unnotifiedCount" */
  readonly unnotifiedCount?: Maybe<Scalars['Int']>;
  /** A computed field, executes function "chat.unreadCount" */
  readonly unreadCount?: Maybe<Scalars['Int']>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate = {
  readonly __typename?: 'chat_ReadUpToIndex_aggregate';
  readonly aggregate?: Maybe<Chat_ReadUpToIndex_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_ReadUpToIndex>;
};

/** aggregate fields of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_aggregate_fields';
  readonly avg?: Maybe<Chat_ReadUpToIndex_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_ReadUpToIndex_Max_Fields>;
  readonly min?: Maybe<Chat_ReadUpToIndex_Min_Fields>;
  readonly stddev?: Maybe<Chat_ReadUpToIndex_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_ReadUpToIndex_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_ReadUpToIndex_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_ReadUpToIndex_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_ReadUpToIndex_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_ReadUpToIndex_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_ReadUpToIndex_Variance_Fields>;
};


/** aggregate fields of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_ReadUpToIndex_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_ReadUpToIndex_Max_Order_By>;
  readonly min?: Maybe<Chat_ReadUpToIndex_Min_Order_By>;
  readonly stddev?: Maybe<Chat_ReadUpToIndex_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_ReadUpToIndex_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_ReadUpToIndex_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_ReadUpToIndex_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_ReadUpToIndex_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_ReadUpToIndex_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_ReadUpToIndex_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_ReadUpToIndex_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_ReadUpToIndex_Avg_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_avg_fields';
  readonly messageId?: Maybe<Scalars['Float']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Avg_Order_By = {
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.ReadUpToIndex". All fields are combined with a logical 'AND'. */
export type Chat_ReadUpToIndex_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_ReadUpToIndex_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_ReadUpToIndex_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly messageId?: Maybe<Int_Comparison_Exp>;
  readonly notifiedUpToMessageId?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Constraint {
  /** unique or primary key constraint */
  ReadUpToIndexPkey = 'ReadUpToIndex_pkey',
  /** unique or primary key constraint */
  ChatReadUpToIndexPkIndex = 'chat_ReadUpToIndex_pk_index'
}

/** input type for incrementing integer column in table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Inc_Input = {
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_ReadUpToIndex_Max_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_ReadUpToIndex_Min_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Mutation_Response = {
  readonly __typename?: 'chat_ReadUpToIndex_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_ReadUpToIndex>;
};

/** input type for inserting object relation for remote table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Obj_Rel_Insert_Input = {
  readonly data: Chat_ReadUpToIndex_Insert_Input;
  readonly on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};

/** on conflict condition type for table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_On_Conflict = {
  readonly constraint: Chat_ReadUpToIndex_Constraint;
  readonly update_columns: ReadonlyArray<Chat_ReadUpToIndex_Update_Column>;
  readonly where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};

/** ordering options when selecting data from "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Pk_Columns_Input = {
  readonly attendeeId: Scalars['uuid'];
  readonly chatId: Scalars['uuid'];
};

/** select columns of table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  NotifiedUpToMessageId = 'notifiedUpToMessageId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_ReadUpToIndex_Stddev_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_stddev_fields';
  readonly messageId?: Maybe<Scalars['Float']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Stddev_Order_By = {
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_ReadUpToIndex_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_stddev_pop_fields';
  readonly messageId?: Maybe<Scalars['Float']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Stddev_Pop_Order_By = {
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_ReadUpToIndex_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_stddev_samp_fields';
  readonly messageId?: Maybe<Scalars['Float']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Stddev_Samp_Order_By = {
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_ReadUpToIndex_Sum_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_sum_fields';
  readonly messageId?: Maybe<Scalars['Int']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Sum_Order_By = {
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
};

/** update columns of table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageId = 'messageId',
  /** column name */
  NotifiedUpToMessageId = 'notifiedUpToMessageId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_ReadUpToIndex_Var_Pop_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_var_pop_fields';
  readonly messageId?: Maybe<Scalars['Float']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Var_Pop_Order_By = {
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_ReadUpToIndex_Var_Samp_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_var_samp_fields';
  readonly messageId?: Maybe<Scalars['Float']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Var_Samp_Order_By = {
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_ReadUpToIndex_Variance_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_variance_fields';
  readonly messageId?: Maybe<Scalars['Float']>;
  readonly notifiedUpToMessageId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Variance_Order_By = {
  readonly messageId?: Maybe<Order_By>;
  readonly notifiedUpToMessageId?: Maybe<Order_By>;
};

/**
 * Subscribe to chat notifications.
 * 
 * 
 * columns and relationships of "chat.Subscription"
 */
export type Chat_Subscription = {
  readonly __typename?: 'chat_Subscription';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly wasManuallySubscribed: Scalars['Boolean'];
};

/** aggregated selection of "chat.Subscription" */
export type Chat_Subscription_Aggregate = {
  readonly __typename?: 'chat_Subscription_aggregate';
  readonly aggregate?: Maybe<Chat_Subscription_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Subscription>;
};

/** aggregate fields of "chat.Subscription" */
export type Chat_Subscription_Aggregate_Fields = {
  readonly __typename?: 'chat_Subscription_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Subscription_Max_Fields>;
  readonly min?: Maybe<Chat_Subscription_Min_Fields>;
};


/** aggregate fields of "chat.Subscription" */
export type Chat_Subscription_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Subscription" */
export type Chat_Subscription_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Subscription_Max_Order_By>;
  readonly min?: Maybe<Chat_Subscription_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Subscription" */
export type Chat_Subscription_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Subscription_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Subscription". All fields are combined with a logical 'AND'. */
export type Chat_Subscription_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Subscription_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Subscription_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Subscription_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly wasManuallySubscribed?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Subscription" */
export enum Chat_Subscription_Constraint {
  /** unique or primary key constraint */
  SubscriptionPkey = 'Subscription_pkey'
}

/** input type for inserting data into table "chat.Subscription" */
export type Chat_Subscription_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly wasManuallySubscribed?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Chat_Subscription_Max_Fields = {
  readonly __typename?: 'chat_Subscription_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Subscription" */
export type Chat_Subscription_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Subscription_Min_Fields = {
  readonly __typename?: 'chat_Subscription_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Subscription" */
export type Chat_Subscription_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Subscription" */
export type Chat_Subscription_Mutation_Response = {
  readonly __typename?: 'chat_Subscription_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Subscription>;
};

/** input type for inserting object relation for remote table "chat.Subscription" */
export type Chat_Subscription_Obj_Rel_Insert_Input = {
  readonly data: Chat_Subscription_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};

/** on conflict condition type for table "chat.Subscription" */
export type Chat_Subscription_On_Conflict = {
  readonly constraint: Chat_Subscription_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Subscription_Update_Column>;
  readonly where?: Maybe<Chat_Subscription_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Subscription" */
export type Chat_Subscription_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly wasManuallySubscribed?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Subscription" */
export type Chat_Subscription_Pk_Columns_Input = {
  readonly attendeeId: Scalars['uuid'];
  readonly chatId: Scalars['uuid'];
};

/** select columns of table "chat.Subscription" */
export enum Chat_Subscription_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  WasManuallySubscribed = 'wasManuallySubscribed'
}

/** input type for updating data in table "chat.Subscription" */
export type Chat_Subscription_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly wasManuallySubscribed?: Maybe<Scalars['Boolean']>;
};

/** update columns of table "chat.Subscription" */
export enum Chat_Subscription_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  WasManuallySubscribed = 'wasManuallySubscribed'
}

/** columns and relationships of "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages = {
  readonly __typename?: 'chat_SubscriptionsWithUnnotifiedMessages';
  /** An object relationship */
  readonly attendee?: Maybe<Attendee>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly chat?: Maybe<Chat_Chat>;
  readonly chatId?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Aggregate = {
  readonly __typename?: 'chat_SubscriptionsWithUnnotifiedMessages_aggregate';
  readonly aggregate?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages>;
};

/** aggregate fields of "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Aggregate_Fields = {
  readonly __typename?: 'chat_SubscriptionsWithUnnotifiedMessages_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Max_Fields>;
  readonly min?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Min_Fields>;
};


/** aggregate fields of "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Max_Order_By>;
  readonly min?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Insert_Input>;
};

/** Boolean expression to filter rows from the table "chat.SubscriptionsWithUnnotifiedMessages". All fields are combined with a logical 'AND'. */
export type Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for inserting data into table "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Chat_SubscriptionsWithUnnotifiedMessages_Max_Fields = {
  readonly __typename?: 'chat_SubscriptionsWithUnnotifiedMessages_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_SubscriptionsWithUnnotifiedMessages_Min_Fields = {
  readonly __typename?: 'chat_SubscriptionsWithUnnotifiedMessages_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Mutation_Response = {
  readonly __typename?: 'chat_SubscriptionsWithUnnotifiedMessages_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages>;
};

/** input type for inserting object relation for remote table "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Obj_Rel_Insert_Input = {
  readonly data: Chat_SubscriptionsWithUnnotifiedMessages_Insert_Input;
};

/** ordering options when selecting data from "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
};

/** select columns of table "chat.SubscriptionsWithUnnotifiedMessages" */
export enum Chat_SubscriptionsWithUnnotifiedMessages_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId'
}

/** input type for updating data in table "chat.SubscriptionsWithUnnotifiedMessages" */
export type Chat_SubscriptionsWithUnnotifiedMessages_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "chat.Typer" */
export type Chat_Typer = {
  readonly __typename?: 'chat_Typer';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly messageTypeName: Chat_MessageType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "chat.Typer" */
export type Chat_Typer_Aggregate = {
  readonly __typename?: 'chat_Typer_aggregate';
  readonly aggregate?: Maybe<Chat_Typer_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Typer>;
};

/** aggregate fields of "chat.Typer" */
export type Chat_Typer_Aggregate_Fields = {
  readonly __typename?: 'chat_Typer_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Typer_Max_Fields>;
  readonly min?: Maybe<Chat_Typer_Min_Fields>;
};


/** aggregate fields of "chat.Typer" */
export type Chat_Typer_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Typer_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Typer" */
export type Chat_Typer_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Typer_Max_Order_By>;
  readonly min?: Maybe<Chat_Typer_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Typer" */
export type Chat_Typer_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Typer_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Typer_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Typer". All fields are combined with a logical 'AND'. */
export type Chat_Typer_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Typer_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Typer_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Typer_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly messageTypeName?: Maybe<Chat_MessageType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Typer" */
export enum Chat_Typer_Constraint {
  /** unique or primary key constraint */
  TyperPkey = 'Typer_pkey'
}

/** input type for inserting data into table "chat.Typer" */
export type Chat_Typer_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageTypeName?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Typer_Max_Fields = {
  readonly __typename?: 'chat_Typer_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Typer" */
export type Chat_Typer_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Typer_Min_Fields = {
  readonly __typename?: 'chat_Typer_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Typer" */
export type Chat_Typer_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Typer" */
export type Chat_Typer_Mutation_Response = {
  readonly __typename?: 'chat_Typer_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Typer>;
};

/** input type for inserting object relation for remote table "chat.Typer" */
export type Chat_Typer_Obj_Rel_Insert_Input = {
  readonly data: Chat_Typer_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Typer_On_Conflict>;
};

/** on conflict condition type for table "chat.Typer" */
export type Chat_Typer_On_Conflict = {
  readonly constraint: Chat_Typer_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Typer_Update_Column>;
  readonly where?: Maybe<Chat_Typer_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Typer" */
export type Chat_Typer_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly messageTypeName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Typer" */
export type Chat_Typer_Pk_Columns_Input = {
  readonly attendeeId: Scalars['uuid'];
  readonly chatId: Scalars['uuid'];
};

/** select columns of table "chat.Typer" */
export enum Chat_Typer_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageTypeName = 'messageTypeName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Typer" */
export type Chat_Typer_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageTypeName?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.Typer" */
export enum Chat_Typer_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageTypeName = 'messageTypeName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob = {
  readonly __typename?: 'job_queues_InvitationEmailJob';
  readonly attendeeIds: Scalars['jsonb'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly sendRepeat: Scalars['Boolean'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJobAttendeeIdsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_InvitationEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_InvitationEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_InvitationEmailJob>;
};

/** aggregate fields of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_InvitationEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_InvitationEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_InvitationEmailJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_InvitationEmailJob_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_InvitationEmailJob_Append_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_InvitationEmailJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.InvitationEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_InvitationEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>>>;
  readonly attendeeIds?: Maybe<Jsonb_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly sendRepeat?: Maybe<Boolean_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Constraint {
  /** unique or primary key constraint */
  InvitationEmailJobsPkey = 'InvitationEmailJobs_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_InvitationEmailJob_Delete_At_Path_Input = {
  readonly attendeeIds?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_InvitationEmailJob_Delete_Elem_Input = {
  readonly attendeeIds?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_InvitationEmailJob_Delete_Key_Input = {
  readonly attendeeIds?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Insert_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly sendRepeat?: Maybe<Scalars['Boolean']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_InvitationEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_InvitationEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_InvitationEmailJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_InvitationEmailJob>;
};

/** input type for inserting object relation for remote table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_InvitationEmailJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_InvitationEmailJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_InvitationEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Order_By = {
  readonly attendeeIds?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly sendRepeat?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_InvitationEmailJob_Prepend_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Select_Column {
  /** column name */
  AttendeeIds = 'attendeeIds',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  SendRepeat = 'sendRepeat',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Set_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly sendRepeat?: Maybe<Scalars['Boolean']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Update_Column {
  /** column name */
  AttendeeIds = 'attendeeIds',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  SendRepeat = 'sendRepeat',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: JobStatus;
  readonly jobStatusName: JobStatus_Enum;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_MediaPackageHarvestJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
};

/** aggregate fields of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_MediaPackageHarvestJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_MediaPackageHarvestJob_Min_Fields>;
};


/** aggregate fields of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_MediaPackageHarvestJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_MediaPackageHarvestJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.MediaPackageHarvestJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_MediaPackageHarvestJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<JobStatus_Enum_Comparison_Exp>;
  readonly mediaPackageHarvestJobId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Constraint {
  /** unique or primary key constraint */
  MediaPackageHarvestJobMediaPackageHarvestJobIdKey = 'MediaPackageHarvestJob_mediaPackageHarvestJobId_key',
  /** unique or primary key constraint */
  MediaPackageHarvestJobPkey = 'MediaPackageHarvestJob_pkey'
}

/** input type for inserting data into table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_MediaPackageHarvestJob_Max_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_MediaPackageHarvestJob_Min_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Mutation_Response = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
};

/** input type for inserting object relation for remote table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_MediaPackageHarvestJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_On_Conflict = {
  readonly constraint: Job_Queues_MediaPackageHarvestJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaPackageHarvestJobId = 'mediaPackageHarvestJobId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaPackageHarvestJobId = 'mediaPackageHarvestJobId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob = {
  readonly __typename?: 'job_queues_PublishVideoJob';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentItem: ContentItem;
  readonly contentItemId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly jobStatusName: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate = {
  readonly __typename?: 'job_queues_PublishVideoJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_PublishVideoJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_PublishVideoJob>;
};

/** aggregate fields of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_PublishVideoJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_PublishVideoJob_Min_Fields>;
};


/** aggregate fields of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_PublishVideoJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_PublishVideoJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_PublishVideoJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.PublishVideoJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_PublishVideoJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_PublishVideoJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_PublishVideoJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItem?: Maybe<ContentItem_Bool_Exp>;
  readonly contentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatusName?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vimeoVideoUrl?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Constraint {
  /** unique or primary key constraint */
  PublishVideoJobPkey = 'PublishVideoJob_pkey'
}

/** input type for inserting data into table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItem?: Maybe<ContentItem_Obj_Rel_Insert_Input>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Job_Queues_PublishVideoJob_Max_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_PublishVideoJob_Min_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Mutation_Response = {
  readonly __typename?: 'job_queues_PublishVideoJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_PublishVideoJob>;
};

/** input type for inserting object relation for remote table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_PublishVideoJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_On_Conflict = {
  readonly constraint: Job_Queues_PublishVideoJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_PublishVideoJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItem?: Maybe<ContentItem_Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VimeoVideoUrl = 'vimeoVideoUrl'
}

/** input type for updating data in table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** update columns of table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VimeoVideoUrl = 'vimeoVideoUrl'
}

/** columns and relationships of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob';
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly updated_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly uploader: Uploader;
  readonly uploaderId: Scalars['uuid'];
};

/** aggregated selection of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_SubmissionRequestEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
};

/** aggregate fields of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_SubmissionRequestEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_SubmissionRequestEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_SubmissionRequestEmailJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_SubmissionRequestEmailJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.SubmissionRequestEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_SubmissionRequestEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploader?: Maybe<Uploader_Bool_Exp>;
  readonly uploaderId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Constraint {
  /** unique or primary key constraint */
  SubmissionRequestEmailJobPkey = 'SubmissionRequestEmailJob_pkey'
}

/** input type for inserting data into table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploader?: Maybe<Uploader_Obj_Rel_Insert_Input>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Job_Queues_SubmissionRequestEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_SubmissionRequestEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
};

/** input type for inserting object relation for remote table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_SubmissionRequestEmailJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_SubmissionRequestEmailJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploader?: Maybe<Uploader_Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploaderId = 'uploaderId'
}

/** input type for updating data in table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploaderId = 'uploaderId'
}


/** expression to compare columns of type json. All fields are combined with logical 'AND'. */
export type Json_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['json']>;
  readonly _gt?: Maybe<Scalars['json']>;
  readonly _gte?: Maybe<Scalars['json']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['json']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['json']>;
  readonly _lte?: Maybe<Scalars['json']>;
  readonly _neq?: Maybe<Scalars['json']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['json']>>;
};


/** expression to compare columns of type jsonb. All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  /** is the column contained in the given json value */
  readonly _contained_in?: Maybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  readonly _contains?: Maybe<Scalars['jsonb']>;
  readonly _eq?: Maybe<Scalars['jsonb']>;
  readonly _gt?: Maybe<Scalars['jsonb']>;
  readonly _gte?: Maybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  readonly _has_key?: Maybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  readonly _has_keys_all?: Maybe<ReadonlyArray<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  readonly _has_keys_any?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['jsonb']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['jsonb']>;
  readonly _lte?: Maybe<Scalars['jsonb']>;
  readonly _neq?: Maybe<Scalars['jsonb']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['jsonb']>>;
};

/** mutation root */
export type Mutation_Root = {
  readonly __typename?: 'mutation_root';
  /** perform the action: "createContentGroupRoom" */
  readonly createContentGroupRoom?: Maybe<CreateContentGroupRoomOutput>;
  /** perform the action: "createRoomDm" */
  readonly createRoomDm?: Maybe<CreateRoomDmOutput>;
  /** delete data from the table: "Attendee" */
  readonly delete_Attendee?: Maybe<Attendee_Mutation_Response>;
  /** delete data from the table: "AttendeeProfile" */
  readonly delete_AttendeeProfile?: Maybe<AttendeeProfile_Mutation_Response>;
  /** delete single row from the table: "AttendeeProfile" */
  readonly delete_AttendeeProfile_by_pk?: Maybe<AttendeeProfile>;
  /** delete single row from the table: "Attendee" */
  readonly delete_Attendee_by_pk?: Maybe<Attendee>;
  /** delete data from the table: "Broadcast" */
  readonly delete_Broadcast?: Maybe<Broadcast_Mutation_Response>;
  /** delete data from the table: "BroadcastContentItem" */
  readonly delete_BroadcastContentItem?: Maybe<BroadcastContentItem_Mutation_Response>;
  /** delete single row from the table: "BroadcastContentItem" */
  readonly delete_BroadcastContentItem_by_pk?: Maybe<BroadcastContentItem>;
  /** delete single row from the table: "Broadcast" */
  readonly delete_Broadcast_by_pk?: Maybe<Broadcast>;
  /** delete data from the table: "Conference" */
  readonly delete_Conference?: Maybe<Conference_Mutation_Response>;
  /** delete data from the table: "ConferenceConfiguration" */
  readonly delete_ConferenceConfiguration?: Maybe<ConferenceConfiguration_Mutation_Response>;
  /** delete single row from the table: "ConferenceConfiguration" */
  readonly delete_ConferenceConfiguration_by_pk?: Maybe<ConferenceConfiguration>;
  /** delete data from the table: "ConferenceDemoCode" */
  readonly delete_ConferenceDemoCode?: Maybe<ConferenceDemoCode_Mutation_Response>;
  /** delete single row from the table: "ConferenceDemoCode" */
  readonly delete_ConferenceDemoCode_by_pk?: Maybe<ConferenceDemoCode>;
  /** delete data from the table: "ConferencePrepareJob" */
  readonly delete_ConferencePrepareJob?: Maybe<ConferencePrepareJob_Mutation_Response>;
  /** delete single row from the table: "ConferencePrepareJob" */
  readonly delete_ConferencePrepareJob_by_pk?: Maybe<ConferencePrepareJob>;
  /** delete single row from the table: "Conference" */
  readonly delete_Conference_by_pk?: Maybe<Conference>;
  /** delete data from the table: "ContentGroup" */
  readonly delete_ContentGroup?: Maybe<ContentGroup_Mutation_Response>;
  /** delete data from the table: "ContentGroupHallway" */
  readonly delete_ContentGroupHallway?: Maybe<ContentGroupHallway_Mutation_Response>;
  /** delete single row from the table: "ContentGroupHallway" */
  readonly delete_ContentGroupHallway_by_pk?: Maybe<ContentGroupHallway>;
  /** delete data from the table: "ContentGroupPerson" */
  readonly delete_ContentGroupPerson?: Maybe<ContentGroupPerson_Mutation_Response>;
  /** delete single row from the table: "ContentGroupPerson" */
  readonly delete_ContentGroupPerson_by_pk?: Maybe<ContentGroupPerson>;
  /** delete data from the table: "ContentGroupTag" */
  readonly delete_ContentGroupTag?: Maybe<ContentGroupTag_Mutation_Response>;
  /** delete single row from the table: "ContentGroupTag" */
  readonly delete_ContentGroupTag_by_pk?: Maybe<ContentGroupTag>;
  /** delete data from the table: "ContentGroupType" */
  readonly delete_ContentGroupType?: Maybe<ContentGroupType_Mutation_Response>;
  /** delete single row from the table: "ContentGroupType" */
  readonly delete_ContentGroupType_by_pk?: Maybe<ContentGroupType>;
  /** delete single row from the table: "ContentGroup" */
  readonly delete_ContentGroup_by_pk?: Maybe<ContentGroup>;
  /** delete data from the table: "ContentItem" */
  readonly delete_ContentItem?: Maybe<ContentItem_Mutation_Response>;
  /** delete single row from the table: "ContentItem" */
  readonly delete_ContentItem_by_pk?: Maybe<ContentItem>;
  /** delete data from the table: "ContentPerson" */
  readonly delete_ContentPerson?: Maybe<ContentPerson_Mutation_Response>;
  /** delete single row from the table: "ContentPerson" */
  readonly delete_ContentPerson_by_pk?: Maybe<ContentPerson>;
  /** delete data from the table: "ContentType" */
  readonly delete_ContentType?: Maybe<ContentType_Mutation_Response>;
  /** delete single row from the table: "ContentType" */
  readonly delete_ContentType_by_pk?: Maybe<ContentType>;
  /** delete data from the table: "Email" */
  readonly delete_Email?: Maybe<Email_Mutation_Response>;
  /** delete single row from the table: "Email" */
  readonly delete_Email_by_pk?: Maybe<Email>;
  /** delete data from the table: "Event" */
  readonly delete_Event?: Maybe<Event_Mutation_Response>;
  /** delete data from the table: "EventParticipantStream" */
  readonly delete_EventParticipantStream?: Maybe<EventParticipantStream_Mutation_Response>;
  /** delete single row from the table: "EventParticipantStream" */
  readonly delete_EventParticipantStream_by_pk?: Maybe<EventParticipantStream>;
  /** delete data from the table: "EventPerson" */
  readonly delete_EventPerson?: Maybe<EventPerson_Mutation_Response>;
  /** delete data from the table: "EventPersonRole" */
  readonly delete_EventPersonRole?: Maybe<EventPersonRole_Mutation_Response>;
  /** delete single row from the table: "EventPersonRole" */
  readonly delete_EventPersonRole_by_pk?: Maybe<EventPersonRole>;
  /** delete single row from the table: "EventPerson" */
  readonly delete_EventPerson_by_pk?: Maybe<EventPerson>;
  /** delete data from the table: "EventRoomJoinRequest" */
  readonly delete_EventRoomJoinRequest?: Maybe<EventRoomJoinRequest_Mutation_Response>;
  /** delete single row from the table: "EventRoomJoinRequest" */
  readonly delete_EventRoomJoinRequest_by_pk?: Maybe<EventRoomJoinRequest>;
  /** delete data from the table: "EventTag" */
  readonly delete_EventTag?: Maybe<EventTag_Mutation_Response>;
  /** delete single row from the table: "EventTag" */
  readonly delete_EventTag_by_pk?: Maybe<EventTag>;
  /** delete data from the table: "EventVonageSession" */
  readonly delete_EventVonageSession?: Maybe<EventVonageSession_Mutation_Response>;
  /** delete single row from the table: "EventVonageSession" */
  readonly delete_EventVonageSession_by_pk?: Maybe<EventVonageSession>;
  /** delete single row from the table: "Event" */
  readonly delete_Event_by_pk?: Maybe<Event>;
  /** delete data from the table: "ExecutedTransitions" */
  readonly delete_ExecutedTransitions?: Maybe<ExecutedTransitions_Mutation_Response>;
  /** delete single row from the table: "ExecutedTransitions" */
  readonly delete_ExecutedTransitions_by_pk?: Maybe<ExecutedTransitions>;
  /** delete data from the table: "Group" */
  readonly delete_Group?: Maybe<Group_Mutation_Response>;
  /** delete data from the table: "GroupAttendee" */
  readonly delete_GroupAttendee?: Maybe<GroupAttendee_Mutation_Response>;
  /** delete single row from the table: "GroupAttendee" */
  readonly delete_GroupAttendee_by_pk?: Maybe<GroupAttendee>;
  /** delete data from the table: "GroupRole" */
  readonly delete_GroupRole?: Maybe<GroupRole_Mutation_Response>;
  /** delete single row from the table: "GroupRole" */
  readonly delete_GroupRole_by_pk?: Maybe<GroupRole>;
  /** delete single row from the table: "Group" */
  readonly delete_Group_by_pk?: Maybe<Group>;
  /** delete data from the table: "Hallway" */
  readonly delete_Hallway?: Maybe<Hallway_Mutation_Response>;
  /** delete single row from the table: "Hallway" */
  readonly delete_Hallway_by_pk?: Maybe<Hallway>;
  /** delete data from the table: "InputType" */
  readonly delete_InputType?: Maybe<InputType_Mutation_Response>;
  /** delete single row from the table: "InputType" */
  readonly delete_InputType_by_pk?: Maybe<InputType>;
  /** delete data from the table: "Invitation" */
  readonly delete_Invitation?: Maybe<Invitation_Mutation_Response>;
  /** delete single row from the table: "Invitation" */
  readonly delete_Invitation_by_pk?: Maybe<Invitation>;
  /** delete data from the table: "JobStatus" */
  readonly delete_JobStatus?: Maybe<JobStatus_Mutation_Response>;
  /** delete single row from the table: "JobStatus" */
  readonly delete_JobStatus_by_pk?: Maybe<JobStatus>;
  /** delete data from the table: "MediaLiveChannel" */
  readonly delete_MediaLiveChannel?: Maybe<MediaLiveChannel_Mutation_Response>;
  /** delete single row from the table: "MediaLiveChannel" */
  readonly delete_MediaLiveChannel_by_pk?: Maybe<MediaLiveChannel>;
  /** delete data from the table: "OnlineStatus" */
  readonly delete_OnlineStatus?: Maybe<OnlineStatus_Mutation_Response>;
  /** delete single row from the table: "OnlineStatus" */
  readonly delete_OnlineStatus_by_pk?: Maybe<OnlineStatus>;
  /** delete data from the table: "OriginatingData" */
  readonly delete_OriginatingData?: Maybe<OriginatingData_Mutation_Response>;
  /** delete single row from the table: "OriginatingData" */
  readonly delete_OriginatingData_by_pk?: Maybe<OriginatingData>;
  /** delete data from the table: "Permission" */
  readonly delete_Permission?: Maybe<Permission_Mutation_Response>;
  /** delete single row from the table: "Permission" */
  readonly delete_Permission_by_pk?: Maybe<Permission>;
  /** delete data from the table: "RequiredContentItem" */
  readonly delete_RequiredContentItem?: Maybe<RequiredContentItem_Mutation_Response>;
  /** delete single row from the table: "RequiredContentItem" */
  readonly delete_RequiredContentItem_by_pk?: Maybe<RequiredContentItem>;
  /** delete data from the table: "Role" */
  readonly delete_Role?: Maybe<Role_Mutation_Response>;
  /** delete data from the table: "RolePermission" */
  readonly delete_RolePermission?: Maybe<RolePermission_Mutation_Response>;
  /** delete single row from the table: "RolePermission" */
  readonly delete_RolePermission_by_pk?: Maybe<RolePermission>;
  /** delete single row from the table: "Role" */
  readonly delete_Role_by_pk?: Maybe<Role>;
  /** delete data from the table: "Room" */
  readonly delete_Room?: Maybe<Room_Mutation_Response>;
  /** delete data from the table: "RoomMode" */
  readonly delete_RoomMode?: Maybe<RoomMode_Mutation_Response>;
  /** delete single row from the table: "RoomMode" */
  readonly delete_RoomMode_by_pk?: Maybe<RoomMode>;
  /** delete data from the table: "RoomParticipant" */
  readonly delete_RoomParticipant?: Maybe<RoomParticipant_Mutation_Response>;
  /** delete single row from the table: "RoomParticipant" */
  readonly delete_RoomParticipant_by_pk?: Maybe<RoomParticipant>;
  /** delete data from the table: "RoomPerson" */
  readonly delete_RoomPerson?: Maybe<RoomPerson_Mutation_Response>;
  /** delete data from the table: "RoomPersonRole" */
  readonly delete_RoomPersonRole?: Maybe<RoomPersonRole_Mutation_Response>;
  /** delete single row from the table: "RoomPersonRole" */
  readonly delete_RoomPersonRole_by_pk?: Maybe<RoomPersonRole>;
  /** delete single row from the table: "RoomPerson" */
  readonly delete_RoomPerson_by_pk?: Maybe<RoomPerson>;
  /** delete data from the table: "RoomPrivacy" */
  readonly delete_RoomPrivacy?: Maybe<RoomPrivacy_Mutation_Response>;
  /** delete single row from the table: "RoomPrivacy" */
  readonly delete_RoomPrivacy_by_pk?: Maybe<RoomPrivacy>;
  /** delete single row from the table: "Room" */
  readonly delete_Room_by_pk?: Maybe<Room>;
  /** delete data from the table: "Tag" */
  readonly delete_Tag?: Maybe<Tag_Mutation_Response>;
  /** delete single row from the table: "Tag" */
  readonly delete_Tag_by_pk?: Maybe<Tag>;
  /** delete data from the table: "TranscriptionJob" */
  readonly delete_TranscriptionJob?: Maybe<TranscriptionJob_Mutation_Response>;
  /** delete single row from the table: "TranscriptionJob" */
  readonly delete_TranscriptionJob_by_pk?: Maybe<TranscriptionJob>;
  /** delete data from the table: "Transitions" */
  readonly delete_Transitions?: Maybe<Transitions_Mutation_Response>;
  /** delete single row from the table: "Transitions" */
  readonly delete_Transitions_by_pk?: Maybe<Transitions>;
  /** delete data from the table: "Uploader" */
  readonly delete_Uploader?: Maybe<Uploader_Mutation_Response>;
  /** delete single row from the table: "Uploader" */
  readonly delete_Uploader_by_pk?: Maybe<Uploader>;
  /** delete data from the table: "User" */
  readonly delete_User?: Maybe<User_Mutation_Response>;
  /** delete single row from the table: "User" */
  readonly delete_User_by_pk?: Maybe<User>;
  /** delete data from the table: "VideoRenderJob" */
  readonly delete_VideoRenderJob?: Maybe<VideoRenderJob_Mutation_Response>;
  /** delete single row from the table: "VideoRenderJob" */
  readonly delete_VideoRenderJob_by_pk?: Maybe<VideoRenderJob>;
  /** delete data from the table: "chat.Chat" */
  readonly delete_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** delete single row from the table: "chat.Chat" */
  readonly delete_chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** delete data from the table: "chat.Flag" */
  readonly delete_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** delete data from the table: "chat.FlagType" */
  readonly delete_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** delete single row from the table: "chat.FlagType" */
  readonly delete_chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** delete single row from the table: "chat.Flag" */
  readonly delete_chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** delete data from the table: "chat.Message" */
  readonly delete_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** delete data from the table: "chat.MessageType" */
  readonly delete_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** delete single row from the table: "chat.MessageType" */
  readonly delete_chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** delete single row from the table: "chat.Message" */
  readonly delete_chat_Message_by_pk?: Maybe<Chat_Message>;
  /** delete data from the table: "chat.Pin" */
  readonly delete_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** delete single row from the table: "chat.Pin" */
  readonly delete_chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** delete data from the table: "chat.Reaction" */
  readonly delete_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** delete data from the table: "chat.ReactionType" */
  readonly delete_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** delete single row from the table: "chat.ReactionType" */
  readonly delete_chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** delete single row from the table: "chat.Reaction" */
  readonly delete_chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** delete data from the table: "chat.ReadUpToIndex" */
  readonly delete_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** delete single row from the table: "chat.ReadUpToIndex" */
  readonly delete_chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** delete data from the table: "chat.Subscription" */
  readonly delete_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** delete single row from the table: "chat.Subscription" */
  readonly delete_chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** delete data from the table: "chat.SubscriptionsWithUnnotifiedMessages" */
  readonly delete_chat_SubscriptionsWithUnnotifiedMessages?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Mutation_Response>;
  /** delete data from the table: "chat.Typer" */
  readonly delete_chat_Typer?: Maybe<Chat_Typer_Mutation_Response>;
  /** delete single row from the table: "chat.Typer" */
  readonly delete_chat_Typer_by_pk?: Maybe<Chat_Typer>;
  /** delete data from the table: "job_queues.InvitationEmailJob" */
  readonly delete_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.InvitationEmailJob" */
  readonly delete_job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** delete data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly delete_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.MediaPackageHarvestJob" */
  readonly delete_job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** delete data from the table: "job_queues.PublishVideoJob" */
  readonly delete_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.PublishVideoJob" */
  readonly delete_job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** delete data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly delete_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly delete_job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** delete data from the table: "room.ShufflePeriod" */
  readonly delete_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** delete single row from the table: "room.ShufflePeriod" */
  readonly delete_room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** delete data from the table: "room.ShuffleQueueEntry" */
  readonly delete_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleQueueEntry" */
  readonly delete_room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** delete data from the table: "room.ShuffleRoom" */
  readonly delete_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleRoom" */
  readonly delete_room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** insert data into the table: "Attendee" */
  readonly insert_Attendee?: Maybe<Attendee_Mutation_Response>;
  /** insert data into the table: "AttendeeProfile" */
  readonly insert_AttendeeProfile?: Maybe<AttendeeProfile_Mutation_Response>;
  /** insert a single row into the table: "AttendeeProfile" */
  readonly insert_AttendeeProfile_one?: Maybe<AttendeeProfile>;
  /** insert a single row into the table: "Attendee" */
  readonly insert_Attendee_one?: Maybe<Attendee>;
  /** insert data into the table: "Broadcast" */
  readonly insert_Broadcast?: Maybe<Broadcast_Mutation_Response>;
  /** insert data into the table: "BroadcastContentItem" */
  readonly insert_BroadcastContentItem?: Maybe<BroadcastContentItem_Mutation_Response>;
  /** insert a single row into the table: "BroadcastContentItem" */
  readonly insert_BroadcastContentItem_one?: Maybe<BroadcastContentItem>;
  /** insert a single row into the table: "Broadcast" */
  readonly insert_Broadcast_one?: Maybe<Broadcast>;
  /** insert data into the table: "Conference" */
  readonly insert_Conference?: Maybe<Conference_Mutation_Response>;
  /** insert data into the table: "ConferenceConfiguration" */
  readonly insert_ConferenceConfiguration?: Maybe<ConferenceConfiguration_Mutation_Response>;
  /** insert a single row into the table: "ConferenceConfiguration" */
  readonly insert_ConferenceConfiguration_one?: Maybe<ConferenceConfiguration>;
  /** insert data into the table: "ConferenceDemoCode" */
  readonly insert_ConferenceDemoCode?: Maybe<ConferenceDemoCode_Mutation_Response>;
  /** insert a single row into the table: "ConferenceDemoCode" */
  readonly insert_ConferenceDemoCode_one?: Maybe<ConferenceDemoCode>;
  /** insert data into the table: "ConferencePrepareJob" */
  readonly insert_ConferencePrepareJob?: Maybe<ConferencePrepareJob_Mutation_Response>;
  /** insert a single row into the table: "ConferencePrepareJob" */
  readonly insert_ConferencePrepareJob_one?: Maybe<ConferencePrepareJob>;
  /** insert a single row into the table: "Conference" */
  readonly insert_Conference_one?: Maybe<Conference>;
  /** insert data into the table: "ContentGroup" */
  readonly insert_ContentGroup?: Maybe<ContentGroup_Mutation_Response>;
  /** insert data into the table: "ContentGroupHallway" */
  readonly insert_ContentGroupHallway?: Maybe<ContentGroupHallway_Mutation_Response>;
  /** insert a single row into the table: "ContentGroupHallway" */
  readonly insert_ContentGroupHallway_one?: Maybe<ContentGroupHallway>;
  /** insert data into the table: "ContentGroupPerson" */
  readonly insert_ContentGroupPerson?: Maybe<ContentGroupPerson_Mutation_Response>;
  /** insert a single row into the table: "ContentGroupPerson" */
  readonly insert_ContentGroupPerson_one?: Maybe<ContentGroupPerson>;
  /** insert data into the table: "ContentGroupTag" */
  readonly insert_ContentGroupTag?: Maybe<ContentGroupTag_Mutation_Response>;
  /** insert a single row into the table: "ContentGroupTag" */
  readonly insert_ContentGroupTag_one?: Maybe<ContentGroupTag>;
  /** insert data into the table: "ContentGroupType" */
  readonly insert_ContentGroupType?: Maybe<ContentGroupType_Mutation_Response>;
  /** insert a single row into the table: "ContentGroupType" */
  readonly insert_ContentGroupType_one?: Maybe<ContentGroupType>;
  /** insert a single row into the table: "ContentGroup" */
  readonly insert_ContentGroup_one?: Maybe<ContentGroup>;
  /** insert data into the table: "ContentItem" */
  readonly insert_ContentItem?: Maybe<ContentItem_Mutation_Response>;
  /** insert a single row into the table: "ContentItem" */
  readonly insert_ContentItem_one?: Maybe<ContentItem>;
  /** insert data into the table: "ContentPerson" */
  readonly insert_ContentPerson?: Maybe<ContentPerson_Mutation_Response>;
  /** insert a single row into the table: "ContentPerson" */
  readonly insert_ContentPerson_one?: Maybe<ContentPerson>;
  /** insert data into the table: "ContentType" */
  readonly insert_ContentType?: Maybe<ContentType_Mutation_Response>;
  /** insert a single row into the table: "ContentType" */
  readonly insert_ContentType_one?: Maybe<ContentType>;
  /** insert data into the table: "Email" */
  readonly insert_Email?: Maybe<Email_Mutation_Response>;
  /** insert a single row into the table: "Email" */
  readonly insert_Email_one?: Maybe<Email>;
  /** insert data into the table: "Event" */
  readonly insert_Event?: Maybe<Event_Mutation_Response>;
  /** insert data into the table: "EventParticipantStream" */
  readonly insert_EventParticipantStream?: Maybe<EventParticipantStream_Mutation_Response>;
  /** insert a single row into the table: "EventParticipantStream" */
  readonly insert_EventParticipantStream_one?: Maybe<EventParticipantStream>;
  /** insert data into the table: "EventPerson" */
  readonly insert_EventPerson?: Maybe<EventPerson_Mutation_Response>;
  /** insert data into the table: "EventPersonRole" */
  readonly insert_EventPersonRole?: Maybe<EventPersonRole_Mutation_Response>;
  /** insert a single row into the table: "EventPersonRole" */
  readonly insert_EventPersonRole_one?: Maybe<EventPersonRole>;
  /** insert a single row into the table: "EventPerson" */
  readonly insert_EventPerson_one?: Maybe<EventPerson>;
  /** insert data into the table: "EventRoomJoinRequest" */
  readonly insert_EventRoomJoinRequest?: Maybe<EventRoomJoinRequest_Mutation_Response>;
  /** insert a single row into the table: "EventRoomJoinRequest" */
  readonly insert_EventRoomJoinRequest_one?: Maybe<EventRoomJoinRequest>;
  /** insert data into the table: "EventTag" */
  readonly insert_EventTag?: Maybe<EventTag_Mutation_Response>;
  /** insert a single row into the table: "EventTag" */
  readonly insert_EventTag_one?: Maybe<EventTag>;
  /** insert data into the table: "EventVonageSession" */
  readonly insert_EventVonageSession?: Maybe<EventVonageSession_Mutation_Response>;
  /** insert a single row into the table: "EventVonageSession" */
  readonly insert_EventVonageSession_one?: Maybe<EventVonageSession>;
  /** insert a single row into the table: "Event" */
  readonly insert_Event_one?: Maybe<Event>;
  /** insert data into the table: "ExecutedTransitions" */
  readonly insert_ExecutedTransitions?: Maybe<ExecutedTransitions_Mutation_Response>;
  /** insert a single row into the table: "ExecutedTransitions" */
  readonly insert_ExecutedTransitions_one?: Maybe<ExecutedTransitions>;
  /** insert data into the table: "Group" */
  readonly insert_Group?: Maybe<Group_Mutation_Response>;
  /** insert data into the table: "GroupAttendee" */
  readonly insert_GroupAttendee?: Maybe<GroupAttendee_Mutation_Response>;
  /** insert a single row into the table: "GroupAttendee" */
  readonly insert_GroupAttendee_one?: Maybe<GroupAttendee>;
  /** insert data into the table: "GroupRole" */
  readonly insert_GroupRole?: Maybe<GroupRole_Mutation_Response>;
  /** insert a single row into the table: "GroupRole" */
  readonly insert_GroupRole_one?: Maybe<GroupRole>;
  /** insert a single row into the table: "Group" */
  readonly insert_Group_one?: Maybe<Group>;
  /** insert data into the table: "Hallway" */
  readonly insert_Hallway?: Maybe<Hallway_Mutation_Response>;
  /** insert a single row into the table: "Hallway" */
  readonly insert_Hallway_one?: Maybe<Hallway>;
  /** insert data into the table: "InputType" */
  readonly insert_InputType?: Maybe<InputType_Mutation_Response>;
  /** insert a single row into the table: "InputType" */
  readonly insert_InputType_one?: Maybe<InputType>;
  /** insert data into the table: "Invitation" */
  readonly insert_Invitation?: Maybe<Invitation_Mutation_Response>;
  /** insert a single row into the table: "Invitation" */
  readonly insert_Invitation_one?: Maybe<Invitation>;
  /** insert data into the table: "JobStatus" */
  readonly insert_JobStatus?: Maybe<JobStatus_Mutation_Response>;
  /** insert a single row into the table: "JobStatus" */
  readonly insert_JobStatus_one?: Maybe<JobStatus>;
  /** insert data into the table: "MediaLiveChannel" */
  readonly insert_MediaLiveChannel?: Maybe<MediaLiveChannel_Mutation_Response>;
  /** insert a single row into the table: "MediaLiveChannel" */
  readonly insert_MediaLiveChannel_one?: Maybe<MediaLiveChannel>;
  /** insert data into the table: "OnlineStatus" */
  readonly insert_OnlineStatus?: Maybe<OnlineStatus_Mutation_Response>;
  /** insert a single row into the table: "OnlineStatus" */
  readonly insert_OnlineStatus_one?: Maybe<OnlineStatus>;
  /** insert data into the table: "OriginatingData" */
  readonly insert_OriginatingData?: Maybe<OriginatingData_Mutation_Response>;
  /** insert a single row into the table: "OriginatingData" */
  readonly insert_OriginatingData_one?: Maybe<OriginatingData>;
  /** insert data into the table: "Permission" */
  readonly insert_Permission?: Maybe<Permission_Mutation_Response>;
  /** insert a single row into the table: "Permission" */
  readonly insert_Permission_one?: Maybe<Permission>;
  /** insert data into the table: "RequiredContentItem" */
  readonly insert_RequiredContentItem?: Maybe<RequiredContentItem_Mutation_Response>;
  /** insert a single row into the table: "RequiredContentItem" */
  readonly insert_RequiredContentItem_one?: Maybe<RequiredContentItem>;
  /** insert data into the table: "Role" */
  readonly insert_Role?: Maybe<Role_Mutation_Response>;
  /** insert data into the table: "RolePermission" */
  readonly insert_RolePermission?: Maybe<RolePermission_Mutation_Response>;
  /** insert a single row into the table: "RolePermission" */
  readonly insert_RolePermission_one?: Maybe<RolePermission>;
  /** insert a single row into the table: "Role" */
  readonly insert_Role_one?: Maybe<Role>;
  /** insert data into the table: "Room" */
  readonly insert_Room?: Maybe<Room_Mutation_Response>;
  /** insert data into the table: "RoomMode" */
  readonly insert_RoomMode?: Maybe<RoomMode_Mutation_Response>;
  /** insert a single row into the table: "RoomMode" */
  readonly insert_RoomMode_one?: Maybe<RoomMode>;
  /** insert data into the table: "RoomParticipant" */
  readonly insert_RoomParticipant?: Maybe<RoomParticipant_Mutation_Response>;
  /** insert a single row into the table: "RoomParticipant" */
  readonly insert_RoomParticipant_one?: Maybe<RoomParticipant>;
  /** insert data into the table: "RoomPerson" */
  readonly insert_RoomPerson?: Maybe<RoomPerson_Mutation_Response>;
  /** insert data into the table: "RoomPersonRole" */
  readonly insert_RoomPersonRole?: Maybe<RoomPersonRole_Mutation_Response>;
  /** insert a single row into the table: "RoomPersonRole" */
  readonly insert_RoomPersonRole_one?: Maybe<RoomPersonRole>;
  /** insert a single row into the table: "RoomPerson" */
  readonly insert_RoomPerson_one?: Maybe<RoomPerson>;
  /** insert data into the table: "RoomPrivacy" */
  readonly insert_RoomPrivacy?: Maybe<RoomPrivacy_Mutation_Response>;
  /** insert a single row into the table: "RoomPrivacy" */
  readonly insert_RoomPrivacy_one?: Maybe<RoomPrivacy>;
  /** insert a single row into the table: "Room" */
  readonly insert_Room_one?: Maybe<Room>;
  /** insert data into the table: "Tag" */
  readonly insert_Tag?: Maybe<Tag_Mutation_Response>;
  /** insert a single row into the table: "Tag" */
  readonly insert_Tag_one?: Maybe<Tag>;
  /** insert data into the table: "TranscriptionJob" */
  readonly insert_TranscriptionJob?: Maybe<TranscriptionJob_Mutation_Response>;
  /** insert a single row into the table: "TranscriptionJob" */
  readonly insert_TranscriptionJob_one?: Maybe<TranscriptionJob>;
  /** insert data into the table: "Transitions" */
  readonly insert_Transitions?: Maybe<Transitions_Mutation_Response>;
  /** insert a single row into the table: "Transitions" */
  readonly insert_Transitions_one?: Maybe<Transitions>;
  /** insert data into the table: "Uploader" */
  readonly insert_Uploader?: Maybe<Uploader_Mutation_Response>;
  /** insert a single row into the table: "Uploader" */
  readonly insert_Uploader_one?: Maybe<Uploader>;
  /** insert data into the table: "User" */
  readonly insert_User?: Maybe<User_Mutation_Response>;
  /** insert a single row into the table: "User" */
  readonly insert_User_one?: Maybe<User>;
  /** insert data into the table: "VideoRenderJob" */
  readonly insert_VideoRenderJob?: Maybe<VideoRenderJob_Mutation_Response>;
  /** insert a single row into the table: "VideoRenderJob" */
  readonly insert_VideoRenderJob_one?: Maybe<VideoRenderJob>;
  /** insert data into the table: "chat.Chat" */
  readonly insert_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** insert a single row into the table: "chat.Chat" */
  readonly insert_chat_Chat_one?: Maybe<Chat_Chat>;
  /** insert data into the table: "chat.Flag" */
  readonly insert_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** insert data into the table: "chat.FlagType" */
  readonly insert_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** insert a single row into the table: "chat.FlagType" */
  readonly insert_chat_FlagType_one?: Maybe<Chat_FlagType>;
  /** insert a single row into the table: "chat.Flag" */
  readonly insert_chat_Flag_one?: Maybe<Chat_Flag>;
  /** insert data into the table: "chat.Message" */
  readonly insert_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** insert data into the table: "chat.MessageType" */
  readonly insert_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** insert a single row into the table: "chat.MessageType" */
  readonly insert_chat_MessageType_one?: Maybe<Chat_MessageType>;
  /** insert a single row into the table: "chat.Message" */
  readonly insert_chat_Message_one?: Maybe<Chat_Message>;
  /** insert data into the table: "chat.Pin" */
  readonly insert_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** insert a single row into the table: "chat.Pin" */
  readonly insert_chat_Pin_one?: Maybe<Chat_Pin>;
  /** insert data into the table: "chat.Reaction" */
  readonly insert_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** insert data into the table: "chat.ReactionType" */
  readonly insert_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** insert a single row into the table: "chat.ReactionType" */
  readonly insert_chat_ReactionType_one?: Maybe<Chat_ReactionType>;
  /** insert a single row into the table: "chat.Reaction" */
  readonly insert_chat_Reaction_one?: Maybe<Chat_Reaction>;
  /** insert data into the table: "chat.ReadUpToIndex" */
  readonly insert_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** insert a single row into the table: "chat.ReadUpToIndex" */
  readonly insert_chat_ReadUpToIndex_one?: Maybe<Chat_ReadUpToIndex>;
  /** insert data into the table: "chat.Subscription" */
  readonly insert_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** insert a single row into the table: "chat.Subscription" */
  readonly insert_chat_Subscription_one?: Maybe<Chat_Subscription>;
  /** insert data into the table: "chat.SubscriptionsWithUnnotifiedMessages" */
  readonly insert_chat_SubscriptionsWithUnnotifiedMessages?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Mutation_Response>;
  /** insert a single row into the table: "chat.SubscriptionsWithUnnotifiedMessages" */
  readonly insert_chat_SubscriptionsWithUnnotifiedMessages_one?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages>;
  /** insert data into the table: "chat.Typer" */
  readonly insert_chat_Typer?: Maybe<Chat_Typer_Mutation_Response>;
  /** insert a single row into the table: "chat.Typer" */
  readonly insert_chat_Typer_one?: Maybe<Chat_Typer>;
  /** insert data into the table: "job_queues.InvitationEmailJob" */
  readonly insert_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.InvitationEmailJob" */
  readonly insert_job_queues_InvitationEmailJob_one?: Maybe<Job_Queues_InvitationEmailJob>;
  /** insert data into the table: "job_queues.MediaPackageHarvestJob" */
  readonly insert_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.MediaPackageHarvestJob" */
  readonly insert_job_queues_MediaPackageHarvestJob_one?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** insert data into the table: "job_queues.PublishVideoJob" */
  readonly insert_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.PublishVideoJob" */
  readonly insert_job_queues_PublishVideoJob_one?: Maybe<Job_Queues_PublishVideoJob>;
  /** insert data into the table: "job_queues.SubmissionRequestEmailJob" */
  readonly insert_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.SubmissionRequestEmailJob" */
  readonly insert_job_queues_SubmissionRequestEmailJob_one?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** insert data into the table: "room.ShufflePeriod" */
  readonly insert_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** insert a single row into the table: "room.ShufflePeriod" */
  readonly insert_room_ShufflePeriod_one?: Maybe<Room_ShufflePeriod>;
  /** insert data into the table: "room.ShuffleQueueEntry" */
  readonly insert_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleQueueEntry" */
  readonly insert_room_ShuffleQueueEntry_one?: Maybe<Room_ShuffleQueueEntry>;
  /** insert data into the table: "room.ShuffleRoom" */
  readonly insert_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleRoom" */
  readonly insert_room_ShuffleRoom_one?: Maybe<Room_ShuffleRoom>;
  /** perform the action: "invitationConfirmCurrent" */
  readonly invitationConfirmCurrent?: Maybe<ConfirmInvitationOutput>;
  /** perform the action: "invitationConfirmSendInitialEmail" */
  readonly invitationConfirmSendInitialEmail?: Maybe<InvitationConfirmationEmailOutput>;
  /** perform the action: "invitationConfirmSendRepeatEmail" */
  readonly invitationConfirmSendRepeatEmail?: Maybe<InvitationConfirmationEmailOutput>;
  /** perform the action: "invitationConfirmWithCode" */
  readonly invitationConfirmWithCode?: Maybe<ConfirmInvitationOutput>;
  /** perform the action: "joinEventVonageSession" */
  readonly joinEventVonageSession?: Maybe<JoinEventVonageSessionOutput>;
  /** perform the action: "joinRoomVonageSession" */
  readonly joinRoomVonageSession?: Maybe<JoinRoomVonageSessionOutput>;
  /** perform the action: "stopEventBroadcast" */
  readonly stopEventBroadcast?: Maybe<StopEventBroadcastOutput>;
  /** perform the action: "submitContentItem" */
  readonly submitContentItem?: Maybe<SubmitContentItemOutput>;
  /** perform the action: "updateProfilePhoto" */
  readonly updateProfilePhoto?: Maybe<UpdateProfilePhotoResponse>;
  /** perform the action: "updateSubtitles" */
  readonly updateSubtitles?: Maybe<SubmitUpdatedSubtitlesOutput>;
  /** update data of the table: "Attendee" */
  readonly update_Attendee?: Maybe<Attendee_Mutation_Response>;
  /** update data of the table: "AttendeeProfile" */
  readonly update_AttendeeProfile?: Maybe<AttendeeProfile_Mutation_Response>;
  /** update single row of the table: "AttendeeProfile" */
  readonly update_AttendeeProfile_by_pk?: Maybe<AttendeeProfile>;
  /** update single row of the table: "Attendee" */
  readonly update_Attendee_by_pk?: Maybe<Attendee>;
  /** update data of the table: "Broadcast" */
  readonly update_Broadcast?: Maybe<Broadcast_Mutation_Response>;
  /** update data of the table: "BroadcastContentItem" */
  readonly update_BroadcastContentItem?: Maybe<BroadcastContentItem_Mutation_Response>;
  /** update single row of the table: "BroadcastContentItem" */
  readonly update_BroadcastContentItem_by_pk?: Maybe<BroadcastContentItem>;
  /** update single row of the table: "Broadcast" */
  readonly update_Broadcast_by_pk?: Maybe<Broadcast>;
  /** update data of the table: "Conference" */
  readonly update_Conference?: Maybe<Conference_Mutation_Response>;
  /** update data of the table: "ConferenceConfiguration" */
  readonly update_ConferenceConfiguration?: Maybe<ConferenceConfiguration_Mutation_Response>;
  /** update single row of the table: "ConferenceConfiguration" */
  readonly update_ConferenceConfiguration_by_pk?: Maybe<ConferenceConfiguration>;
  /** update data of the table: "ConferenceDemoCode" */
  readonly update_ConferenceDemoCode?: Maybe<ConferenceDemoCode_Mutation_Response>;
  /** update single row of the table: "ConferenceDemoCode" */
  readonly update_ConferenceDemoCode_by_pk?: Maybe<ConferenceDemoCode>;
  /** update data of the table: "ConferencePrepareJob" */
  readonly update_ConferencePrepareJob?: Maybe<ConferencePrepareJob_Mutation_Response>;
  /** update single row of the table: "ConferencePrepareJob" */
  readonly update_ConferencePrepareJob_by_pk?: Maybe<ConferencePrepareJob>;
  /** update single row of the table: "Conference" */
  readonly update_Conference_by_pk?: Maybe<Conference>;
  /** update data of the table: "ContentGroup" */
  readonly update_ContentGroup?: Maybe<ContentGroup_Mutation_Response>;
  /** update data of the table: "ContentGroupHallway" */
  readonly update_ContentGroupHallway?: Maybe<ContentGroupHallway_Mutation_Response>;
  /** update single row of the table: "ContentGroupHallway" */
  readonly update_ContentGroupHallway_by_pk?: Maybe<ContentGroupHallway>;
  /** update data of the table: "ContentGroupPerson" */
  readonly update_ContentGroupPerson?: Maybe<ContentGroupPerson_Mutation_Response>;
  /** update single row of the table: "ContentGroupPerson" */
  readonly update_ContentGroupPerson_by_pk?: Maybe<ContentGroupPerson>;
  /** update data of the table: "ContentGroupTag" */
  readonly update_ContentGroupTag?: Maybe<ContentGroupTag_Mutation_Response>;
  /** update single row of the table: "ContentGroupTag" */
  readonly update_ContentGroupTag_by_pk?: Maybe<ContentGroupTag>;
  /** update data of the table: "ContentGroupType" */
  readonly update_ContentGroupType?: Maybe<ContentGroupType_Mutation_Response>;
  /** update single row of the table: "ContentGroupType" */
  readonly update_ContentGroupType_by_pk?: Maybe<ContentGroupType>;
  /** update single row of the table: "ContentGroup" */
  readonly update_ContentGroup_by_pk?: Maybe<ContentGroup>;
  /** update data of the table: "ContentItem" */
  readonly update_ContentItem?: Maybe<ContentItem_Mutation_Response>;
  /** update single row of the table: "ContentItem" */
  readonly update_ContentItem_by_pk?: Maybe<ContentItem>;
  /** update data of the table: "ContentPerson" */
  readonly update_ContentPerson?: Maybe<ContentPerson_Mutation_Response>;
  /** update single row of the table: "ContentPerson" */
  readonly update_ContentPerson_by_pk?: Maybe<ContentPerson>;
  /** update data of the table: "ContentType" */
  readonly update_ContentType?: Maybe<ContentType_Mutation_Response>;
  /** update single row of the table: "ContentType" */
  readonly update_ContentType_by_pk?: Maybe<ContentType>;
  /** update data of the table: "Email" */
  readonly update_Email?: Maybe<Email_Mutation_Response>;
  /** update single row of the table: "Email" */
  readonly update_Email_by_pk?: Maybe<Email>;
  /** update data of the table: "Event" */
  readonly update_Event?: Maybe<Event_Mutation_Response>;
  /** update data of the table: "EventParticipantStream" */
  readonly update_EventParticipantStream?: Maybe<EventParticipantStream_Mutation_Response>;
  /** update single row of the table: "EventParticipantStream" */
  readonly update_EventParticipantStream_by_pk?: Maybe<EventParticipantStream>;
  /** update data of the table: "EventPerson" */
  readonly update_EventPerson?: Maybe<EventPerson_Mutation_Response>;
  /** update data of the table: "EventPersonRole" */
  readonly update_EventPersonRole?: Maybe<EventPersonRole_Mutation_Response>;
  /** update single row of the table: "EventPersonRole" */
  readonly update_EventPersonRole_by_pk?: Maybe<EventPersonRole>;
  /** update single row of the table: "EventPerson" */
  readonly update_EventPerson_by_pk?: Maybe<EventPerson>;
  /** update data of the table: "EventRoomJoinRequest" */
  readonly update_EventRoomJoinRequest?: Maybe<EventRoomJoinRequest_Mutation_Response>;
  /** update single row of the table: "EventRoomJoinRequest" */
  readonly update_EventRoomJoinRequest_by_pk?: Maybe<EventRoomJoinRequest>;
  /** update data of the table: "EventTag" */
  readonly update_EventTag?: Maybe<EventTag_Mutation_Response>;
  /** update single row of the table: "EventTag" */
  readonly update_EventTag_by_pk?: Maybe<EventTag>;
  /** update data of the table: "EventVonageSession" */
  readonly update_EventVonageSession?: Maybe<EventVonageSession_Mutation_Response>;
  /** update single row of the table: "EventVonageSession" */
  readonly update_EventVonageSession_by_pk?: Maybe<EventVonageSession>;
  /** update single row of the table: "Event" */
  readonly update_Event_by_pk?: Maybe<Event>;
  /** update data of the table: "ExecutedTransitions" */
  readonly update_ExecutedTransitions?: Maybe<ExecutedTransitions_Mutation_Response>;
  /** update single row of the table: "ExecutedTransitions" */
  readonly update_ExecutedTransitions_by_pk?: Maybe<ExecutedTransitions>;
  /** update data of the table: "Group" */
  readonly update_Group?: Maybe<Group_Mutation_Response>;
  /** update data of the table: "GroupAttendee" */
  readonly update_GroupAttendee?: Maybe<GroupAttendee_Mutation_Response>;
  /** update single row of the table: "GroupAttendee" */
  readonly update_GroupAttendee_by_pk?: Maybe<GroupAttendee>;
  /** update data of the table: "GroupRole" */
  readonly update_GroupRole?: Maybe<GroupRole_Mutation_Response>;
  /** update single row of the table: "GroupRole" */
  readonly update_GroupRole_by_pk?: Maybe<GroupRole>;
  /** update single row of the table: "Group" */
  readonly update_Group_by_pk?: Maybe<Group>;
  /** update data of the table: "Hallway" */
  readonly update_Hallway?: Maybe<Hallway_Mutation_Response>;
  /** update single row of the table: "Hallway" */
  readonly update_Hallway_by_pk?: Maybe<Hallway>;
  /** update data of the table: "InputType" */
  readonly update_InputType?: Maybe<InputType_Mutation_Response>;
  /** update single row of the table: "InputType" */
  readonly update_InputType_by_pk?: Maybe<InputType>;
  /** update data of the table: "Invitation" */
  readonly update_Invitation?: Maybe<Invitation_Mutation_Response>;
  /** update single row of the table: "Invitation" */
  readonly update_Invitation_by_pk?: Maybe<Invitation>;
  /** update data of the table: "JobStatus" */
  readonly update_JobStatus?: Maybe<JobStatus_Mutation_Response>;
  /** update single row of the table: "JobStatus" */
  readonly update_JobStatus_by_pk?: Maybe<JobStatus>;
  /** update data of the table: "MediaLiveChannel" */
  readonly update_MediaLiveChannel?: Maybe<MediaLiveChannel_Mutation_Response>;
  /** update single row of the table: "MediaLiveChannel" */
  readonly update_MediaLiveChannel_by_pk?: Maybe<MediaLiveChannel>;
  /** update data of the table: "OnlineStatus" */
  readonly update_OnlineStatus?: Maybe<OnlineStatus_Mutation_Response>;
  /** update single row of the table: "OnlineStatus" */
  readonly update_OnlineStatus_by_pk?: Maybe<OnlineStatus>;
  /** update data of the table: "OriginatingData" */
  readonly update_OriginatingData?: Maybe<OriginatingData_Mutation_Response>;
  /** update single row of the table: "OriginatingData" */
  readonly update_OriginatingData_by_pk?: Maybe<OriginatingData>;
  /** update data of the table: "Permission" */
  readonly update_Permission?: Maybe<Permission_Mutation_Response>;
  /** update single row of the table: "Permission" */
  readonly update_Permission_by_pk?: Maybe<Permission>;
  /** update data of the table: "RequiredContentItem" */
  readonly update_RequiredContentItem?: Maybe<RequiredContentItem_Mutation_Response>;
  /** update single row of the table: "RequiredContentItem" */
  readonly update_RequiredContentItem_by_pk?: Maybe<RequiredContentItem>;
  /** update data of the table: "Role" */
  readonly update_Role?: Maybe<Role_Mutation_Response>;
  /** update data of the table: "RolePermission" */
  readonly update_RolePermission?: Maybe<RolePermission_Mutation_Response>;
  /** update single row of the table: "RolePermission" */
  readonly update_RolePermission_by_pk?: Maybe<RolePermission>;
  /** update single row of the table: "Role" */
  readonly update_Role_by_pk?: Maybe<Role>;
  /** update data of the table: "Room" */
  readonly update_Room?: Maybe<Room_Mutation_Response>;
  /** update data of the table: "RoomMode" */
  readonly update_RoomMode?: Maybe<RoomMode_Mutation_Response>;
  /** update single row of the table: "RoomMode" */
  readonly update_RoomMode_by_pk?: Maybe<RoomMode>;
  /** update data of the table: "RoomParticipant" */
  readonly update_RoomParticipant?: Maybe<RoomParticipant_Mutation_Response>;
  /** update single row of the table: "RoomParticipant" */
  readonly update_RoomParticipant_by_pk?: Maybe<RoomParticipant>;
  /** update data of the table: "RoomPerson" */
  readonly update_RoomPerson?: Maybe<RoomPerson_Mutation_Response>;
  /** update data of the table: "RoomPersonRole" */
  readonly update_RoomPersonRole?: Maybe<RoomPersonRole_Mutation_Response>;
  /** update single row of the table: "RoomPersonRole" */
  readonly update_RoomPersonRole_by_pk?: Maybe<RoomPersonRole>;
  /** update single row of the table: "RoomPerson" */
  readonly update_RoomPerson_by_pk?: Maybe<RoomPerson>;
  /** update data of the table: "RoomPrivacy" */
  readonly update_RoomPrivacy?: Maybe<RoomPrivacy_Mutation_Response>;
  /** update single row of the table: "RoomPrivacy" */
  readonly update_RoomPrivacy_by_pk?: Maybe<RoomPrivacy>;
  /** update single row of the table: "Room" */
  readonly update_Room_by_pk?: Maybe<Room>;
  /** update data of the table: "Tag" */
  readonly update_Tag?: Maybe<Tag_Mutation_Response>;
  /** update single row of the table: "Tag" */
  readonly update_Tag_by_pk?: Maybe<Tag>;
  /** update data of the table: "TranscriptionJob" */
  readonly update_TranscriptionJob?: Maybe<TranscriptionJob_Mutation_Response>;
  /** update single row of the table: "TranscriptionJob" */
  readonly update_TranscriptionJob_by_pk?: Maybe<TranscriptionJob>;
  /** update data of the table: "Transitions" */
  readonly update_Transitions?: Maybe<Transitions_Mutation_Response>;
  /** update single row of the table: "Transitions" */
  readonly update_Transitions_by_pk?: Maybe<Transitions>;
  /** update data of the table: "Uploader" */
  readonly update_Uploader?: Maybe<Uploader_Mutation_Response>;
  /** update single row of the table: "Uploader" */
  readonly update_Uploader_by_pk?: Maybe<Uploader>;
  /** update data of the table: "User" */
  readonly update_User?: Maybe<User_Mutation_Response>;
  /** update single row of the table: "User" */
  readonly update_User_by_pk?: Maybe<User>;
  /** update data of the table: "VideoRenderJob" */
  readonly update_VideoRenderJob?: Maybe<VideoRenderJob_Mutation_Response>;
  /** update single row of the table: "VideoRenderJob" */
  readonly update_VideoRenderJob_by_pk?: Maybe<VideoRenderJob>;
  /** update data of the table: "chat.Chat" */
  readonly update_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** update single row of the table: "chat.Chat" */
  readonly update_chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** update data of the table: "chat.Flag" */
  readonly update_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** update data of the table: "chat.FlagType" */
  readonly update_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** update single row of the table: "chat.FlagType" */
  readonly update_chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** update single row of the table: "chat.Flag" */
  readonly update_chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** update data of the table: "chat.Message" */
  readonly update_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** update data of the table: "chat.MessageType" */
  readonly update_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** update single row of the table: "chat.MessageType" */
  readonly update_chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** update single row of the table: "chat.Message" */
  readonly update_chat_Message_by_pk?: Maybe<Chat_Message>;
  /** update data of the table: "chat.Pin" */
  readonly update_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** update single row of the table: "chat.Pin" */
  readonly update_chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** update data of the table: "chat.Reaction" */
  readonly update_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** update data of the table: "chat.ReactionType" */
  readonly update_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** update single row of the table: "chat.ReactionType" */
  readonly update_chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** update single row of the table: "chat.Reaction" */
  readonly update_chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** update data of the table: "chat.ReadUpToIndex" */
  readonly update_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** update single row of the table: "chat.ReadUpToIndex" */
  readonly update_chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** update data of the table: "chat.Subscription" */
  readonly update_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** update single row of the table: "chat.Subscription" */
  readonly update_chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** update data of the table: "chat.SubscriptionsWithUnnotifiedMessages" */
  readonly update_chat_SubscriptionsWithUnnotifiedMessages?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Mutation_Response>;
  /** update data of the table: "chat.Typer" */
  readonly update_chat_Typer?: Maybe<Chat_Typer_Mutation_Response>;
  /** update single row of the table: "chat.Typer" */
  readonly update_chat_Typer_by_pk?: Maybe<Chat_Typer>;
  /** update data of the table: "job_queues.InvitationEmailJob" */
  readonly update_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.InvitationEmailJob" */
  readonly update_job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** update data of the table: "job_queues.MediaPackageHarvestJob" */
  readonly update_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** update single row of the table: "job_queues.MediaPackageHarvestJob" */
  readonly update_job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** update data of the table: "job_queues.PublishVideoJob" */
  readonly update_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** update single row of the table: "job_queues.PublishVideoJob" */
  readonly update_job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** update data of the table: "job_queues.SubmissionRequestEmailJob" */
  readonly update_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.SubmissionRequestEmailJob" */
  readonly update_job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** update data of the table: "room.ShufflePeriod" */
  readonly update_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** update single row of the table: "room.ShufflePeriod" */
  readonly update_room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** update data of the table: "room.ShuffleQueueEntry" */
  readonly update_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** update single row of the table: "room.ShuffleQueueEntry" */
  readonly update_room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** update data of the table: "room.ShuffleRoom" */
  readonly update_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** update single row of the table: "room.ShuffleRoom" */
  readonly update_room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
};


/** mutation root */
export type Mutation_RootCreateContentGroupRoomArgs = {
  conferenceId: Scalars['uuid'];
  contentGroupId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCreateRoomDmArgs = {
  attendeeIds: ReadonlyArray<Maybe<Scalars['uuid']>>;
  conferenceId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_AttendeeArgs = {
  where: Attendee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_AttendeeProfileArgs = {
  where: AttendeeProfile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_AttendeeProfile_By_PkArgs = {
  attendeeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Attendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_BroadcastArgs = {
  where: Broadcast_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_BroadcastContentItemArgs = {
  where: BroadcastContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_BroadcastContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Broadcast_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ConferenceArgs = {
  where: Conference_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ConferenceConfigurationArgs = {
  where: ConferenceConfiguration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ConferenceConfiguration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ConferenceDemoCodeArgs = {
  where: ConferenceDemoCode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ConferenceDemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ConferencePrepareJobArgs = {
  where: ConferencePrepareJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ConferencePrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupArgs = {
  where: ContentGroup_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupHallwayArgs = {
  where: ContentGroupHallway_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupPersonArgs = {
  where: ContentGroupPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupTagArgs = {
  where: ContentGroupTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupTypeArgs = {
  where: ContentGroupType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentItemArgs = {
  where: ContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentPersonArgs = {
  where: ContentPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentTypeArgs = {
  where: ContentType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_EmailArgs = {
  where: Email_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Email_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventArgs = {
  where: Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventParticipantStreamArgs = {
  where: EventParticipantStream_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventPersonArgs = {
  where: EventPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventPersonRoleArgs = {
  where: EventPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_EventPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventRoomJoinRequestArgs = {
  where: EventRoomJoinRequest_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventRoomJoinRequest_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventTagArgs = {
  where: EventTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventVonageSessionArgs = {
  where: EventVonageSession_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Event_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ExecutedTransitionsArgs = {
  where: ExecutedTransitions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ExecutedTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_GroupArgs = {
  where: Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_GroupAttendeeArgs = {
  where: GroupAttendee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_GroupAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_GroupRoleArgs = {
  where: GroupRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_GroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_HallwayArgs = {
  where: Hallway_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Hallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_InputTypeArgs = {
  where: InputType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_InputType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_InvitationArgs = {
  where: Invitation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Invitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_JobStatusArgs = {
  where: JobStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_JobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_MediaLiveChannelArgs = {
  where: MediaLiveChannel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_MediaLiveChannel_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_OnlineStatusArgs = {
  where: OnlineStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_OnlineStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_OriginatingDataArgs = {
  where: OriginatingData_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_OriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_PermissionArgs = {
  where: Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permission_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_RequiredContentItemArgs = {
  where: RequiredContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RequiredContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_RoleArgs = {
  where: Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RolePermissionArgs = {
  where: RolePermission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_RoomArgs = {
  where: Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomModeArgs = {
  where: RoomMode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomMode_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_RoomParticipantArgs = {
  where: RoomParticipant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomParticipant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_RoomPersonArgs = {
  where: RoomPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomPersonRoleArgs = {
  where: RoomPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_RoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_RoomPrivacyArgs = {
  where: RoomPrivacy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomPrivacy_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_TagArgs = {
  where: Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_TranscriptionJobArgs = {
  where: TranscriptionJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_TranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_TransitionsArgs = {
  where: Transitions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Transitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_UploaderArgs = {
  where: Uploader_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Uploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_UserArgs = {
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_By_PkArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_VideoRenderJobArgs = {
  where: VideoRenderJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_VideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ChatArgs = {
  where: Chat_Chat_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagArgs = {
  where: Chat_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagTypeArgs = {
  where: Chat_FlagType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageArgs = {
  where: Chat_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageTypeArgs = {
  where: Chat_MessageType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_PinArgs = {
  where: Chat_Pin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Pin_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionArgs = {
  where: Chat_Reaction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionTypeArgs = {
  where: Chat_ReactionType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Reaction_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReadUpToIndexArgs = {
  where: Chat_ReadUpToIndex_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReadUpToIndex_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_SubscriptionArgs = {
  where: Chat_Subscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Subscription_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_SubscriptionsWithUnnotifiedMessagesArgs = {
  where: Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_TyperArgs = {
  where: Chat_Typer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Typer_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_InvitationEmailJobArgs = {
  where: Job_Queues_InvitationEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_MediaPackageHarvestJobArgs = {
  where: Job_Queues_MediaPackageHarvestJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_PublishVideoJobArgs = {
  where: Job_Queues_PublishVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_SubmissionRequestEmailJobArgs = {
  where: Job_Queues_SubmissionRequestEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShufflePeriodArgs = {
  where: Room_ShufflePeriod_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleQueueEntryArgs = {
  where: Room_ShuffleQueueEntry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleRoomArgs = {
  where: Room_ShuffleRoom_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootInsert_AttendeeArgs = {
  objects: ReadonlyArray<Attendee_Insert_Input>;
  on_conflict?: Maybe<Attendee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AttendeeProfileArgs = {
  objects: ReadonlyArray<AttendeeProfile_Insert_Input>;
  on_conflict?: Maybe<AttendeeProfile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AttendeeProfile_OneArgs = {
  object: AttendeeProfile_Insert_Input;
  on_conflict?: Maybe<AttendeeProfile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Attendee_OneArgs = {
  object: Attendee_Insert_Input;
  on_conflict?: Maybe<Attendee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BroadcastArgs = {
  objects: ReadonlyArray<Broadcast_Insert_Input>;
  on_conflict?: Maybe<Broadcast_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BroadcastContentItemArgs = {
  objects: ReadonlyArray<BroadcastContentItem_Insert_Input>;
  on_conflict?: Maybe<BroadcastContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BroadcastContentItem_OneArgs = {
  object: BroadcastContentItem_Insert_Input;
  on_conflict?: Maybe<BroadcastContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Broadcast_OneArgs = {
  object: Broadcast_Insert_Input;
  on_conflict?: Maybe<Broadcast_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceArgs = {
  objects: ReadonlyArray<Conference_Insert_Input>;
  on_conflict?: Maybe<Conference_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceConfigurationArgs = {
  objects: ReadonlyArray<ConferenceConfiguration_Insert_Input>;
  on_conflict?: Maybe<ConferenceConfiguration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceConfiguration_OneArgs = {
  object: ConferenceConfiguration_Insert_Input;
  on_conflict?: Maybe<ConferenceConfiguration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceDemoCodeArgs = {
  objects: ReadonlyArray<ConferenceDemoCode_Insert_Input>;
  on_conflict?: Maybe<ConferenceDemoCode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceDemoCode_OneArgs = {
  object: ConferenceDemoCode_Insert_Input;
  on_conflict?: Maybe<ConferenceDemoCode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferencePrepareJobArgs = {
  objects: ReadonlyArray<ConferencePrepareJob_Insert_Input>;
  on_conflict?: Maybe<ConferencePrepareJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferencePrepareJob_OneArgs = {
  object: ConferencePrepareJob_Insert_Input;
  on_conflict?: Maybe<ConferencePrepareJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_OneArgs = {
  object: Conference_Insert_Input;
  on_conflict?: Maybe<Conference_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupArgs = {
  objects: ReadonlyArray<ContentGroup_Insert_Input>;
  on_conflict?: Maybe<ContentGroup_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupHallwayArgs = {
  objects: ReadonlyArray<ContentGroupHallway_Insert_Input>;
  on_conflict?: Maybe<ContentGroupHallway_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupHallway_OneArgs = {
  object: ContentGroupHallway_Insert_Input;
  on_conflict?: Maybe<ContentGroupHallway_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupPersonArgs = {
  objects: ReadonlyArray<ContentGroupPerson_Insert_Input>;
  on_conflict?: Maybe<ContentGroupPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupPerson_OneArgs = {
  object: ContentGroupPerson_Insert_Input;
  on_conflict?: Maybe<ContentGroupPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupTagArgs = {
  objects: ReadonlyArray<ContentGroupTag_Insert_Input>;
  on_conflict?: Maybe<ContentGroupTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupTag_OneArgs = {
  object: ContentGroupTag_Insert_Input;
  on_conflict?: Maybe<ContentGroupTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupTypeArgs = {
  objects: ReadonlyArray<ContentGroupType_Insert_Input>;
  on_conflict?: Maybe<ContentGroupType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupType_OneArgs = {
  object: ContentGroupType_Insert_Input;
  on_conflict?: Maybe<ContentGroupType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroup_OneArgs = {
  object: ContentGroup_Insert_Input;
  on_conflict?: Maybe<ContentGroup_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentItemArgs = {
  objects: ReadonlyArray<ContentItem_Insert_Input>;
  on_conflict?: Maybe<ContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentItem_OneArgs = {
  object: ContentItem_Insert_Input;
  on_conflict?: Maybe<ContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentPersonArgs = {
  objects: ReadonlyArray<ContentPerson_Insert_Input>;
  on_conflict?: Maybe<ContentPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentPerson_OneArgs = {
  object: ContentPerson_Insert_Input;
  on_conflict?: Maybe<ContentPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentTypeArgs = {
  objects: ReadonlyArray<ContentType_Insert_Input>;
  on_conflict?: Maybe<ContentType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentType_OneArgs = {
  object: ContentType_Insert_Input;
  on_conflict?: Maybe<ContentType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EmailArgs = {
  objects: ReadonlyArray<Email_Insert_Input>;
  on_conflict?: Maybe<Email_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Email_OneArgs = {
  object: Email_Insert_Input;
  on_conflict?: Maybe<Email_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventArgs = {
  objects: ReadonlyArray<Event_Insert_Input>;
  on_conflict?: Maybe<Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventParticipantStreamArgs = {
  objects: ReadonlyArray<EventParticipantStream_Insert_Input>;
  on_conflict?: Maybe<EventParticipantStream_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventParticipantStream_OneArgs = {
  object: EventParticipantStream_Insert_Input;
  on_conflict?: Maybe<EventParticipantStream_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventPersonArgs = {
  objects: ReadonlyArray<EventPerson_Insert_Input>;
  on_conflict?: Maybe<EventPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventPersonRoleArgs = {
  objects: ReadonlyArray<EventPersonRole_Insert_Input>;
  on_conflict?: Maybe<EventPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventPersonRole_OneArgs = {
  object: EventPersonRole_Insert_Input;
  on_conflict?: Maybe<EventPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventPerson_OneArgs = {
  object: EventPerson_Insert_Input;
  on_conflict?: Maybe<EventPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventRoomJoinRequestArgs = {
  objects: ReadonlyArray<EventRoomJoinRequest_Insert_Input>;
  on_conflict?: Maybe<EventRoomJoinRequest_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventRoomJoinRequest_OneArgs = {
  object: EventRoomJoinRequest_Insert_Input;
  on_conflict?: Maybe<EventRoomJoinRequest_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventTagArgs = {
  objects: ReadonlyArray<EventTag_Insert_Input>;
  on_conflict?: Maybe<EventTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventTag_OneArgs = {
  object: EventTag_Insert_Input;
  on_conflict?: Maybe<EventTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventVonageSessionArgs = {
  objects: ReadonlyArray<EventVonageSession_Insert_Input>;
  on_conflict?: Maybe<EventVonageSession_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventVonageSession_OneArgs = {
  object: EventVonageSession_Insert_Input;
  on_conflict?: Maybe<EventVonageSession_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Event_OneArgs = {
  object: Event_Insert_Input;
  on_conflict?: Maybe<Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ExecutedTransitionsArgs = {
  objects: ReadonlyArray<ExecutedTransitions_Insert_Input>;
  on_conflict?: Maybe<ExecutedTransitions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ExecutedTransitions_OneArgs = {
  object: ExecutedTransitions_Insert_Input;
  on_conflict?: Maybe<ExecutedTransitions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupArgs = {
  objects: ReadonlyArray<Group_Insert_Input>;
  on_conflict?: Maybe<Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupAttendeeArgs = {
  objects: ReadonlyArray<GroupAttendee_Insert_Input>;
  on_conflict?: Maybe<GroupAttendee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupAttendee_OneArgs = {
  object: GroupAttendee_Insert_Input;
  on_conflict?: Maybe<GroupAttendee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupRoleArgs = {
  objects: ReadonlyArray<GroupRole_Insert_Input>;
  on_conflict?: Maybe<GroupRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupRole_OneArgs = {
  object: GroupRole_Insert_Input;
  on_conflict?: Maybe<GroupRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Group_OneArgs = {
  object: Group_Insert_Input;
  on_conflict?: Maybe<Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_HallwayArgs = {
  objects: ReadonlyArray<Hallway_Insert_Input>;
  on_conflict?: Maybe<Hallway_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Hallway_OneArgs = {
  object: Hallway_Insert_Input;
  on_conflict?: Maybe<Hallway_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InputTypeArgs = {
  objects: ReadonlyArray<InputType_Insert_Input>;
  on_conflict?: Maybe<InputType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InputType_OneArgs = {
  object: InputType_Insert_Input;
  on_conflict?: Maybe<InputType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InvitationArgs = {
  objects: ReadonlyArray<Invitation_Insert_Input>;
  on_conflict?: Maybe<Invitation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Invitation_OneArgs = {
  object: Invitation_Insert_Input;
  on_conflict?: Maybe<Invitation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_JobStatusArgs = {
  objects: ReadonlyArray<JobStatus_Insert_Input>;
  on_conflict?: Maybe<JobStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_JobStatus_OneArgs = {
  object: JobStatus_Insert_Input;
  on_conflict?: Maybe<JobStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MediaLiveChannelArgs = {
  objects: ReadonlyArray<MediaLiveChannel_Insert_Input>;
  on_conflict?: Maybe<MediaLiveChannel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MediaLiveChannel_OneArgs = {
  object: MediaLiveChannel_Insert_Input;
  on_conflict?: Maybe<MediaLiveChannel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OnlineStatusArgs = {
  objects: ReadonlyArray<OnlineStatus_Insert_Input>;
  on_conflict?: Maybe<OnlineStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OnlineStatus_OneArgs = {
  object: OnlineStatus_Insert_Input;
  on_conflict?: Maybe<OnlineStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OriginatingDataArgs = {
  objects: ReadonlyArray<OriginatingData_Insert_Input>;
  on_conflict?: Maybe<OriginatingData_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OriginatingData_OneArgs = {
  object: OriginatingData_Insert_Input;
  on_conflict?: Maybe<OriginatingData_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PermissionArgs = {
  objects: ReadonlyArray<Permission_Insert_Input>;
  on_conflict?: Maybe<Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permission_OneArgs = {
  object: Permission_Insert_Input;
  on_conflict?: Maybe<Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RequiredContentItemArgs = {
  objects: ReadonlyArray<RequiredContentItem_Insert_Input>;
  on_conflict?: Maybe<RequiredContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RequiredContentItem_OneArgs = {
  object: RequiredContentItem_Insert_Input;
  on_conflict?: Maybe<RequiredContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoleArgs = {
  objects: ReadonlyArray<Role_Insert_Input>;
  on_conflict?: Maybe<Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RolePermissionArgs = {
  objects: ReadonlyArray<RolePermission_Insert_Input>;
  on_conflict?: Maybe<RolePermission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RolePermission_OneArgs = {
  object: RolePermission_Insert_Input;
  on_conflict?: Maybe<RolePermission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Role_OneArgs = {
  object: Role_Insert_Input;
  on_conflict?: Maybe<Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomArgs = {
  objects: ReadonlyArray<Room_Insert_Input>;
  on_conflict?: Maybe<Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomModeArgs = {
  objects: ReadonlyArray<RoomMode_Insert_Input>;
  on_conflict?: Maybe<RoomMode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomMode_OneArgs = {
  object: RoomMode_Insert_Input;
  on_conflict?: Maybe<RoomMode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomParticipantArgs = {
  objects: ReadonlyArray<RoomParticipant_Insert_Input>;
  on_conflict?: Maybe<RoomParticipant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomParticipant_OneArgs = {
  object: RoomParticipant_Insert_Input;
  on_conflict?: Maybe<RoomParticipant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPersonArgs = {
  objects: ReadonlyArray<RoomPerson_Insert_Input>;
  on_conflict?: Maybe<RoomPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPersonRoleArgs = {
  objects: ReadonlyArray<RoomPersonRole_Insert_Input>;
  on_conflict?: Maybe<RoomPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPersonRole_OneArgs = {
  object: RoomPersonRole_Insert_Input;
  on_conflict?: Maybe<RoomPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPerson_OneArgs = {
  object: RoomPerson_Insert_Input;
  on_conflict?: Maybe<RoomPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPrivacyArgs = {
  objects: ReadonlyArray<RoomPrivacy_Insert_Input>;
  on_conflict?: Maybe<RoomPrivacy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPrivacy_OneArgs = {
  object: RoomPrivacy_Insert_Input;
  on_conflict?: Maybe<RoomPrivacy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_OneArgs = {
  object: Room_Insert_Input;
  on_conflict?: Maybe<Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TagArgs = {
  objects: ReadonlyArray<Tag_Insert_Input>;
  on_conflict?: Maybe<Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tag_OneArgs = {
  object: Tag_Insert_Input;
  on_conflict?: Maybe<Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TranscriptionJobArgs = {
  objects: ReadonlyArray<TranscriptionJob_Insert_Input>;
  on_conflict?: Maybe<TranscriptionJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TranscriptionJob_OneArgs = {
  object: TranscriptionJob_Insert_Input;
  on_conflict?: Maybe<TranscriptionJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TransitionsArgs = {
  objects: ReadonlyArray<Transitions_Insert_Input>;
  on_conflict?: Maybe<Transitions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Transitions_OneArgs = {
  object: Transitions_Insert_Input;
  on_conflict?: Maybe<Transitions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UploaderArgs = {
  objects: ReadonlyArray<Uploader_Insert_Input>;
  on_conflict?: Maybe<Uploader_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Uploader_OneArgs = {
  object: Uploader_Insert_Input;
  on_conflict?: Maybe<Uploader_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UserArgs = {
  objects: ReadonlyArray<User_Insert_Input>;
  on_conflict?: Maybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_OneArgs = {
  object: User_Insert_Input;
  on_conflict?: Maybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VideoRenderJobArgs = {
  objects: ReadonlyArray<VideoRenderJob_Insert_Input>;
  on_conflict?: Maybe<VideoRenderJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VideoRenderJob_OneArgs = {
  object: VideoRenderJob_Insert_Input;
  on_conflict?: Maybe<VideoRenderJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ChatArgs = {
  objects: ReadonlyArray<Chat_Chat_Insert_Input>;
  on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Chat_OneArgs = {
  object: Chat_Chat_Insert_Input;
  on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagArgs = {
  objects: ReadonlyArray<Chat_Flag_Insert_Input>;
  on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagTypeArgs = {
  objects: ReadonlyArray<Chat_FlagType_Insert_Input>;
  on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagType_OneArgs = {
  object: Chat_FlagType_Insert_Input;
  on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Flag_OneArgs = {
  object: Chat_Flag_Insert_Input;
  on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageArgs = {
  objects: ReadonlyArray<Chat_Message_Insert_Input>;
  on_conflict?: Maybe<Chat_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageTypeArgs = {
  objects: ReadonlyArray<Chat_MessageType_Insert_Input>;
  on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageType_OneArgs = {
  object: Chat_MessageType_Insert_Input;
  on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Message_OneArgs = {
  object: Chat_Message_Insert_Input;
  on_conflict?: Maybe<Chat_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_PinArgs = {
  objects: ReadonlyArray<Chat_Pin_Insert_Input>;
  on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Pin_OneArgs = {
  object: Chat_Pin_Insert_Input;
  on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionArgs = {
  objects: ReadonlyArray<Chat_Reaction_Insert_Input>;
  on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionTypeArgs = {
  objects: ReadonlyArray<Chat_ReactionType_Insert_Input>;
  on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionType_OneArgs = {
  object: Chat_ReactionType_Insert_Input;
  on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Reaction_OneArgs = {
  object: Chat_Reaction_Insert_Input;
  on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReadUpToIndexArgs = {
  objects: ReadonlyArray<Chat_ReadUpToIndex_Insert_Input>;
  on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReadUpToIndex_OneArgs = {
  object: Chat_ReadUpToIndex_Insert_Input;
  on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_SubscriptionArgs = {
  objects: ReadonlyArray<Chat_Subscription_Insert_Input>;
  on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Subscription_OneArgs = {
  object: Chat_Subscription_Insert_Input;
  on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_SubscriptionsWithUnnotifiedMessagesArgs = {
  objects: ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_SubscriptionsWithUnnotifiedMessages_OneArgs = {
  object: Chat_SubscriptionsWithUnnotifiedMessages_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Chat_TyperArgs = {
  objects: ReadonlyArray<Chat_Typer_Insert_Input>;
  on_conflict?: Maybe<Chat_Typer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Typer_OneArgs = {
  object: Chat_Typer_Insert_Input;
  on_conflict?: Maybe<Chat_Typer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_InvitationEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_InvitationEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_InvitationEmailJob_OneArgs = {
  object: Job_Queues_InvitationEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_MediaPackageHarvestJobArgs = {
  objects: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_MediaPackageHarvestJob_OneArgs = {
  object: Job_Queues_MediaPackageHarvestJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_PublishVideoJobArgs = {
  objects: ReadonlyArray<Job_Queues_PublishVideoJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_PublishVideoJob_OneArgs = {
  object: Job_Queues_PublishVideoJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_SubmissionRequestEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_SubmissionRequestEmailJob_OneArgs = {
  object: Job_Queues_SubmissionRequestEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShufflePeriodArgs = {
  objects: ReadonlyArray<Room_ShufflePeriod_Insert_Input>;
  on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShufflePeriod_OneArgs = {
  object: Room_ShufflePeriod_Insert_Input;
  on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleQueueEntryArgs = {
  objects: ReadonlyArray<Room_ShuffleQueueEntry_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleQueueEntry_OneArgs = {
  object: Room_ShuffleQueueEntry_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleRoomArgs = {
  objects: ReadonlyArray<Room_ShuffleRoom_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleRoom_OneArgs = {
  object: Room_ShuffleRoom_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInvitationConfirmCurrentArgs = {
  inviteCode: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootInvitationConfirmSendInitialEmailArgs = {
  inviteInput: InvitationConfirmationEmailInput;
};


/** mutation root */
export type Mutation_RootInvitationConfirmSendRepeatEmailArgs = {
  inviteInput: InvitationConfirmationEmailInput;
};


/** mutation root */
export type Mutation_RootInvitationConfirmWithCodeArgs = {
  inviteInput: ConfirmInvitationInput;
};


/** mutation root */
export type Mutation_RootJoinEventVonageSessionArgs = {
  eventId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootJoinRoomVonageSessionArgs = {
  roomId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootStopEventBroadcastArgs = {
  eventId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootSubmitContentItemArgs = {
  data: Scalars['jsonb'];
  magicToken: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdateProfilePhotoArgs = {
  attendeeId: Scalars['uuid'];
  s3URL?: Maybe<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootUpdateSubtitlesArgs = {
  contentItemId: Scalars['String'];
  magicToken: Scalars['String'];
  subtitleText: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdate_AttendeeArgs = {
  _set?: Maybe<Attendee_Set_Input>;
  where: Attendee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_AttendeeProfileArgs = {
  _append?: Maybe<AttendeeProfile_Append_Input>;
  _delete_at_path?: Maybe<AttendeeProfile_Delete_At_Path_Input>;
  _delete_elem?: Maybe<AttendeeProfile_Delete_Elem_Input>;
  _delete_key?: Maybe<AttendeeProfile_Delete_Key_Input>;
  _inc?: Maybe<AttendeeProfile_Inc_Input>;
  _prepend?: Maybe<AttendeeProfile_Prepend_Input>;
  _set?: Maybe<AttendeeProfile_Set_Input>;
  where: AttendeeProfile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_AttendeeProfile_By_PkArgs = {
  _append?: Maybe<AttendeeProfile_Append_Input>;
  _delete_at_path?: Maybe<AttendeeProfile_Delete_At_Path_Input>;
  _delete_elem?: Maybe<AttendeeProfile_Delete_Elem_Input>;
  _delete_key?: Maybe<AttendeeProfile_Delete_Key_Input>;
  _inc?: Maybe<AttendeeProfile_Inc_Input>;
  _prepend?: Maybe<AttendeeProfile_Prepend_Input>;
  _set?: Maybe<AttendeeProfile_Set_Input>;
  pk_columns: AttendeeProfile_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Attendee_By_PkArgs = {
  _set?: Maybe<Attendee_Set_Input>;
  pk_columns: Attendee_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_BroadcastArgs = {
  _append?: Maybe<Broadcast_Append_Input>;
  _delete_at_path?: Maybe<Broadcast_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Broadcast_Delete_Elem_Input>;
  _delete_key?: Maybe<Broadcast_Delete_Key_Input>;
  _prepend?: Maybe<Broadcast_Prepend_Input>;
  _set?: Maybe<Broadcast_Set_Input>;
  where: Broadcast_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_BroadcastContentItemArgs = {
  _append?: Maybe<BroadcastContentItem_Append_Input>;
  _delete_at_path?: Maybe<BroadcastContentItem_Delete_At_Path_Input>;
  _delete_elem?: Maybe<BroadcastContentItem_Delete_Elem_Input>;
  _delete_key?: Maybe<BroadcastContentItem_Delete_Key_Input>;
  _prepend?: Maybe<BroadcastContentItem_Prepend_Input>;
  _set?: Maybe<BroadcastContentItem_Set_Input>;
  where: BroadcastContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_BroadcastContentItem_By_PkArgs = {
  _append?: Maybe<BroadcastContentItem_Append_Input>;
  _delete_at_path?: Maybe<BroadcastContentItem_Delete_At_Path_Input>;
  _delete_elem?: Maybe<BroadcastContentItem_Delete_Elem_Input>;
  _delete_key?: Maybe<BroadcastContentItem_Delete_Key_Input>;
  _prepend?: Maybe<BroadcastContentItem_Prepend_Input>;
  _set?: Maybe<BroadcastContentItem_Set_Input>;
  pk_columns: BroadcastContentItem_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Broadcast_By_PkArgs = {
  _append?: Maybe<Broadcast_Append_Input>;
  _delete_at_path?: Maybe<Broadcast_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Broadcast_Delete_Elem_Input>;
  _delete_key?: Maybe<Broadcast_Delete_Key_Input>;
  _prepend?: Maybe<Broadcast_Prepend_Input>;
  _set?: Maybe<Broadcast_Set_Input>;
  pk_columns: Broadcast_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceArgs = {
  _set?: Maybe<Conference_Set_Input>;
  where: Conference_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceConfigurationArgs = {
  _append?: Maybe<ConferenceConfiguration_Append_Input>;
  _delete_at_path?: Maybe<ConferenceConfiguration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ConferenceConfiguration_Delete_Elem_Input>;
  _delete_key?: Maybe<ConferenceConfiguration_Delete_Key_Input>;
  _prepend?: Maybe<ConferenceConfiguration_Prepend_Input>;
  _set?: Maybe<ConferenceConfiguration_Set_Input>;
  where: ConferenceConfiguration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceConfiguration_By_PkArgs = {
  _append?: Maybe<ConferenceConfiguration_Append_Input>;
  _delete_at_path?: Maybe<ConferenceConfiguration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ConferenceConfiguration_Delete_Elem_Input>;
  _delete_key?: Maybe<ConferenceConfiguration_Delete_Key_Input>;
  _prepend?: Maybe<ConferenceConfiguration_Prepend_Input>;
  _set?: Maybe<ConferenceConfiguration_Set_Input>;
  pk_columns: ConferenceConfiguration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceDemoCodeArgs = {
  _set?: Maybe<ConferenceDemoCode_Set_Input>;
  where: ConferenceDemoCode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceDemoCode_By_PkArgs = {
  _set?: Maybe<ConferenceDemoCode_Set_Input>;
  pk_columns: ConferenceDemoCode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ConferencePrepareJobArgs = {
  _set?: Maybe<ConferencePrepareJob_Set_Input>;
  where: ConferencePrepareJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ConferencePrepareJob_By_PkArgs = {
  _set?: Maybe<ConferencePrepareJob_Set_Input>;
  pk_columns: ConferencePrepareJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_By_PkArgs = {
  _set?: Maybe<Conference_Set_Input>;
  pk_columns: Conference_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupArgs = {
  _set?: Maybe<ContentGroup_Set_Input>;
  where: ContentGroup_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupHallwayArgs = {
  _append?: Maybe<ContentGroupHallway_Append_Input>;
  _delete_at_path?: Maybe<ContentGroupHallway_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ContentGroupHallway_Delete_Elem_Input>;
  _delete_key?: Maybe<ContentGroupHallway_Delete_Key_Input>;
  _inc?: Maybe<ContentGroupHallway_Inc_Input>;
  _prepend?: Maybe<ContentGroupHallway_Prepend_Input>;
  _set?: Maybe<ContentGroupHallway_Set_Input>;
  where: ContentGroupHallway_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupHallway_By_PkArgs = {
  _append?: Maybe<ContentGroupHallway_Append_Input>;
  _delete_at_path?: Maybe<ContentGroupHallway_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ContentGroupHallway_Delete_Elem_Input>;
  _delete_key?: Maybe<ContentGroupHallway_Delete_Key_Input>;
  _inc?: Maybe<ContentGroupHallway_Inc_Input>;
  _prepend?: Maybe<ContentGroupHallway_Prepend_Input>;
  _set?: Maybe<ContentGroupHallway_Set_Input>;
  pk_columns: ContentGroupHallway_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupPersonArgs = {
  _inc?: Maybe<ContentGroupPerson_Inc_Input>;
  _set?: Maybe<ContentGroupPerson_Set_Input>;
  where: ContentGroupPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupPerson_By_PkArgs = {
  _inc?: Maybe<ContentGroupPerson_Inc_Input>;
  _set?: Maybe<ContentGroupPerson_Set_Input>;
  pk_columns: ContentGroupPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupTagArgs = {
  _set?: Maybe<ContentGroupTag_Set_Input>;
  where: ContentGroupTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupTag_By_PkArgs = {
  _set?: Maybe<ContentGroupTag_Set_Input>;
  pk_columns: ContentGroupTag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupTypeArgs = {
  _set?: Maybe<ContentGroupType_Set_Input>;
  where: ContentGroupType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupType_By_PkArgs = {
  _set?: Maybe<ContentGroupType_Set_Input>;
  pk_columns: ContentGroupType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroup_By_PkArgs = {
  _set?: Maybe<ContentGroup_Set_Input>;
  pk_columns: ContentGroup_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentItemArgs = {
  _append?: Maybe<ContentItem_Append_Input>;
  _delete_at_path?: Maybe<ContentItem_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ContentItem_Delete_Elem_Input>;
  _delete_key?: Maybe<ContentItem_Delete_Key_Input>;
  _prepend?: Maybe<ContentItem_Prepend_Input>;
  _set?: Maybe<ContentItem_Set_Input>;
  where: ContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentItem_By_PkArgs = {
  _append?: Maybe<ContentItem_Append_Input>;
  _delete_at_path?: Maybe<ContentItem_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ContentItem_Delete_Elem_Input>;
  _delete_key?: Maybe<ContentItem_Delete_Key_Input>;
  _prepend?: Maybe<ContentItem_Prepend_Input>;
  _set?: Maybe<ContentItem_Set_Input>;
  pk_columns: ContentItem_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentPersonArgs = {
  _set?: Maybe<ContentPerson_Set_Input>;
  where: ContentPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentPerson_By_PkArgs = {
  _set?: Maybe<ContentPerson_Set_Input>;
  pk_columns: ContentPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentTypeArgs = {
  _set?: Maybe<ContentType_Set_Input>;
  where: ContentType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentType_By_PkArgs = {
  _set?: Maybe<ContentType_Set_Input>;
  pk_columns: ContentType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EmailArgs = {
  _inc?: Maybe<Email_Inc_Input>;
  _set?: Maybe<Email_Set_Input>;
  where: Email_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Email_By_PkArgs = {
  _inc?: Maybe<Email_Inc_Input>;
  _set?: Maybe<Email_Set_Input>;
  pk_columns: Email_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventArgs = {
  _inc?: Maybe<Event_Inc_Input>;
  _set?: Maybe<Event_Set_Input>;
  where: Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventParticipantStreamArgs = {
  _set?: Maybe<EventParticipantStream_Set_Input>;
  where: EventParticipantStream_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventParticipantStream_By_PkArgs = {
  _set?: Maybe<EventParticipantStream_Set_Input>;
  pk_columns: EventParticipantStream_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventPersonArgs = {
  _set?: Maybe<EventPerson_Set_Input>;
  where: EventPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventPersonRoleArgs = {
  _set?: Maybe<EventPersonRole_Set_Input>;
  where: EventPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventPersonRole_By_PkArgs = {
  _set?: Maybe<EventPersonRole_Set_Input>;
  pk_columns: EventPersonRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventPerson_By_PkArgs = {
  _set?: Maybe<EventPerson_Set_Input>;
  pk_columns: EventPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventRoomJoinRequestArgs = {
  _set?: Maybe<EventRoomJoinRequest_Set_Input>;
  where: EventRoomJoinRequest_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventRoomJoinRequest_By_PkArgs = {
  _set?: Maybe<EventRoomJoinRequest_Set_Input>;
  pk_columns: EventRoomJoinRequest_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventTagArgs = {
  _set?: Maybe<EventTag_Set_Input>;
  where: EventTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventTag_By_PkArgs = {
  _set?: Maybe<EventTag_Set_Input>;
  pk_columns: EventTag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventVonageSessionArgs = {
  _append?: Maybe<EventVonageSession_Append_Input>;
  _delete_at_path?: Maybe<EventVonageSession_Delete_At_Path_Input>;
  _delete_elem?: Maybe<EventVonageSession_Delete_Elem_Input>;
  _delete_key?: Maybe<EventVonageSession_Delete_Key_Input>;
  _prepend?: Maybe<EventVonageSession_Prepend_Input>;
  _set?: Maybe<EventVonageSession_Set_Input>;
  where: EventVonageSession_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventVonageSession_By_PkArgs = {
  _append?: Maybe<EventVonageSession_Append_Input>;
  _delete_at_path?: Maybe<EventVonageSession_Delete_At_Path_Input>;
  _delete_elem?: Maybe<EventVonageSession_Delete_Elem_Input>;
  _delete_key?: Maybe<EventVonageSession_Delete_Key_Input>;
  _prepend?: Maybe<EventVonageSession_Prepend_Input>;
  _set?: Maybe<EventVonageSession_Set_Input>;
  pk_columns: EventVonageSession_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Event_By_PkArgs = {
  _inc?: Maybe<Event_Inc_Input>;
  _set?: Maybe<Event_Set_Input>;
  pk_columns: Event_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ExecutedTransitionsArgs = {
  _set?: Maybe<ExecutedTransitions_Set_Input>;
  where: ExecutedTransitions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ExecutedTransitions_By_PkArgs = {
  _set?: Maybe<ExecutedTransitions_Set_Input>;
  pk_columns: ExecutedTransitions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_GroupArgs = {
  _set?: Maybe<Group_Set_Input>;
  where: Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_GroupAttendeeArgs = {
  _set?: Maybe<GroupAttendee_Set_Input>;
  where: GroupAttendee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_GroupAttendee_By_PkArgs = {
  _set?: Maybe<GroupAttendee_Set_Input>;
  pk_columns: GroupAttendee_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_GroupRoleArgs = {
  _set?: Maybe<GroupRole_Set_Input>;
  where: GroupRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_GroupRole_By_PkArgs = {
  _set?: Maybe<GroupRole_Set_Input>;
  pk_columns: GroupRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Group_By_PkArgs = {
  _set?: Maybe<Group_Set_Input>;
  pk_columns: Group_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_HallwayArgs = {
  _inc?: Maybe<Hallway_Inc_Input>;
  _set?: Maybe<Hallway_Set_Input>;
  where: Hallway_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Hallway_By_PkArgs = {
  _inc?: Maybe<Hallway_Inc_Input>;
  _set?: Maybe<Hallway_Set_Input>;
  pk_columns: Hallway_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_InputTypeArgs = {
  _set?: Maybe<InputType_Set_Input>;
  where: InputType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_InputType_By_PkArgs = {
  _set?: Maybe<InputType_Set_Input>;
  pk_columns: InputType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_InvitationArgs = {
  _set?: Maybe<Invitation_Set_Input>;
  where: Invitation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Invitation_By_PkArgs = {
  _set?: Maybe<Invitation_Set_Input>;
  pk_columns: Invitation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_JobStatusArgs = {
  _set?: Maybe<JobStatus_Set_Input>;
  where: JobStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_JobStatus_By_PkArgs = {
  _set?: Maybe<JobStatus_Set_Input>;
  pk_columns: JobStatus_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_MediaLiveChannelArgs = {
  _set?: Maybe<MediaLiveChannel_Set_Input>;
  where: MediaLiveChannel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_MediaLiveChannel_By_PkArgs = {
  _set?: Maybe<MediaLiveChannel_Set_Input>;
  pk_columns: MediaLiveChannel_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_OnlineStatusArgs = {
  _set?: Maybe<OnlineStatus_Set_Input>;
  where: OnlineStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_OnlineStatus_By_PkArgs = {
  _set?: Maybe<OnlineStatus_Set_Input>;
  pk_columns: OnlineStatus_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_OriginatingDataArgs = {
  _append?: Maybe<OriginatingData_Append_Input>;
  _delete_at_path?: Maybe<OriginatingData_Delete_At_Path_Input>;
  _delete_elem?: Maybe<OriginatingData_Delete_Elem_Input>;
  _delete_key?: Maybe<OriginatingData_Delete_Key_Input>;
  _prepend?: Maybe<OriginatingData_Prepend_Input>;
  _set?: Maybe<OriginatingData_Set_Input>;
  where: OriginatingData_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_OriginatingData_By_PkArgs = {
  _append?: Maybe<OriginatingData_Append_Input>;
  _delete_at_path?: Maybe<OriginatingData_Delete_At_Path_Input>;
  _delete_elem?: Maybe<OriginatingData_Delete_Elem_Input>;
  _delete_key?: Maybe<OriginatingData_Delete_Key_Input>;
  _prepend?: Maybe<OriginatingData_Prepend_Input>;
  _set?: Maybe<OriginatingData_Set_Input>;
  pk_columns: OriginatingData_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PermissionArgs = {
  _set?: Maybe<Permission_Set_Input>;
  where: Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permission_By_PkArgs = {
  _set?: Maybe<Permission_Set_Input>;
  pk_columns: Permission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RequiredContentItemArgs = {
  _inc?: Maybe<RequiredContentItem_Inc_Input>;
  _set?: Maybe<RequiredContentItem_Set_Input>;
  where: RequiredContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RequiredContentItem_By_PkArgs = {
  _inc?: Maybe<RequiredContentItem_Inc_Input>;
  _set?: Maybe<RequiredContentItem_Set_Input>;
  pk_columns: RequiredContentItem_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoleArgs = {
  _set?: Maybe<Role_Set_Input>;
  where: Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RolePermissionArgs = {
  _set?: Maybe<RolePermission_Set_Input>;
  where: RolePermission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RolePermission_By_PkArgs = {
  _set?: Maybe<RolePermission_Set_Input>;
  pk_columns: RolePermission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Role_By_PkArgs = {
  _set?: Maybe<Role_Set_Input>;
  pk_columns: Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomArgs = {
  _inc?: Maybe<Room_Inc_Input>;
  _set?: Maybe<Room_Set_Input>;
  where: Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomModeArgs = {
  _set?: Maybe<RoomMode_Set_Input>;
  where: RoomMode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomMode_By_PkArgs = {
  _set?: Maybe<RoomMode_Set_Input>;
  pk_columns: RoomMode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomParticipantArgs = {
  _set?: Maybe<RoomParticipant_Set_Input>;
  where: RoomParticipant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomParticipant_By_PkArgs = {
  _set?: Maybe<RoomParticipant_Set_Input>;
  pk_columns: RoomParticipant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPersonArgs = {
  _set?: Maybe<RoomPerson_Set_Input>;
  where: RoomPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPersonRoleArgs = {
  _set?: Maybe<RoomPersonRole_Set_Input>;
  where: RoomPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPersonRole_By_PkArgs = {
  _set?: Maybe<RoomPersonRole_Set_Input>;
  pk_columns: RoomPersonRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPerson_By_PkArgs = {
  _set?: Maybe<RoomPerson_Set_Input>;
  pk_columns: RoomPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPrivacyArgs = {
  _set?: Maybe<RoomPrivacy_Set_Input>;
  where: RoomPrivacy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPrivacy_By_PkArgs = {
  _set?: Maybe<RoomPrivacy_Set_Input>;
  pk_columns: RoomPrivacy_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_By_PkArgs = {
  _inc?: Maybe<Room_Inc_Input>;
  _set?: Maybe<Room_Set_Input>;
  pk_columns: Room_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_TagArgs = {
  _set?: Maybe<Tag_Set_Input>;
  where: Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tag_By_PkArgs = {
  _set?: Maybe<Tag_Set_Input>;
  pk_columns: Tag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_TranscriptionJobArgs = {
  _set?: Maybe<TranscriptionJob_Set_Input>;
  where: TranscriptionJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_TranscriptionJob_By_PkArgs = {
  _set?: Maybe<TranscriptionJob_Set_Input>;
  pk_columns: TranscriptionJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_TransitionsArgs = {
  _set?: Maybe<Transitions_Set_Input>;
  where: Transitions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Transitions_By_PkArgs = {
  _set?: Maybe<Transitions_Set_Input>;
  pk_columns: Transitions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_UploaderArgs = {
  _inc?: Maybe<Uploader_Inc_Input>;
  _set?: Maybe<Uploader_Set_Input>;
  where: Uploader_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Uploader_By_PkArgs = {
  _inc?: Maybe<Uploader_Inc_Input>;
  _set?: Maybe<Uploader_Set_Input>;
  pk_columns: Uploader_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_UserArgs = {
  _set?: Maybe<User_Set_Input>;
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_By_PkArgs = {
  _set?: Maybe<User_Set_Input>;
  pk_columns: User_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_VideoRenderJobArgs = {
  _append?: Maybe<VideoRenderJob_Append_Input>;
  _delete_at_path?: Maybe<VideoRenderJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<VideoRenderJob_Delete_Elem_Input>;
  _delete_key?: Maybe<VideoRenderJob_Delete_Key_Input>;
  _inc?: Maybe<VideoRenderJob_Inc_Input>;
  _prepend?: Maybe<VideoRenderJob_Prepend_Input>;
  _set?: Maybe<VideoRenderJob_Set_Input>;
  where: VideoRenderJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_VideoRenderJob_By_PkArgs = {
  _append?: Maybe<VideoRenderJob_Append_Input>;
  _delete_at_path?: Maybe<VideoRenderJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<VideoRenderJob_Delete_Elem_Input>;
  _delete_key?: Maybe<VideoRenderJob_Delete_Key_Input>;
  _inc?: Maybe<VideoRenderJob_Inc_Input>;
  _prepend?: Maybe<VideoRenderJob_Prepend_Input>;
  _set?: Maybe<VideoRenderJob_Set_Input>;
  pk_columns: VideoRenderJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ChatArgs = {
  _set?: Maybe<Chat_Chat_Set_Input>;
  where: Chat_Chat_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Chat_By_PkArgs = {
  _set?: Maybe<Chat_Chat_Set_Input>;
  pk_columns: Chat_Chat_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagArgs = {
  _inc?: Maybe<Chat_Flag_Inc_Input>;
  _set?: Maybe<Chat_Flag_Set_Input>;
  where: Chat_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagTypeArgs = {
  _set?: Maybe<Chat_FlagType_Set_Input>;
  where: Chat_FlagType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagType_By_PkArgs = {
  _set?: Maybe<Chat_FlagType_Set_Input>;
  pk_columns: Chat_FlagType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Flag_By_PkArgs = {
  _inc?: Maybe<Chat_Flag_Inc_Input>;
  _set?: Maybe<Chat_Flag_Set_Input>;
  pk_columns: Chat_Flag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageArgs = {
  _append?: Maybe<Chat_Message_Append_Input>;
  _delete_at_path?: Maybe<Chat_Message_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Message_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Message_Delete_Key_Input>;
  _inc?: Maybe<Chat_Message_Inc_Input>;
  _prepend?: Maybe<Chat_Message_Prepend_Input>;
  _set?: Maybe<Chat_Message_Set_Input>;
  where: Chat_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageTypeArgs = {
  _set?: Maybe<Chat_MessageType_Set_Input>;
  where: Chat_MessageType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageType_By_PkArgs = {
  _set?: Maybe<Chat_MessageType_Set_Input>;
  pk_columns: Chat_MessageType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Message_By_PkArgs = {
  _append?: Maybe<Chat_Message_Append_Input>;
  _delete_at_path?: Maybe<Chat_Message_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Message_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Message_Delete_Key_Input>;
  _inc?: Maybe<Chat_Message_Inc_Input>;
  _prepend?: Maybe<Chat_Message_Prepend_Input>;
  _set?: Maybe<Chat_Message_Set_Input>;
  pk_columns: Chat_Message_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_PinArgs = {
  _set?: Maybe<Chat_Pin_Set_Input>;
  where: Chat_Pin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Pin_By_PkArgs = {
  _set?: Maybe<Chat_Pin_Set_Input>;
  pk_columns: Chat_Pin_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionArgs = {
  _append?: Maybe<Chat_Reaction_Append_Input>;
  _delete_at_path?: Maybe<Chat_Reaction_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Reaction_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Reaction_Delete_Key_Input>;
  _inc?: Maybe<Chat_Reaction_Inc_Input>;
  _prepend?: Maybe<Chat_Reaction_Prepend_Input>;
  _set?: Maybe<Chat_Reaction_Set_Input>;
  where: Chat_Reaction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionTypeArgs = {
  _set?: Maybe<Chat_ReactionType_Set_Input>;
  where: Chat_ReactionType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionType_By_PkArgs = {
  _set?: Maybe<Chat_ReactionType_Set_Input>;
  pk_columns: Chat_ReactionType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Reaction_By_PkArgs = {
  _append?: Maybe<Chat_Reaction_Append_Input>;
  _delete_at_path?: Maybe<Chat_Reaction_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Reaction_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Reaction_Delete_Key_Input>;
  _inc?: Maybe<Chat_Reaction_Inc_Input>;
  _prepend?: Maybe<Chat_Reaction_Prepend_Input>;
  _set?: Maybe<Chat_Reaction_Set_Input>;
  pk_columns: Chat_Reaction_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReadUpToIndexArgs = {
  _inc?: Maybe<Chat_ReadUpToIndex_Inc_Input>;
  _set?: Maybe<Chat_ReadUpToIndex_Set_Input>;
  where: Chat_ReadUpToIndex_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReadUpToIndex_By_PkArgs = {
  _inc?: Maybe<Chat_ReadUpToIndex_Inc_Input>;
  _set?: Maybe<Chat_ReadUpToIndex_Set_Input>;
  pk_columns: Chat_ReadUpToIndex_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_SubscriptionArgs = {
  _set?: Maybe<Chat_Subscription_Set_Input>;
  where: Chat_Subscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Subscription_By_PkArgs = {
  _set?: Maybe<Chat_Subscription_Set_Input>;
  pk_columns: Chat_Subscription_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_SubscriptionsWithUnnotifiedMessagesArgs = {
  _set?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Set_Input>;
  where: Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_TyperArgs = {
  _set?: Maybe<Chat_Typer_Set_Input>;
  where: Chat_Typer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Typer_By_PkArgs = {
  _set?: Maybe<Chat_Typer_Set_Input>;
  pk_columns: Chat_Typer_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_InvitationEmailJobArgs = {
  _append?: Maybe<Job_Queues_InvitationEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_InvitationEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_InvitationEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_InvitationEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_InvitationEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_InvitationEmailJob_Set_Input>;
  where: Job_Queues_InvitationEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_InvitationEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_InvitationEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_InvitationEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_InvitationEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_InvitationEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_InvitationEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_InvitationEmailJob_Set_Input>;
  pk_columns: Job_Queues_InvitationEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_MediaPackageHarvestJobArgs = {
  _set?: Maybe<Job_Queues_MediaPackageHarvestJob_Set_Input>;
  where: Job_Queues_MediaPackageHarvestJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_MediaPackageHarvestJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_MediaPackageHarvestJob_Set_Input>;
  pk_columns: Job_Queues_MediaPackageHarvestJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_PublishVideoJobArgs = {
  _set?: Maybe<Job_Queues_PublishVideoJob_Set_Input>;
  where: Job_Queues_PublishVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_PublishVideoJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_PublishVideoJob_Set_Input>;
  pk_columns: Job_Queues_PublishVideoJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_SubmissionRequestEmailJobArgs = {
  _set?: Maybe<Job_Queues_SubmissionRequestEmailJob_Set_Input>;
  where: Job_Queues_SubmissionRequestEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_SubmissionRequestEmailJob_Set_Input>;
  pk_columns: Job_Queues_SubmissionRequestEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShufflePeriodArgs = {
  _inc?: Maybe<Room_ShufflePeriod_Inc_Input>;
  _set?: Maybe<Room_ShufflePeriod_Set_Input>;
  where: Room_ShufflePeriod_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShufflePeriod_By_PkArgs = {
  _inc?: Maybe<Room_ShufflePeriod_Inc_Input>;
  _set?: Maybe<Room_ShufflePeriod_Set_Input>;
  pk_columns: Room_ShufflePeriod_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleQueueEntryArgs = {
  _inc?: Maybe<Room_ShuffleQueueEntry_Inc_Input>;
  _set?: Maybe<Room_ShuffleQueueEntry_Set_Input>;
  where: Room_ShuffleQueueEntry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleQueueEntry_By_PkArgs = {
  _inc?: Maybe<Room_ShuffleQueueEntry_Inc_Input>;
  _set?: Maybe<Room_ShuffleQueueEntry_Set_Input>;
  pk_columns: Room_ShuffleQueueEntry_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleRoomArgs = {
  _inc?: Maybe<Room_ShuffleRoom_Inc_Input>;
  _set?: Maybe<Room_ShuffleRoom_Set_Input>;
  where: Room_ShuffleRoom_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleRoom_By_PkArgs = {
  _inc?: Maybe<Room_ShuffleRoom_Inc_Input>;
  _set?: Maybe<Room_ShuffleRoom_Set_Input>;
  pk_columns: Room_ShuffleRoom_Pk_Columns_Input;
};

/** column ordering options */
export enum Order_By {
  /** in the ascending order, nulls last */
  Asc = 'asc',
  /** in the ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in the ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in the descending order, nulls first */
  Desc = 'desc',
  /** in the descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in the descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** query root */
export type Query_Root = {
  readonly __typename?: 'query_root';
  /** fetch data from the table: "Attendee" */
  readonly Attendee: ReadonlyArray<Attendee>;
  /** fetch data from the table: "AttendeeProfile" */
  readonly AttendeeProfile: ReadonlyArray<AttendeeProfile>;
  /** fetch aggregated fields from the table: "AttendeeProfile" */
  readonly AttendeeProfile_aggregate: AttendeeProfile_Aggregate;
  /** fetch data from the table: "AttendeeProfile" using primary key columns */
  readonly AttendeeProfile_by_pk?: Maybe<AttendeeProfile>;
  /** fetch aggregated fields from the table: "Attendee" */
  readonly Attendee_aggregate: Attendee_Aggregate;
  /** fetch data from the table: "Attendee" using primary key columns */
  readonly Attendee_by_pk?: Maybe<Attendee>;
  /** fetch data from the table: "Broadcast" */
  readonly Broadcast: ReadonlyArray<Broadcast>;
  /** fetch data from the table: "BroadcastContentItem" */
  readonly BroadcastContentItem: ReadonlyArray<BroadcastContentItem>;
  /** fetch aggregated fields from the table: "BroadcastContentItem" */
  readonly BroadcastContentItem_aggregate: BroadcastContentItem_Aggregate;
  /** fetch data from the table: "BroadcastContentItem" using primary key columns */
  readonly BroadcastContentItem_by_pk?: Maybe<BroadcastContentItem>;
  /** fetch aggregated fields from the table: "Broadcast" */
  readonly Broadcast_aggregate: Broadcast_Aggregate;
  /** fetch data from the table: "Broadcast" using primary key columns */
  readonly Broadcast_by_pk?: Maybe<Broadcast>;
  /** fetch data from the table: "Conference" */
  readonly Conference: ReadonlyArray<Conference>;
  /** fetch data from the table: "ConferenceConfiguration" */
  readonly ConferenceConfiguration: ReadonlyArray<ConferenceConfiguration>;
  /** fetch aggregated fields from the table: "ConferenceConfiguration" */
  readonly ConferenceConfiguration_aggregate: ConferenceConfiguration_Aggregate;
  /** fetch data from the table: "ConferenceConfiguration" using primary key columns */
  readonly ConferenceConfiguration_by_pk?: Maybe<ConferenceConfiguration>;
  /** fetch data from the table: "ConferenceDemoCode" */
  readonly ConferenceDemoCode: ReadonlyArray<ConferenceDemoCode>;
  /** fetch aggregated fields from the table: "ConferenceDemoCode" */
  readonly ConferenceDemoCode_aggregate: ConferenceDemoCode_Aggregate;
  /** fetch data from the table: "ConferenceDemoCode" using primary key columns */
  readonly ConferenceDemoCode_by_pk?: Maybe<ConferenceDemoCode>;
  /** fetch data from the table: "ConferencePrepareJob" */
  readonly ConferencePrepareJob: ReadonlyArray<ConferencePrepareJob>;
  /** fetch aggregated fields from the table: "ConferencePrepareJob" */
  readonly ConferencePrepareJob_aggregate: ConferencePrepareJob_Aggregate;
  /** fetch data from the table: "ConferencePrepareJob" using primary key columns */
  readonly ConferencePrepareJob_by_pk?: Maybe<ConferencePrepareJob>;
  /** fetch aggregated fields from the table: "Conference" */
  readonly Conference_aggregate: Conference_Aggregate;
  /** fetch data from the table: "Conference" using primary key columns */
  readonly Conference_by_pk?: Maybe<Conference>;
  /** fetch data from the table: "ContentGroup" */
  readonly ContentGroup: ReadonlyArray<ContentGroup>;
  /** fetch data from the table: "ContentGroupHallway" */
  readonly ContentGroupHallway: ReadonlyArray<ContentGroupHallway>;
  /** fetch aggregated fields from the table: "ContentGroupHallway" */
  readonly ContentGroupHallway_aggregate: ContentGroupHallway_Aggregate;
  /** fetch data from the table: "ContentGroupHallway" using primary key columns */
  readonly ContentGroupHallway_by_pk?: Maybe<ContentGroupHallway>;
  /** fetch data from the table: "ContentGroupPerson" */
  readonly ContentGroupPerson: ReadonlyArray<ContentGroupPerson>;
  /** fetch aggregated fields from the table: "ContentGroupPerson" */
  readonly ContentGroupPerson_aggregate: ContentGroupPerson_Aggregate;
  /** fetch data from the table: "ContentGroupPerson" using primary key columns */
  readonly ContentGroupPerson_by_pk?: Maybe<ContentGroupPerson>;
  /** fetch data from the table: "ContentGroupTag" */
  readonly ContentGroupTag: ReadonlyArray<ContentGroupTag>;
  /** fetch aggregated fields from the table: "ContentGroupTag" */
  readonly ContentGroupTag_aggregate: ContentGroupTag_Aggregate;
  /** fetch data from the table: "ContentGroupTag" using primary key columns */
  readonly ContentGroupTag_by_pk?: Maybe<ContentGroupTag>;
  /** fetch data from the table: "ContentGroupType" */
  readonly ContentGroupType: ReadonlyArray<ContentGroupType>;
  /** fetch aggregated fields from the table: "ContentGroupType" */
  readonly ContentGroupType_aggregate: ContentGroupType_Aggregate;
  /** fetch data from the table: "ContentGroupType" using primary key columns */
  readonly ContentGroupType_by_pk?: Maybe<ContentGroupType>;
  /** fetch aggregated fields from the table: "ContentGroup" */
  readonly ContentGroup_aggregate: ContentGroup_Aggregate;
  /** fetch data from the table: "ContentGroup" using primary key columns */
  readonly ContentGroup_by_pk?: Maybe<ContentGroup>;
  /** fetch data from the table: "ContentItem" */
  readonly ContentItem: ReadonlyArray<ContentItem>;
  /** fetch aggregated fields from the table: "ContentItem" */
  readonly ContentItem_aggregate: ContentItem_Aggregate;
  /** fetch data from the table: "ContentItem" using primary key columns */
  readonly ContentItem_by_pk?: Maybe<ContentItem>;
  /** fetch data from the table: "ContentPerson" */
  readonly ContentPerson: ReadonlyArray<ContentPerson>;
  /** fetch aggregated fields from the table: "ContentPerson" */
  readonly ContentPerson_aggregate: ContentPerson_Aggregate;
  /** fetch data from the table: "ContentPerson" using primary key columns */
  readonly ContentPerson_by_pk?: Maybe<ContentPerson>;
  /** fetch data from the table: "ContentType" */
  readonly ContentType: ReadonlyArray<ContentType>;
  /** fetch aggregated fields from the table: "ContentType" */
  readonly ContentType_aggregate: ContentType_Aggregate;
  /** fetch data from the table: "ContentType" using primary key columns */
  readonly ContentType_by_pk?: Maybe<ContentType>;
  /** fetch data from the table: "Email" */
  readonly Email: ReadonlyArray<Email>;
  /** fetch aggregated fields from the table: "Email" */
  readonly Email_aggregate: Email_Aggregate;
  /** fetch data from the table: "Email" using primary key columns */
  readonly Email_by_pk?: Maybe<Email>;
  /** fetch data from the table: "Event" */
  readonly Event: ReadonlyArray<Event>;
  /** fetch data from the table: "EventParticipantStream" */
  readonly EventParticipantStream: ReadonlyArray<EventParticipantStream>;
  /** fetch aggregated fields from the table: "EventParticipantStream" */
  readonly EventParticipantStream_aggregate: EventParticipantStream_Aggregate;
  /** fetch data from the table: "EventParticipantStream" using primary key columns */
  readonly EventParticipantStream_by_pk?: Maybe<EventParticipantStream>;
  /** fetch data from the table: "EventPerson" */
  readonly EventPerson: ReadonlyArray<EventPerson>;
  /** fetch data from the table: "EventPersonRole" */
  readonly EventPersonRole: ReadonlyArray<EventPersonRole>;
  /** fetch aggregated fields from the table: "EventPersonRole" */
  readonly EventPersonRole_aggregate: EventPersonRole_Aggregate;
  /** fetch data from the table: "EventPersonRole" using primary key columns */
  readonly EventPersonRole_by_pk?: Maybe<EventPersonRole>;
  /** fetch aggregated fields from the table: "EventPerson" */
  readonly EventPerson_aggregate: EventPerson_Aggregate;
  /** fetch data from the table: "EventPerson" using primary key columns */
  readonly EventPerson_by_pk?: Maybe<EventPerson>;
  /** fetch data from the table: "EventRoomJoinRequest" */
  readonly EventRoomJoinRequest: ReadonlyArray<EventRoomJoinRequest>;
  /** fetch aggregated fields from the table: "EventRoomJoinRequest" */
  readonly EventRoomJoinRequest_aggregate: EventRoomJoinRequest_Aggregate;
  /** fetch data from the table: "EventRoomJoinRequest" using primary key columns */
  readonly EventRoomJoinRequest_by_pk?: Maybe<EventRoomJoinRequest>;
  /** fetch data from the table: "EventTag" */
  readonly EventTag: ReadonlyArray<EventTag>;
  /** fetch aggregated fields from the table: "EventTag" */
  readonly EventTag_aggregate: EventTag_Aggregate;
  /** fetch data from the table: "EventTag" using primary key columns */
  readonly EventTag_by_pk?: Maybe<EventTag>;
  /** fetch data from the table: "EventVonageSession" */
  readonly EventVonageSession: ReadonlyArray<EventVonageSession>;
  /** fetch aggregated fields from the table: "EventVonageSession" */
  readonly EventVonageSession_aggregate: EventVonageSession_Aggregate;
  /** fetch data from the table: "EventVonageSession" using primary key columns */
  readonly EventVonageSession_by_pk?: Maybe<EventVonageSession>;
  /** fetch aggregated fields from the table: "Event" */
  readonly Event_aggregate: Event_Aggregate;
  /** fetch data from the table: "Event" using primary key columns */
  readonly Event_by_pk?: Maybe<Event>;
  /** fetch data from the table: "ExecutedTransitions" */
  readonly ExecutedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** fetch aggregated fields from the table: "ExecutedTransitions" */
  readonly ExecutedTransitions_aggregate: ExecutedTransitions_Aggregate;
  /** fetch data from the table: "ExecutedTransitions" using primary key columns */
  readonly ExecutedTransitions_by_pk?: Maybe<ExecutedTransitions>;
  /** fetch data from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission: ReadonlyArray<FlatUnauthPermission>;
  /** fetch aggregated fields from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission_aggregate: FlatUnauthPermission_Aggregate;
  /** fetch data from the table: "FlatUserPermission" */
  readonly FlatUserPermission: ReadonlyArray<FlatUserPermission>;
  /** fetch aggregated fields from the table: "FlatUserPermission" */
  readonly FlatUserPermission_aggregate: FlatUserPermission_Aggregate;
  /** fetch data from the table: "Group" */
  readonly Group: ReadonlyArray<Group>;
  /** fetch data from the table: "GroupAttendee" */
  readonly GroupAttendee: ReadonlyArray<GroupAttendee>;
  /** fetch aggregated fields from the table: "GroupAttendee" */
  readonly GroupAttendee_aggregate: GroupAttendee_Aggregate;
  /** fetch data from the table: "GroupAttendee" using primary key columns */
  readonly GroupAttendee_by_pk?: Maybe<GroupAttendee>;
  /** fetch data from the table: "GroupRole" */
  readonly GroupRole: ReadonlyArray<GroupRole>;
  /** fetch aggregated fields from the table: "GroupRole" */
  readonly GroupRole_aggregate: GroupRole_Aggregate;
  /** fetch data from the table: "GroupRole" using primary key columns */
  readonly GroupRole_by_pk?: Maybe<GroupRole>;
  /** fetch aggregated fields from the table: "Group" */
  readonly Group_aggregate: Group_Aggregate;
  /** fetch data from the table: "Group" using primary key columns */
  readonly Group_by_pk?: Maybe<Group>;
  /** fetch data from the table: "Hallway" */
  readonly Hallway: ReadonlyArray<Hallway>;
  /** fetch aggregated fields from the table: "Hallway" */
  readonly Hallway_aggregate: Hallway_Aggregate;
  /** fetch data from the table: "Hallway" using primary key columns */
  readonly Hallway_by_pk?: Maybe<Hallway>;
  /** fetch data from the table: "InputType" */
  readonly InputType: ReadonlyArray<InputType>;
  /** fetch aggregated fields from the table: "InputType" */
  readonly InputType_aggregate: InputType_Aggregate;
  /** fetch data from the table: "InputType" using primary key columns */
  readonly InputType_by_pk?: Maybe<InputType>;
  /** fetch data from the table: "Invitation" */
  readonly Invitation: ReadonlyArray<Invitation>;
  /** fetch aggregated fields from the table: "Invitation" */
  readonly Invitation_aggregate: Invitation_Aggregate;
  /** fetch data from the table: "Invitation" using primary key columns */
  readonly Invitation_by_pk?: Maybe<Invitation>;
  /** fetch data from the table: "JobStatus" */
  readonly JobStatus: ReadonlyArray<JobStatus>;
  /** fetch aggregated fields from the table: "JobStatus" */
  readonly JobStatus_aggregate: JobStatus_Aggregate;
  /** fetch data from the table: "JobStatus" using primary key columns */
  readonly JobStatus_by_pk?: Maybe<JobStatus>;
  /** fetch data from the table: "MediaLiveChannel" */
  readonly MediaLiveChannel: ReadonlyArray<MediaLiveChannel>;
  /** fetch aggregated fields from the table: "MediaLiveChannel" */
  readonly MediaLiveChannel_aggregate: MediaLiveChannel_Aggregate;
  /** fetch data from the table: "MediaLiveChannel" using primary key columns */
  readonly MediaLiveChannel_by_pk?: Maybe<MediaLiveChannel>;
  /** fetch data from the table: "OnlineStatus" */
  readonly OnlineStatus: ReadonlyArray<OnlineStatus>;
  /** fetch aggregated fields from the table: "OnlineStatus" */
  readonly OnlineStatus_aggregate: OnlineStatus_Aggregate;
  /** fetch data from the table: "OnlineStatus" using primary key columns */
  readonly OnlineStatus_by_pk?: Maybe<OnlineStatus>;
  /** fetch data from the table: "OriginatingData" */
  readonly OriginatingData: ReadonlyArray<OriginatingData>;
  /** fetch aggregated fields from the table: "OriginatingData" */
  readonly OriginatingData_aggregate: OriginatingData_Aggregate;
  /** fetch data from the table: "OriginatingData" using primary key columns */
  readonly OriginatingData_by_pk?: Maybe<OriginatingData>;
  /** fetch data from the table: "Permission" */
  readonly Permission: ReadonlyArray<Permission>;
  /** fetch aggregated fields from the table: "Permission" */
  readonly Permission_aggregate: Permission_Aggregate;
  /** fetch data from the table: "Permission" using primary key columns */
  readonly Permission_by_pk?: Maybe<Permission>;
  /** fetch data from the table: "RequiredContentItem" */
  readonly RequiredContentItem: ReadonlyArray<RequiredContentItem>;
  /** fetch aggregated fields from the table: "RequiredContentItem" */
  readonly RequiredContentItem_aggregate: RequiredContentItem_Aggregate;
  /** fetch data from the table: "RequiredContentItem" using primary key columns */
  readonly RequiredContentItem_by_pk?: Maybe<RequiredContentItem>;
  /** fetch data from the table: "Role" */
  readonly Role: ReadonlyArray<Role>;
  /** fetch data from the table: "RolePermission" */
  readonly RolePermission: ReadonlyArray<RolePermission>;
  /** fetch aggregated fields from the table: "RolePermission" */
  readonly RolePermission_aggregate: RolePermission_Aggregate;
  /** fetch data from the table: "RolePermission" using primary key columns */
  readonly RolePermission_by_pk?: Maybe<RolePermission>;
  /** fetch aggregated fields from the table: "Role" */
  readonly Role_aggregate: Role_Aggregate;
  /** fetch data from the table: "Role" using primary key columns */
  readonly Role_by_pk?: Maybe<Role>;
  /** fetch data from the table: "Room" */
  readonly Room: ReadonlyArray<Room>;
  /** fetch data from the table: "RoomMode" */
  readonly RoomMode: ReadonlyArray<RoomMode>;
  /** fetch aggregated fields from the table: "RoomMode" */
  readonly RoomMode_aggregate: RoomMode_Aggregate;
  /** fetch data from the table: "RoomMode" using primary key columns */
  readonly RoomMode_by_pk?: Maybe<RoomMode>;
  /** fetch data from the table: "RoomParticipant" */
  readonly RoomParticipant: ReadonlyArray<RoomParticipant>;
  /** fetch aggregated fields from the table: "RoomParticipant" */
  readonly RoomParticipant_aggregate: RoomParticipant_Aggregate;
  /** fetch data from the table: "RoomParticipant" using primary key columns */
  readonly RoomParticipant_by_pk?: Maybe<RoomParticipant>;
  /** fetch data from the table: "RoomPerson" */
  readonly RoomPerson: ReadonlyArray<RoomPerson>;
  /** fetch data from the table: "RoomPersonRole" */
  readonly RoomPersonRole: ReadonlyArray<RoomPersonRole>;
  /** fetch aggregated fields from the table: "RoomPersonRole" */
  readonly RoomPersonRole_aggregate: RoomPersonRole_Aggregate;
  /** fetch data from the table: "RoomPersonRole" using primary key columns */
  readonly RoomPersonRole_by_pk?: Maybe<RoomPersonRole>;
  /** fetch aggregated fields from the table: "RoomPerson" */
  readonly RoomPerson_aggregate: RoomPerson_Aggregate;
  /** fetch data from the table: "RoomPerson" using primary key columns */
  readonly RoomPerson_by_pk?: Maybe<RoomPerson>;
  /** fetch data from the table: "RoomPrivacy" */
  readonly RoomPrivacy: ReadonlyArray<RoomPrivacy>;
  /** fetch aggregated fields from the table: "RoomPrivacy" */
  readonly RoomPrivacy_aggregate: RoomPrivacy_Aggregate;
  /** fetch data from the table: "RoomPrivacy" using primary key columns */
  readonly RoomPrivacy_by_pk?: Maybe<RoomPrivacy>;
  /** fetch aggregated fields from the table: "Room" */
  readonly Room_aggregate: Room_Aggregate;
  /** fetch data from the table: "Room" using primary key columns */
  readonly Room_by_pk?: Maybe<Room>;
  /** fetch data from the table: "Tag" */
  readonly Tag: ReadonlyArray<Tag>;
  /** fetch aggregated fields from the table: "Tag" */
  readonly Tag_aggregate: Tag_Aggregate;
  /** fetch data from the table: "Tag" using primary key columns */
  readonly Tag_by_pk?: Maybe<Tag>;
  /** fetch data from the table: "TranscriptionJob" */
  readonly TranscriptionJob: ReadonlyArray<TranscriptionJob>;
  /** fetch aggregated fields from the table: "TranscriptionJob" */
  readonly TranscriptionJob_aggregate: TranscriptionJob_Aggregate;
  /** fetch data from the table: "TranscriptionJob" using primary key columns */
  readonly TranscriptionJob_by_pk?: Maybe<TranscriptionJob>;
  /** fetch data from the table: "Transitions" */
  readonly Transitions: ReadonlyArray<Transitions>;
  /** fetch aggregated fields from the table: "Transitions" */
  readonly Transitions_aggregate: Transitions_Aggregate;
  /** fetch data from the table: "Transitions" using primary key columns */
  readonly Transitions_by_pk?: Maybe<Transitions>;
  /** fetch data from the table: "Uploader" */
  readonly Uploader: ReadonlyArray<Uploader>;
  /** fetch aggregated fields from the table: "Uploader" */
  readonly Uploader_aggregate: Uploader_Aggregate;
  /** fetch data from the table: "Uploader" using primary key columns */
  readonly Uploader_by_pk?: Maybe<Uploader>;
  /** fetch data from the table: "User" */
  readonly User: ReadonlyArray<User>;
  /** fetch aggregated fields from the table: "User" */
  readonly User_aggregate: User_Aggregate;
  /** fetch data from the table: "User" using primary key columns */
  readonly User_by_pk?: Maybe<User>;
  /** fetch data from the table: "VideoRenderJob" */
  readonly VideoRenderJob: ReadonlyArray<VideoRenderJob>;
  /** fetch aggregated fields from the table: "VideoRenderJob" */
  readonly VideoRenderJob_aggregate: VideoRenderJob_Aggregate;
  /** fetch data from the table: "VideoRenderJob" using primary key columns */
  readonly VideoRenderJob_by_pk?: Maybe<VideoRenderJob>;
  /** fetch data from the table: "chat.Chat" */
  readonly chat_Chat: ReadonlyArray<Chat_Chat>;
  /** fetch aggregated fields from the table: "chat.Chat" */
  readonly chat_Chat_aggregate: Chat_Chat_Aggregate;
  /** fetch data from the table: "chat.Chat" using primary key columns */
  readonly chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** fetch data from the table: "chat.Flag" */
  readonly chat_Flag: ReadonlyArray<Chat_Flag>;
  /** fetch data from the table: "chat.FlagType" */
  readonly chat_FlagType: ReadonlyArray<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.FlagType" */
  readonly chat_FlagType_aggregate: Chat_FlagType_Aggregate;
  /** fetch data from the table: "chat.FlagType" using primary key columns */
  readonly chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.Flag" */
  readonly chat_Flag_aggregate: Chat_Flag_Aggregate;
  /** fetch data from the table: "chat.Flag" using primary key columns */
  readonly chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** fetch data from the table: "chat.Message" */
  readonly chat_Message: ReadonlyArray<Chat_Message>;
  /** fetch data from the table: "chat.MessageType" */
  readonly chat_MessageType: ReadonlyArray<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.MessageType" */
  readonly chat_MessageType_aggregate: Chat_MessageType_Aggregate;
  /** fetch data from the table: "chat.MessageType" using primary key columns */
  readonly chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.Message" */
  readonly chat_Message_aggregate: Chat_Message_Aggregate;
  /** fetch data from the table: "chat.Message" using primary key columns */
  readonly chat_Message_by_pk?: Maybe<Chat_Message>;
  /** fetch data from the table: "chat.Pin" */
  readonly chat_Pin: ReadonlyArray<Chat_Pin>;
  /** fetch aggregated fields from the table: "chat.Pin" */
  readonly chat_Pin_aggregate: Chat_Pin_Aggregate;
  /** fetch data from the table: "chat.Pin" using primary key columns */
  readonly chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** fetch data from the table: "chat.Reaction" */
  readonly chat_Reaction: ReadonlyArray<Chat_Reaction>;
  /** fetch data from the table: "chat.ReactionType" */
  readonly chat_ReactionType: ReadonlyArray<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.ReactionType" */
  readonly chat_ReactionType_aggregate: Chat_ReactionType_Aggregate;
  /** fetch data from the table: "chat.ReactionType" using primary key columns */
  readonly chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.Reaction" */
  readonly chat_Reaction_aggregate: Chat_Reaction_Aggregate;
  /** fetch data from the table: "chat.Reaction" using primary key columns */
  readonly chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** fetch data from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex: ReadonlyArray<Chat_ReadUpToIndex>;
  /** fetch aggregated fields from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex_aggregate: Chat_ReadUpToIndex_Aggregate;
  /** fetch data from the table: "chat.ReadUpToIndex" using primary key columns */
  readonly chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** fetch data from the table: "chat.Subscription" */
  readonly chat_Subscription: ReadonlyArray<Chat_Subscription>;
  /** fetch aggregated fields from the table: "chat.Subscription" */
  readonly chat_Subscription_aggregate: Chat_Subscription_Aggregate;
  /** fetch data from the table: "chat.Subscription" using primary key columns */
  readonly chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** fetch data from the table: "chat.SubscriptionsWithUnnotifiedMessages" */
  readonly chat_SubscriptionsWithUnnotifiedMessages: ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages>;
  /** fetch aggregated fields from the table: "chat.SubscriptionsWithUnnotifiedMessages" */
  readonly chat_SubscriptionsWithUnnotifiedMessages_aggregate: Chat_SubscriptionsWithUnnotifiedMessages_Aggregate;
  /** fetch data from the table: "chat.Typer" */
  readonly chat_Typer: ReadonlyArray<Chat_Typer>;
  /** fetch aggregated fields from the table: "chat.Typer" */
  readonly chat_Typer_aggregate: Chat_Typer_Aggregate;
  /** fetch data from the table: "chat.Typer" using primary key columns */
  readonly chat_Typer_by_pk?: Maybe<Chat_Typer>;
  /** perform the action: "echo" */
  readonly echo?: Maybe<EchoOutput>;
  /** perform the action: "getContentItem" */
  readonly getContentItem?: Maybe<ReadonlyArray<Maybe<GetContentItemOutput>>>;
  /** perform the action: "getUploadAgreement" */
  readonly getUploadAgreement?: Maybe<GetUploadAgreementOutput>;
  /** fetch data from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob: ReadonlyArray<Job_Queues_InvitationEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob_aggregate: Job_Queues_InvitationEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.InvitationEmailJob" using primary key columns */
  readonly job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
  /** fetch aggregated fields from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob_aggregate: Job_Queues_MediaPackageHarvestJob_Aggregate;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" using primary key columns */
  readonly job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** fetch data from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob: ReadonlyArray<Job_Queues_PublishVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob_aggregate: Job_Queues_PublishVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.PublishVideoJob" using primary key columns */
  readonly job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob_aggregate: Job_Queues_SubmissionRequestEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" using primary key columns */
  readonly job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** perform the action: "protectedEcho" */
  readonly protectedEcho?: Maybe<ProtectedEchoOutput>;
  /** fetch data from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod: ReadonlyArray<Room_ShufflePeriod>;
  /** fetch aggregated fields from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod_aggregate: Room_ShufflePeriod_Aggregate;
  /** fetch data from the table: "room.ShufflePeriod" using primary key columns */
  readonly room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** fetch data from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** fetch aggregated fields from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry_aggregate: Room_ShuffleQueueEntry_Aggregate;
  /** fetch data from the table: "room.ShuffleQueueEntry" using primary key columns */
  readonly room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** fetch data from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom: ReadonlyArray<Room_ShuffleRoom>;
  /** fetch aggregated fields from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom_aggregate: Room_ShuffleRoom_Aggregate;
  /** fetch data from the table: "room.ShuffleRoom" using primary key columns */
  readonly room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
};


/** query root */
export type Query_RootAttendeeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeProfileArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfile_Order_By>>;
  where?: Maybe<AttendeeProfile_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeProfile_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfile_Order_By>>;
  where?: Maybe<AttendeeProfile_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeProfile_By_PkArgs = {
  attendeeId: Scalars['uuid'];
};


/** query root */
export type Query_RootAttendee_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** query root */
export type Query_RootAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootBroadcastArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** query root */
export type Query_RootBroadcastContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootBroadcastContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootBroadcastContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootBroadcast_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** query root */
export type Query_RootBroadcast_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConferenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceConfiguration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceConfiguration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConferenceDemoCodeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceDemoCode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceDemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConferencePrepareJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferencePrepareJob_Order_By>>;
  where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};


/** query root */
export type Query_RootConferencePrepareJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferencePrepareJob_Order_By>>;
  where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};


/** query root */
export type Query_RootConferencePrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConference_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** query root */
export type Query_RootConference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupHallwayArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupHallway_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentGroupPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentGroupTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentGroupTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupType_Order_By>>;
  where?: Maybe<ContentGroupType_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupType_Order_By>>;
  where?: Maybe<ContentGroupType_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootContentGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContentPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContentPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentType_Order_By>>;
  where?: Maybe<ContentType_Bool_Exp>;
};


/** query root */
export type Query_RootContentType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentType_Order_By>>;
  where?: Maybe<ContentType_Bool_Exp>;
};


/** query root */
export type Query_RootContentType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootEmailArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** query root */
export type Query_RootEmail_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** query root */
export type Query_RootEmail_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** query root */
export type Query_RootEventParticipantStreamArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventParticipantStream_Order_By>>;
  where?: Maybe<EventParticipantStream_Bool_Exp>;
};


/** query root */
export type Query_RootEventParticipantStream_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventParticipantStream_Order_By>>;
  where?: Maybe<EventParticipantStream_Bool_Exp>;
};


/** query root */
export type Query_RootEventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** query root */
export type Query_RootEventPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPersonRole_Order_By>>;
  where?: Maybe<EventPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootEventPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPersonRole_Order_By>>;
  where?: Maybe<EventPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootEventPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootEventPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** query root */
export type Query_RootEventPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventRoomJoinRequestArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventRoomJoinRequest_Order_By>>;
  where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};


/** query root */
export type Query_RootEventRoomJoinRequest_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventRoomJoinRequest_Order_By>>;
  where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};


/** query root */
export type Query_RootEventRoomJoinRequest_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** query root */
export type Query_RootEventTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** query root */
export type Query_RootEventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventVonageSessionArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventVonageSession_Order_By>>;
  where?: Maybe<EventVonageSession_Bool_Exp>;
};


/** query root */
export type Query_RootEventVonageSession_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventVonageSession_Order_By>>;
  where?: Maybe<EventVonageSession_Bool_Exp>;
};


/** query root */
export type Query_RootEventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEvent_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** query root */
export type Query_RootEvent_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** query root */
export type Query_RootExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** query root */
export type Query_RootExecutedTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootFlatUnauthPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** query root */
export type Query_RootFlatUnauthPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** query root */
export type Query_RootFlatUserPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** query root */
export type Query_RootFlatUserPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** query root */
export type Query_RootGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** query root */
export type Query_RootGroupAttendeeArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** query root */
export type Query_RootGroupAttendee_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** query root */
export type Query_RootGroupAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootGroupRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** query root */
export type Query_RootGroupRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** query root */
export type Query_RootGroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** query root */
export type Query_RootGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootHallwayArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** query root */
export type Query_RootHallway_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** query root */
export type Query_RootHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootInputTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<InputType_Order_By>>;
  where?: Maybe<InputType_Bool_Exp>;
};


/** query root */
export type Query_RootInputType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<InputType_Order_By>>;
  where?: Maybe<InputType_Bool_Exp>;
};


/** query root */
export type Query_RootInputType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootInvitationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** query root */
export type Query_RootInvitation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** query root */
export type Query_RootInvitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJobStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<JobStatus_Order_By>>;
  where?: Maybe<JobStatus_Bool_Exp>;
};


/** query root */
export type Query_RootJobStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<JobStatus_Order_By>>;
  where?: Maybe<JobStatus_Bool_Exp>;
};


/** query root */
export type Query_RootJobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootMediaLiveChannelArgs = {
  distinct_on?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<MediaLiveChannel_Order_By>>;
  where?: Maybe<MediaLiveChannel_Bool_Exp>;
};


/** query root */
export type Query_RootMediaLiveChannel_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<MediaLiveChannel_Order_By>>;
  where?: Maybe<MediaLiveChannel_Bool_Exp>;
};


/** query root */
export type Query_RootMediaLiveChannel_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootOnlineStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OnlineStatus_Order_By>>;
  where?: Maybe<OnlineStatus_Bool_Exp>;
};


/** query root */
export type Query_RootOnlineStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OnlineStatus_Order_By>>;
  where?: Maybe<OnlineStatus_Bool_Exp>;
};


/** query root */
export type Query_RootOnlineStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootOriginatingDataArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** query root */
export type Query_RootOriginatingData_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** query root */
export type Query_RootOriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permission_Order_By>>;
  where?: Maybe<Permission_Bool_Exp>;
};


/** query root */
export type Query_RootPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permission_Order_By>>;
  where?: Maybe<Permission_Bool_Exp>;
};


/** query root */
export type Query_RootPermission_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRequiredContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootRequiredContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootRequiredContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** query root */
export type Query_RootRolePermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** query root */
export type Query_RootRolePermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** query root */
export type Query_RootRolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** query root */
export type Query_RootRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** query root */
export type Query_RootRoomModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomMode_Order_By>>;
  where?: Maybe<RoomMode_Bool_Exp>;
};


/** query root */
export type Query_RootRoomMode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomMode_Order_By>>;
  where?: Maybe<RoomMode_Bool_Exp>;
};


/** query root */
export type Query_RootRoomMode_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoomParticipantArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** query root */
export type Query_RootRoomParticipant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** query root */
export type Query_RootRoomParticipant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoomPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPersonRole_Order_By>>;
  where?: Maybe<RoomPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPersonRole_Order_By>>;
  where?: Maybe<RoomPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoomPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoomPrivacyArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPrivacy_Order_By>>;
  where?: Maybe<RoomPrivacy_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPrivacy_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPrivacy_Order_By>>;
  where?: Maybe<RoomPrivacy_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPrivacy_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** query root */
export type Query_RootTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** query root */
export type Query_RootTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootTranscriptionJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<TranscriptionJob_Order_By>>;
  where?: Maybe<TranscriptionJob_Bool_Exp>;
};


/** query root */
export type Query_RootTranscriptionJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<TranscriptionJob_Order_By>>;
  where?: Maybe<TranscriptionJob_Bool_Exp>;
};


/** query root */
export type Query_RootTranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** query root */
export type Query_RootTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** query root */
export type Query_RootTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootUploaderArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** query root */
export type Query_RootUploader_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** query root */
export type Query_RootUploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootUserArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** query root */
export type Query_RootUser_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** query root */
export type Query_RootUser_By_PkArgs = {
  id: Scalars['String'];
};


/** query root */
export type Query_RootVideoRenderJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** query root */
export type Query_RootVideoRenderJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** query root */
export type Query_RootVideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_ChatArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Chat_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_FlagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** query root */
export type Query_RootChat_FlagTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_FlagType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootChat_Flag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootChat_MessageArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** query root */
export type Query_RootChat_MessageTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_MessageType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootChat_Message_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootChat_PinArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Pin_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Pin_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_ReactionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReactionTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReactionType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootChat_Reaction_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Reaction_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootChat_ReadUpToIndexArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReadUpToIndex_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReadUpToIndex_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_SubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Subscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Subscription_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_SubscriptionsWithUnnotifiedMessagesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Order_By>>;
  where?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp>;
};


/** query root */
export type Query_RootChat_SubscriptionsWithUnnotifiedMessages_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Order_By>>;
  where?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp>;
};


/** query root */
export type Query_RootChat_TyperArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Typer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Typer_Order_By>>;
  where?: Maybe<Chat_Typer_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Typer_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Typer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Typer_Order_By>>;
  where?: Maybe<Chat_Typer_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Typer_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** query root */
export type Query_RootEchoArgs = {
  message: Scalars['String'];
};


/** query root */
export type Query_RootGetContentItemArgs = {
  magicToken: Scalars['String'];
};


/** query root */
export type Query_RootGetUploadAgreementArgs = {
  magicToken: Scalars['String'];
};


/** query root */
export type Query_RootJob_Queues_InvitationEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_InvitationEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_MediaPackageHarvestJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_MediaPackageHarvestJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_PublishVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_PublishVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_SubmissionRequestEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_SubmissionRequestEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootProtectedEchoArgs = {
  message: Scalars['String'];
};


/** query root */
export type Query_RootRoom_ShufflePeriodArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShufflePeriod_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoom_ShuffleQueueEntryArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleQueueEntry_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** query root */
export type Query_RootRoom_ShuffleRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};

/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriod = {
  readonly __typename?: 'room_ShufflePeriod';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly endAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly maxAttendeesPerRoom: Scalars['Int'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly organiser: Attendee;
  readonly organiserId: Scalars['uuid'];
  /** An array relationship */
  readonly queueEntries: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** An aggregated array relationship */
  readonly queueEntries_aggregate: Room_ShuffleQueueEntry_Aggregate;
  readonly roomDurationMinutes: Scalars['Int'];
  /** An array relationship */
  readonly shuffleRooms: ReadonlyArray<Room_ShuffleRoom>;
  /** An aggregated array relationship */
  readonly shuffleRooms_aggregate: Room_ShuffleRoom_Aggregate;
  readonly startAt: Scalars['timestamptz'];
  readonly targetAttendeesPerRoom: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
  readonly waitRoomMaxDurationSeconds: Scalars['Int'];
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodQueueEntriesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodQueueEntries_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodShuffleRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodShuffleRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};

/** aggregated selection of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate = {
  readonly __typename?: 'room_ShufflePeriod_aggregate';
  readonly aggregate?: Maybe<Room_ShufflePeriod_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShufflePeriod>;
};

/** aggregate fields of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_Fields = {
  readonly __typename?: 'room_ShufflePeriod_aggregate_fields';
  readonly avg?: Maybe<Room_ShufflePeriod_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShufflePeriod_Max_Fields>;
  readonly min?: Maybe<Room_ShufflePeriod_Min_Fields>;
  readonly stddev?: Maybe<Room_ShufflePeriod_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShufflePeriod_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShufflePeriod_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShufflePeriod_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShufflePeriod_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShufflePeriod_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShufflePeriod_Variance_Fields>;
};


/** aggregate fields of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShufflePeriod_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShufflePeriod_Max_Order_By>;
  readonly min?: Maybe<Room_ShufflePeriod_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShufflePeriod_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShufflePeriod_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShufflePeriod_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShufflePeriod_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShufflePeriod_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShufflePeriod_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShufflePeriod_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShufflePeriod_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShufflePeriod_Avg_Fields = {
  readonly __typename?: 'room_ShufflePeriod_avg_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Avg_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShufflePeriod". All fields are combined with a logical 'AND'. */
export type Room_ShufflePeriod_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShufflePeriod_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShufflePeriod_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly maxAttendeesPerRoom?: Maybe<Int_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly organiser?: Maybe<Attendee_Bool_Exp>;
  readonly organiserId?: Maybe<Uuid_Comparison_Exp>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly roomDurationMinutes?: Maybe<Int_Comparison_Exp>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly startAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly targetAttendeesPerRoom?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Constraint {
  /** unique or primary key constraint */
  ShufflePeriodPkey = 'ShufflePeriod_pkey'
}

/** input type for incrementing integer column in table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Inc_Input = {
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiser?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Arr_Rel_Insert_Input>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Arr_Rel_Insert_Input>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Room_ShufflePeriod_Max_Fields = {
  readonly __typename?: 'room_ShufflePeriod_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShufflePeriod_Min_Fields = {
  readonly __typename?: 'room_ShufflePeriod_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Mutation_Response = {
  readonly __typename?: 'room_ShufflePeriod_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShufflePeriod>;
};

/** input type for inserting object relation for remote table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Obj_Rel_Insert_Input = {
  readonly data: Room_ShufflePeriod_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};

/** on conflict condition type for table "room.ShufflePeriod" */
export type Room_ShufflePeriod_On_Conflict = {
  readonly constraint: Room_ShufflePeriod_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShufflePeriod_Update_Column>;
  readonly where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShufflePeriod" */
export type Room_ShufflePeriod_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiser?: Maybe<Attendee_Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly queueEntries_aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly shuffleRooms_aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShufflePeriod" */
export type Room_ShufflePeriod_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'endAt',
  /** column name */
  Id = 'id',
  /** column name */
  MaxAttendeesPerRoom = 'maxAttendeesPerRoom',
  /** column name */
  Name = 'name',
  /** column name */
  OrganiserId = 'organiserId',
  /** column name */
  RoomDurationMinutes = 'roomDurationMinutes',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  TargetAttendeesPerRoom = 'targetAttendeesPerRoom',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WaitRoomMaxDurationSeconds = 'waitRoomMaxDurationSeconds'
}

/** input type for updating data in table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Room_ShufflePeriod_Stddev_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShufflePeriod_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_pop_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Pop_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShufflePeriod_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_samp_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Samp_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShufflePeriod_Sum_Fields = {
  readonly __typename?: 'room_ShufflePeriod_sum_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Sum_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** update columns of table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'endAt',
  /** column name */
  Id = 'id',
  /** column name */
  MaxAttendeesPerRoom = 'maxAttendeesPerRoom',
  /** column name */
  Name = 'name',
  /** column name */
  OrganiserId = 'organiserId',
  /** column name */
  RoomDurationMinutes = 'roomDurationMinutes',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  TargetAttendeesPerRoom = 'targetAttendeesPerRoom',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WaitRoomMaxDurationSeconds = 'waitRoomMaxDurationSeconds'
}

/** aggregate var_pop on columns */
export type Room_ShufflePeriod_Var_Pop_Fields = {
  readonly __typename?: 'room_ShufflePeriod_var_pop_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Var_Pop_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShufflePeriod_Var_Samp_Fields = {
  readonly __typename?: 'room_ShufflePeriod_var_samp_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Var_Samp_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShufflePeriod_Variance_Fields = {
  readonly __typename?: 'room_ShufflePeriod_variance_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Variance_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry = {
  readonly __typename?: 'room_ShuffleQueueEntry';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['bigint'];
  /** An object relationship */
  readonly shufflePeriod: Room_ShufflePeriod;
  readonly shufflePeriodId: Scalars['uuid'];
  /** An object relationship */
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate = {
  readonly __typename?: 'room_ShuffleQueueEntry_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleQueueEntry>;
};

/** aggregate fields of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields';
  readonly avg?: Maybe<Room_ShuffleQueueEntry_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShuffleQueueEntry_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleQueueEntry_Min_Fields>;
  readonly stddev?: Maybe<Room_ShuffleQueueEntry_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShuffleQueueEntry_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShuffleQueueEntry_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShuffleQueueEntry_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShuffleQueueEntry_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShuffleQueueEntry_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShuffleQueueEntry_Variance_Fields>;
};


/** aggregate fields of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShuffleQueueEntry_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleQueueEntry_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleQueueEntry_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShuffleQueueEntry_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShuffleQueueEntry_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShuffleQueueEntry_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShuffleQueueEntry_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShuffleQueueEntry_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShuffleQueueEntry_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShuffleQueueEntry_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleQueueEntry_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShuffleQueueEntry_Avg_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_avg_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Avg_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShuffleQueueEntry". All fields are combined with a logical 'AND'. */
export type Room_ShuffleQueueEntry_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShuffleQueueEntry_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShuffleQueueEntry_Bool_Exp>>>;
  readonly allocatedShuffleRoomId?: Maybe<Int_Comparison_Exp>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Bigint_Comparison_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Constraint {
  /** unique or primary key constraint */
  ShuffleQueueEntryPkey = 'ShuffleQueueEntry_pkey',
  /** unique or primary key constraint */
  IndexIswaiting = 'index_iswaiting'
}

/** input type for incrementing integer column in table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Inc_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Insert_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Obj_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ShuffleQueueEntry_Max_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_max_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Max_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleQueueEntry_Min_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_min_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Min_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Mutation_Response = {
  readonly __typename?: 'room_ShuffleQueueEntry_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleQueueEntry>;
};

/** input type for inserting object relation for remote table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Obj_Rel_Insert_Input = {
  readonly data: Room_ShuffleQueueEntry_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};

/** on conflict condition type for table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_On_Conflict = {
  readonly constraint: Room_ShuffleQueueEntry_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShuffleQueueEntry_Update_Column>;
  readonly where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Pk_Columns_Input = {
  readonly id: Scalars['bigint'];
};

/** select columns of table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Select_Column {
  /** column name */
  AllocatedShuffleRoomId = 'allocatedShuffleRoomId',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Set_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_ShuffleQueueEntry_Stddev_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShuffleQueueEntry_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_pop_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Pop_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShuffleQueueEntry_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_samp_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Samp_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShuffleQueueEntry_Sum_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_sum_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Sum_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Update_Column {
  /** column name */
  AllocatedShuffleRoomId = 'allocatedShuffleRoomId',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_ShuffleQueueEntry_Var_Pop_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_var_pop_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Var_Pop_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShuffleQueueEntry_Var_Samp_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_var_samp_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Var_Samp_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShuffleQueueEntry_Variance_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_variance_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Variance_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoom = {
  readonly __typename?: 'room_ShuffleRoom';
  readonly created_at: Scalars['timestamptz'];
  readonly durationMinutes: Scalars['Int'];
  readonly id: Scalars['bigint'];
  readonly isEnded: Scalars['Boolean'];
  /** An array relationship */
  readonly queueEntries: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** An aggregated array relationship */
  readonly queueEntries_aggregate: Room_ShuffleQueueEntry_Aggregate;
  readonly reshuffleUponEnd: Scalars['Boolean'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly shufflePeriod: Room_ShufflePeriod;
  readonly shufflePeriodId: Scalars['uuid'];
  readonly startedAt: Scalars['timestamptz'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomQueueEntriesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomQueueEntries_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};

/** aggregated selection of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate = {
  readonly __typename?: 'room_ShuffleRoom_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleRoom>;
};

/** aggregate fields of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleRoom_aggregate_fields';
  readonly avg?: Maybe<Room_ShuffleRoom_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShuffleRoom_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleRoom_Min_Fields>;
  readonly stddev?: Maybe<Room_ShuffleRoom_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShuffleRoom_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShuffleRoom_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShuffleRoom_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShuffleRoom_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShuffleRoom_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShuffleRoom_Variance_Fields>;
};


/** aggregate fields of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShuffleRoom_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleRoom_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleRoom_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShuffleRoom_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShuffleRoom_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShuffleRoom_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShuffleRoom_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShuffleRoom_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShuffleRoom_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShuffleRoom_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleRoom_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShuffleRoom_Avg_Fields = {
  readonly __typename?: 'room_ShuffleRoom_avg_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Avg_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShuffleRoom". All fields are combined with a logical 'AND'. */
export type Room_ShuffleRoom_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShuffleRoom_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShuffleRoom_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly durationMinutes?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Bigint_Comparison_Exp>;
  readonly isEnded?: Maybe<Boolean_Comparison_Exp>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly reshuffleUponEnd?: Maybe<Boolean_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly startedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Constraint {
  /** unique or primary key constraint */
  ShuffleRoomPkey = 'ShuffleRoom_pkey'
}

/** input type for incrementing integer column in table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Inc_Input = {
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isEnded?: Maybe<Scalars['Boolean']>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Arr_Rel_Insert_Input>;
  readonly reshuffleUponEnd?: Maybe<Scalars['Boolean']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ShuffleRoom_Max_Fields = {
  readonly __typename?: 'room_ShuffleRoom_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleRoom_Min_Fields = {
  readonly __typename?: 'room_ShuffleRoom_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Mutation_Response = {
  readonly __typename?: 'room_ShuffleRoom_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleRoom>;
};

/** input type for inserting object relation for remote table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Obj_Rel_Insert_Input = {
  readonly data: Room_ShuffleRoom_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};

/** on conflict condition type for table "room.ShuffleRoom" */
export type Room_ShuffleRoom_On_Conflict = {
  readonly constraint: Room_ShuffleRoom_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShuffleRoom_Update_Column>;
  readonly where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShuffleRoom" */
export type Room_ShuffleRoom_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isEnded?: Maybe<Order_By>;
  readonly queueEntries_aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Order_By>;
  readonly reshuffleUponEnd?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShuffleRoom" */
export type Room_ShuffleRoom_Pk_Columns_Input = {
  readonly id: Scalars['bigint'];
};

/** select columns of table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMinutes = 'durationMinutes',
  /** column name */
  Id = 'id',
  /** column name */
  IsEnded = 'isEnded',
  /** column name */
  ReshuffleUponEnd = 'reshuffleUponEnd',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isEnded?: Maybe<Scalars['Boolean']>;
  readonly reshuffleUponEnd?: Maybe<Scalars['Boolean']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_ShuffleRoom_Stddev_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShuffleRoom_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_pop_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Pop_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShuffleRoom_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_samp_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Samp_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShuffleRoom_Sum_Fields = {
  readonly __typename?: 'room_ShuffleRoom_sum_fields';
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Sum_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMinutes = 'durationMinutes',
  /** column name */
  Id = 'id',
  /** column name */
  IsEnded = 'isEnded',
  /** column name */
  ReshuffleUponEnd = 'reshuffleUponEnd',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_ShuffleRoom_Var_Pop_Fields = {
  readonly __typename?: 'room_ShuffleRoom_var_pop_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Var_Pop_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShuffleRoom_Var_Samp_Fields = {
  readonly __typename?: 'room_ShuffleRoom_var_samp_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Var_Samp_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShuffleRoom_Variance_Fields = {
  readonly __typename?: 'room_ShuffleRoom_variance_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Variance_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** subscription root */
export type Subscription_Root = {
  readonly __typename?: 'subscription_root';
  /** fetch data from the table: "Attendee" */
  readonly Attendee: ReadonlyArray<Attendee>;
  /** fetch data from the table: "AttendeeProfile" */
  readonly AttendeeProfile: ReadonlyArray<AttendeeProfile>;
  /** fetch aggregated fields from the table: "AttendeeProfile" */
  readonly AttendeeProfile_aggregate: AttendeeProfile_Aggregate;
  /** fetch data from the table: "AttendeeProfile" using primary key columns */
  readonly AttendeeProfile_by_pk?: Maybe<AttendeeProfile>;
  /** fetch aggregated fields from the table: "Attendee" */
  readonly Attendee_aggregate: Attendee_Aggregate;
  /** fetch data from the table: "Attendee" using primary key columns */
  readonly Attendee_by_pk?: Maybe<Attendee>;
  /** fetch data from the table: "Broadcast" */
  readonly Broadcast: ReadonlyArray<Broadcast>;
  /** fetch data from the table: "BroadcastContentItem" */
  readonly BroadcastContentItem: ReadonlyArray<BroadcastContentItem>;
  /** fetch aggregated fields from the table: "BroadcastContentItem" */
  readonly BroadcastContentItem_aggregate: BroadcastContentItem_Aggregate;
  /** fetch data from the table: "BroadcastContentItem" using primary key columns */
  readonly BroadcastContentItem_by_pk?: Maybe<BroadcastContentItem>;
  /** fetch aggregated fields from the table: "Broadcast" */
  readonly Broadcast_aggregate: Broadcast_Aggregate;
  /** fetch data from the table: "Broadcast" using primary key columns */
  readonly Broadcast_by_pk?: Maybe<Broadcast>;
  /** fetch data from the table: "Conference" */
  readonly Conference: ReadonlyArray<Conference>;
  /** fetch data from the table: "ConferenceConfiguration" */
  readonly ConferenceConfiguration: ReadonlyArray<ConferenceConfiguration>;
  /** fetch aggregated fields from the table: "ConferenceConfiguration" */
  readonly ConferenceConfiguration_aggregate: ConferenceConfiguration_Aggregate;
  /** fetch data from the table: "ConferenceConfiguration" using primary key columns */
  readonly ConferenceConfiguration_by_pk?: Maybe<ConferenceConfiguration>;
  /** fetch data from the table: "ConferenceDemoCode" */
  readonly ConferenceDemoCode: ReadonlyArray<ConferenceDemoCode>;
  /** fetch aggregated fields from the table: "ConferenceDemoCode" */
  readonly ConferenceDemoCode_aggregate: ConferenceDemoCode_Aggregate;
  /** fetch data from the table: "ConferenceDemoCode" using primary key columns */
  readonly ConferenceDemoCode_by_pk?: Maybe<ConferenceDemoCode>;
  /** fetch data from the table: "ConferencePrepareJob" */
  readonly ConferencePrepareJob: ReadonlyArray<ConferencePrepareJob>;
  /** fetch aggregated fields from the table: "ConferencePrepareJob" */
  readonly ConferencePrepareJob_aggregate: ConferencePrepareJob_Aggregate;
  /** fetch data from the table: "ConferencePrepareJob" using primary key columns */
  readonly ConferencePrepareJob_by_pk?: Maybe<ConferencePrepareJob>;
  /** fetch aggregated fields from the table: "Conference" */
  readonly Conference_aggregate: Conference_Aggregate;
  /** fetch data from the table: "Conference" using primary key columns */
  readonly Conference_by_pk?: Maybe<Conference>;
  /** fetch data from the table: "ContentGroup" */
  readonly ContentGroup: ReadonlyArray<ContentGroup>;
  /** fetch data from the table: "ContentGroupHallway" */
  readonly ContentGroupHallway: ReadonlyArray<ContentGroupHallway>;
  /** fetch aggregated fields from the table: "ContentGroupHallway" */
  readonly ContentGroupHallway_aggregate: ContentGroupHallway_Aggregate;
  /** fetch data from the table: "ContentGroupHallway" using primary key columns */
  readonly ContentGroupHallway_by_pk?: Maybe<ContentGroupHallway>;
  /** fetch data from the table: "ContentGroupPerson" */
  readonly ContentGroupPerson: ReadonlyArray<ContentGroupPerson>;
  /** fetch aggregated fields from the table: "ContentGroupPerson" */
  readonly ContentGroupPerson_aggregate: ContentGroupPerson_Aggregate;
  /** fetch data from the table: "ContentGroupPerson" using primary key columns */
  readonly ContentGroupPerson_by_pk?: Maybe<ContentGroupPerson>;
  /** fetch data from the table: "ContentGroupTag" */
  readonly ContentGroupTag: ReadonlyArray<ContentGroupTag>;
  /** fetch aggregated fields from the table: "ContentGroupTag" */
  readonly ContentGroupTag_aggregate: ContentGroupTag_Aggregate;
  /** fetch data from the table: "ContentGroupTag" using primary key columns */
  readonly ContentGroupTag_by_pk?: Maybe<ContentGroupTag>;
  /** fetch data from the table: "ContentGroupType" */
  readonly ContentGroupType: ReadonlyArray<ContentGroupType>;
  /** fetch aggregated fields from the table: "ContentGroupType" */
  readonly ContentGroupType_aggregate: ContentGroupType_Aggregate;
  /** fetch data from the table: "ContentGroupType" using primary key columns */
  readonly ContentGroupType_by_pk?: Maybe<ContentGroupType>;
  /** fetch aggregated fields from the table: "ContentGroup" */
  readonly ContentGroup_aggregate: ContentGroup_Aggregate;
  /** fetch data from the table: "ContentGroup" using primary key columns */
  readonly ContentGroup_by_pk?: Maybe<ContentGroup>;
  /** fetch data from the table: "ContentItem" */
  readonly ContentItem: ReadonlyArray<ContentItem>;
  /** fetch aggregated fields from the table: "ContentItem" */
  readonly ContentItem_aggregate: ContentItem_Aggregate;
  /** fetch data from the table: "ContentItem" using primary key columns */
  readonly ContentItem_by_pk?: Maybe<ContentItem>;
  /** fetch data from the table: "ContentPerson" */
  readonly ContentPerson: ReadonlyArray<ContentPerson>;
  /** fetch aggregated fields from the table: "ContentPerson" */
  readonly ContentPerson_aggregate: ContentPerson_Aggregate;
  /** fetch data from the table: "ContentPerson" using primary key columns */
  readonly ContentPerson_by_pk?: Maybe<ContentPerson>;
  /** fetch data from the table: "ContentType" */
  readonly ContentType: ReadonlyArray<ContentType>;
  /** fetch aggregated fields from the table: "ContentType" */
  readonly ContentType_aggregate: ContentType_Aggregate;
  /** fetch data from the table: "ContentType" using primary key columns */
  readonly ContentType_by_pk?: Maybe<ContentType>;
  /** fetch data from the table: "Email" */
  readonly Email: ReadonlyArray<Email>;
  /** fetch aggregated fields from the table: "Email" */
  readonly Email_aggregate: Email_Aggregate;
  /** fetch data from the table: "Email" using primary key columns */
  readonly Email_by_pk?: Maybe<Email>;
  /** fetch data from the table: "Event" */
  readonly Event: ReadonlyArray<Event>;
  /** fetch data from the table: "EventParticipantStream" */
  readonly EventParticipantStream: ReadonlyArray<EventParticipantStream>;
  /** fetch aggregated fields from the table: "EventParticipantStream" */
  readonly EventParticipantStream_aggregate: EventParticipantStream_Aggregate;
  /** fetch data from the table: "EventParticipantStream" using primary key columns */
  readonly EventParticipantStream_by_pk?: Maybe<EventParticipantStream>;
  /** fetch data from the table: "EventPerson" */
  readonly EventPerson: ReadonlyArray<EventPerson>;
  /** fetch data from the table: "EventPersonRole" */
  readonly EventPersonRole: ReadonlyArray<EventPersonRole>;
  /** fetch aggregated fields from the table: "EventPersonRole" */
  readonly EventPersonRole_aggregate: EventPersonRole_Aggregate;
  /** fetch data from the table: "EventPersonRole" using primary key columns */
  readonly EventPersonRole_by_pk?: Maybe<EventPersonRole>;
  /** fetch aggregated fields from the table: "EventPerson" */
  readonly EventPerson_aggregate: EventPerson_Aggregate;
  /** fetch data from the table: "EventPerson" using primary key columns */
  readonly EventPerson_by_pk?: Maybe<EventPerson>;
  /** fetch data from the table: "EventRoomJoinRequest" */
  readonly EventRoomJoinRequest: ReadonlyArray<EventRoomJoinRequest>;
  /** fetch aggregated fields from the table: "EventRoomJoinRequest" */
  readonly EventRoomJoinRequest_aggregate: EventRoomJoinRequest_Aggregate;
  /** fetch data from the table: "EventRoomJoinRequest" using primary key columns */
  readonly EventRoomJoinRequest_by_pk?: Maybe<EventRoomJoinRequest>;
  /** fetch data from the table: "EventTag" */
  readonly EventTag: ReadonlyArray<EventTag>;
  /** fetch aggregated fields from the table: "EventTag" */
  readonly EventTag_aggregate: EventTag_Aggregate;
  /** fetch data from the table: "EventTag" using primary key columns */
  readonly EventTag_by_pk?: Maybe<EventTag>;
  /** fetch data from the table: "EventVonageSession" */
  readonly EventVonageSession: ReadonlyArray<EventVonageSession>;
  /** fetch aggregated fields from the table: "EventVonageSession" */
  readonly EventVonageSession_aggregate: EventVonageSession_Aggregate;
  /** fetch data from the table: "EventVonageSession" using primary key columns */
  readonly EventVonageSession_by_pk?: Maybe<EventVonageSession>;
  /** fetch aggregated fields from the table: "Event" */
  readonly Event_aggregate: Event_Aggregate;
  /** fetch data from the table: "Event" using primary key columns */
  readonly Event_by_pk?: Maybe<Event>;
  /** fetch data from the table: "ExecutedTransitions" */
  readonly ExecutedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** fetch aggregated fields from the table: "ExecutedTransitions" */
  readonly ExecutedTransitions_aggregate: ExecutedTransitions_Aggregate;
  /** fetch data from the table: "ExecutedTransitions" using primary key columns */
  readonly ExecutedTransitions_by_pk?: Maybe<ExecutedTransitions>;
  /** fetch data from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission: ReadonlyArray<FlatUnauthPermission>;
  /** fetch aggregated fields from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission_aggregate: FlatUnauthPermission_Aggregate;
  /** fetch data from the table: "FlatUserPermission" */
  readonly FlatUserPermission: ReadonlyArray<FlatUserPermission>;
  /** fetch aggregated fields from the table: "FlatUserPermission" */
  readonly FlatUserPermission_aggregate: FlatUserPermission_Aggregate;
  /** fetch data from the table: "Group" */
  readonly Group: ReadonlyArray<Group>;
  /** fetch data from the table: "GroupAttendee" */
  readonly GroupAttendee: ReadonlyArray<GroupAttendee>;
  /** fetch aggregated fields from the table: "GroupAttendee" */
  readonly GroupAttendee_aggregate: GroupAttendee_Aggregate;
  /** fetch data from the table: "GroupAttendee" using primary key columns */
  readonly GroupAttendee_by_pk?: Maybe<GroupAttendee>;
  /** fetch data from the table: "GroupRole" */
  readonly GroupRole: ReadonlyArray<GroupRole>;
  /** fetch aggregated fields from the table: "GroupRole" */
  readonly GroupRole_aggregate: GroupRole_Aggregate;
  /** fetch data from the table: "GroupRole" using primary key columns */
  readonly GroupRole_by_pk?: Maybe<GroupRole>;
  /** fetch aggregated fields from the table: "Group" */
  readonly Group_aggregate: Group_Aggregate;
  /** fetch data from the table: "Group" using primary key columns */
  readonly Group_by_pk?: Maybe<Group>;
  /** fetch data from the table: "Hallway" */
  readonly Hallway: ReadonlyArray<Hallway>;
  /** fetch aggregated fields from the table: "Hallway" */
  readonly Hallway_aggregate: Hallway_Aggregate;
  /** fetch data from the table: "Hallway" using primary key columns */
  readonly Hallway_by_pk?: Maybe<Hallway>;
  /** fetch data from the table: "InputType" */
  readonly InputType: ReadonlyArray<InputType>;
  /** fetch aggregated fields from the table: "InputType" */
  readonly InputType_aggregate: InputType_Aggregate;
  /** fetch data from the table: "InputType" using primary key columns */
  readonly InputType_by_pk?: Maybe<InputType>;
  /** fetch data from the table: "Invitation" */
  readonly Invitation: ReadonlyArray<Invitation>;
  /** fetch aggregated fields from the table: "Invitation" */
  readonly Invitation_aggregate: Invitation_Aggregate;
  /** fetch data from the table: "Invitation" using primary key columns */
  readonly Invitation_by_pk?: Maybe<Invitation>;
  /** fetch data from the table: "JobStatus" */
  readonly JobStatus: ReadonlyArray<JobStatus>;
  /** fetch aggregated fields from the table: "JobStatus" */
  readonly JobStatus_aggregate: JobStatus_Aggregate;
  /** fetch data from the table: "JobStatus" using primary key columns */
  readonly JobStatus_by_pk?: Maybe<JobStatus>;
  /** fetch data from the table: "MediaLiveChannel" */
  readonly MediaLiveChannel: ReadonlyArray<MediaLiveChannel>;
  /** fetch aggregated fields from the table: "MediaLiveChannel" */
  readonly MediaLiveChannel_aggregate: MediaLiveChannel_Aggregate;
  /** fetch data from the table: "MediaLiveChannel" using primary key columns */
  readonly MediaLiveChannel_by_pk?: Maybe<MediaLiveChannel>;
  /** fetch data from the table: "OnlineStatus" */
  readonly OnlineStatus: ReadonlyArray<OnlineStatus>;
  /** fetch aggregated fields from the table: "OnlineStatus" */
  readonly OnlineStatus_aggregate: OnlineStatus_Aggregate;
  /** fetch data from the table: "OnlineStatus" using primary key columns */
  readonly OnlineStatus_by_pk?: Maybe<OnlineStatus>;
  /** fetch data from the table: "OriginatingData" */
  readonly OriginatingData: ReadonlyArray<OriginatingData>;
  /** fetch aggregated fields from the table: "OriginatingData" */
  readonly OriginatingData_aggregate: OriginatingData_Aggregate;
  /** fetch data from the table: "OriginatingData" using primary key columns */
  readonly OriginatingData_by_pk?: Maybe<OriginatingData>;
  /** fetch data from the table: "Permission" */
  readonly Permission: ReadonlyArray<Permission>;
  /** fetch aggregated fields from the table: "Permission" */
  readonly Permission_aggregate: Permission_Aggregate;
  /** fetch data from the table: "Permission" using primary key columns */
  readonly Permission_by_pk?: Maybe<Permission>;
  /** fetch data from the table: "RequiredContentItem" */
  readonly RequiredContentItem: ReadonlyArray<RequiredContentItem>;
  /** fetch aggregated fields from the table: "RequiredContentItem" */
  readonly RequiredContentItem_aggregate: RequiredContentItem_Aggregate;
  /** fetch data from the table: "RequiredContentItem" using primary key columns */
  readonly RequiredContentItem_by_pk?: Maybe<RequiredContentItem>;
  /** fetch data from the table: "Role" */
  readonly Role: ReadonlyArray<Role>;
  /** fetch data from the table: "RolePermission" */
  readonly RolePermission: ReadonlyArray<RolePermission>;
  /** fetch aggregated fields from the table: "RolePermission" */
  readonly RolePermission_aggregate: RolePermission_Aggregate;
  /** fetch data from the table: "RolePermission" using primary key columns */
  readonly RolePermission_by_pk?: Maybe<RolePermission>;
  /** fetch aggregated fields from the table: "Role" */
  readonly Role_aggregate: Role_Aggregate;
  /** fetch data from the table: "Role" using primary key columns */
  readonly Role_by_pk?: Maybe<Role>;
  /** fetch data from the table: "Room" */
  readonly Room: ReadonlyArray<Room>;
  /** fetch data from the table: "RoomMode" */
  readonly RoomMode: ReadonlyArray<RoomMode>;
  /** fetch aggregated fields from the table: "RoomMode" */
  readonly RoomMode_aggregate: RoomMode_Aggregate;
  /** fetch data from the table: "RoomMode" using primary key columns */
  readonly RoomMode_by_pk?: Maybe<RoomMode>;
  /** fetch data from the table: "RoomParticipant" */
  readonly RoomParticipant: ReadonlyArray<RoomParticipant>;
  /** fetch aggregated fields from the table: "RoomParticipant" */
  readonly RoomParticipant_aggregate: RoomParticipant_Aggregate;
  /** fetch data from the table: "RoomParticipant" using primary key columns */
  readonly RoomParticipant_by_pk?: Maybe<RoomParticipant>;
  /** fetch data from the table: "RoomPerson" */
  readonly RoomPerson: ReadonlyArray<RoomPerson>;
  /** fetch data from the table: "RoomPersonRole" */
  readonly RoomPersonRole: ReadonlyArray<RoomPersonRole>;
  /** fetch aggregated fields from the table: "RoomPersonRole" */
  readonly RoomPersonRole_aggregate: RoomPersonRole_Aggregate;
  /** fetch data from the table: "RoomPersonRole" using primary key columns */
  readonly RoomPersonRole_by_pk?: Maybe<RoomPersonRole>;
  /** fetch aggregated fields from the table: "RoomPerson" */
  readonly RoomPerson_aggregate: RoomPerson_Aggregate;
  /** fetch data from the table: "RoomPerson" using primary key columns */
  readonly RoomPerson_by_pk?: Maybe<RoomPerson>;
  /** fetch data from the table: "RoomPrivacy" */
  readonly RoomPrivacy: ReadonlyArray<RoomPrivacy>;
  /** fetch aggregated fields from the table: "RoomPrivacy" */
  readonly RoomPrivacy_aggregate: RoomPrivacy_Aggregate;
  /** fetch data from the table: "RoomPrivacy" using primary key columns */
  readonly RoomPrivacy_by_pk?: Maybe<RoomPrivacy>;
  /** fetch aggregated fields from the table: "Room" */
  readonly Room_aggregate: Room_Aggregate;
  /** fetch data from the table: "Room" using primary key columns */
  readonly Room_by_pk?: Maybe<Room>;
  /** fetch data from the table: "Tag" */
  readonly Tag: ReadonlyArray<Tag>;
  /** fetch aggregated fields from the table: "Tag" */
  readonly Tag_aggregate: Tag_Aggregate;
  /** fetch data from the table: "Tag" using primary key columns */
  readonly Tag_by_pk?: Maybe<Tag>;
  /** fetch data from the table: "TranscriptionJob" */
  readonly TranscriptionJob: ReadonlyArray<TranscriptionJob>;
  /** fetch aggregated fields from the table: "TranscriptionJob" */
  readonly TranscriptionJob_aggregate: TranscriptionJob_Aggregate;
  /** fetch data from the table: "TranscriptionJob" using primary key columns */
  readonly TranscriptionJob_by_pk?: Maybe<TranscriptionJob>;
  /** fetch data from the table: "Transitions" */
  readonly Transitions: ReadonlyArray<Transitions>;
  /** fetch aggregated fields from the table: "Transitions" */
  readonly Transitions_aggregate: Transitions_Aggregate;
  /** fetch data from the table: "Transitions" using primary key columns */
  readonly Transitions_by_pk?: Maybe<Transitions>;
  /** fetch data from the table: "Uploader" */
  readonly Uploader: ReadonlyArray<Uploader>;
  /** fetch aggregated fields from the table: "Uploader" */
  readonly Uploader_aggregate: Uploader_Aggregate;
  /** fetch data from the table: "Uploader" using primary key columns */
  readonly Uploader_by_pk?: Maybe<Uploader>;
  /** fetch data from the table: "User" */
  readonly User: ReadonlyArray<User>;
  /** fetch aggregated fields from the table: "User" */
  readonly User_aggregate: User_Aggregate;
  /** fetch data from the table: "User" using primary key columns */
  readonly User_by_pk?: Maybe<User>;
  /** fetch data from the table: "VideoRenderJob" */
  readonly VideoRenderJob: ReadonlyArray<VideoRenderJob>;
  /** fetch aggregated fields from the table: "VideoRenderJob" */
  readonly VideoRenderJob_aggregate: VideoRenderJob_Aggregate;
  /** fetch data from the table: "VideoRenderJob" using primary key columns */
  readonly VideoRenderJob_by_pk?: Maybe<VideoRenderJob>;
  /** fetch data from the table: "chat.Chat" */
  readonly chat_Chat: ReadonlyArray<Chat_Chat>;
  /** fetch aggregated fields from the table: "chat.Chat" */
  readonly chat_Chat_aggregate: Chat_Chat_Aggregate;
  /** fetch data from the table: "chat.Chat" using primary key columns */
  readonly chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** fetch data from the table: "chat.Flag" */
  readonly chat_Flag: ReadonlyArray<Chat_Flag>;
  /** fetch data from the table: "chat.FlagType" */
  readonly chat_FlagType: ReadonlyArray<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.FlagType" */
  readonly chat_FlagType_aggregate: Chat_FlagType_Aggregate;
  /** fetch data from the table: "chat.FlagType" using primary key columns */
  readonly chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.Flag" */
  readonly chat_Flag_aggregate: Chat_Flag_Aggregate;
  /** fetch data from the table: "chat.Flag" using primary key columns */
  readonly chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** fetch data from the table: "chat.Message" */
  readonly chat_Message: ReadonlyArray<Chat_Message>;
  /** fetch data from the table: "chat.MessageType" */
  readonly chat_MessageType: ReadonlyArray<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.MessageType" */
  readonly chat_MessageType_aggregate: Chat_MessageType_Aggregate;
  /** fetch data from the table: "chat.MessageType" using primary key columns */
  readonly chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.Message" */
  readonly chat_Message_aggregate: Chat_Message_Aggregate;
  /** fetch data from the table: "chat.Message" using primary key columns */
  readonly chat_Message_by_pk?: Maybe<Chat_Message>;
  /** fetch data from the table: "chat.Pin" */
  readonly chat_Pin: ReadonlyArray<Chat_Pin>;
  /** fetch aggregated fields from the table: "chat.Pin" */
  readonly chat_Pin_aggregate: Chat_Pin_Aggregate;
  /** fetch data from the table: "chat.Pin" using primary key columns */
  readonly chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** fetch data from the table: "chat.Reaction" */
  readonly chat_Reaction: ReadonlyArray<Chat_Reaction>;
  /** fetch data from the table: "chat.ReactionType" */
  readonly chat_ReactionType: ReadonlyArray<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.ReactionType" */
  readonly chat_ReactionType_aggregate: Chat_ReactionType_Aggregate;
  /** fetch data from the table: "chat.ReactionType" using primary key columns */
  readonly chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.Reaction" */
  readonly chat_Reaction_aggregate: Chat_Reaction_Aggregate;
  /** fetch data from the table: "chat.Reaction" using primary key columns */
  readonly chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** fetch data from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex: ReadonlyArray<Chat_ReadUpToIndex>;
  /** fetch aggregated fields from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex_aggregate: Chat_ReadUpToIndex_Aggregate;
  /** fetch data from the table: "chat.ReadUpToIndex" using primary key columns */
  readonly chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** fetch data from the table: "chat.Subscription" */
  readonly chat_Subscription: ReadonlyArray<Chat_Subscription>;
  /** fetch aggregated fields from the table: "chat.Subscription" */
  readonly chat_Subscription_aggregate: Chat_Subscription_Aggregate;
  /** fetch data from the table: "chat.Subscription" using primary key columns */
  readonly chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** fetch data from the table: "chat.SubscriptionsWithUnnotifiedMessages" */
  readonly chat_SubscriptionsWithUnnotifiedMessages: ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages>;
  /** fetch aggregated fields from the table: "chat.SubscriptionsWithUnnotifiedMessages" */
  readonly chat_SubscriptionsWithUnnotifiedMessages_aggregate: Chat_SubscriptionsWithUnnotifiedMessages_Aggregate;
  /** fetch data from the table: "chat.Typer" */
  readonly chat_Typer: ReadonlyArray<Chat_Typer>;
  /** fetch aggregated fields from the table: "chat.Typer" */
  readonly chat_Typer_aggregate: Chat_Typer_Aggregate;
  /** fetch data from the table: "chat.Typer" using primary key columns */
  readonly chat_Typer_by_pk?: Maybe<Chat_Typer>;
  /** perform the action: "echo" */
  readonly echo?: Maybe<EchoOutput>;
  /** perform the action: "getContentItem" */
  readonly getContentItem?: Maybe<ReadonlyArray<Maybe<GetContentItemOutput>>>;
  /** perform the action: "getUploadAgreement" */
  readonly getUploadAgreement?: Maybe<GetUploadAgreementOutput>;
  /** fetch data from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob: ReadonlyArray<Job_Queues_InvitationEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob_aggregate: Job_Queues_InvitationEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.InvitationEmailJob" using primary key columns */
  readonly job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
  /** fetch aggregated fields from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob_aggregate: Job_Queues_MediaPackageHarvestJob_Aggregate;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" using primary key columns */
  readonly job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** fetch data from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob: ReadonlyArray<Job_Queues_PublishVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob_aggregate: Job_Queues_PublishVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.PublishVideoJob" using primary key columns */
  readonly job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob_aggregate: Job_Queues_SubmissionRequestEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" using primary key columns */
  readonly job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** perform the action: "protectedEcho" */
  readonly protectedEcho?: Maybe<ProtectedEchoOutput>;
  /** fetch data from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod: ReadonlyArray<Room_ShufflePeriod>;
  /** fetch aggregated fields from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod_aggregate: Room_ShufflePeriod_Aggregate;
  /** fetch data from the table: "room.ShufflePeriod" using primary key columns */
  readonly room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** fetch data from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** fetch aggregated fields from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry_aggregate: Room_ShuffleQueueEntry_Aggregate;
  /** fetch data from the table: "room.ShuffleQueueEntry" using primary key columns */
  readonly room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** fetch data from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom: ReadonlyArray<Room_ShuffleRoom>;
  /** fetch aggregated fields from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom_aggregate: Room_ShuffleRoom_Aggregate;
  /** fetch data from the table: "room.ShuffleRoom" using primary key columns */
  readonly room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
};


/** subscription root */
export type Subscription_RootAttendeeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeProfileArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfile_Order_By>>;
  where?: Maybe<AttendeeProfile_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeProfile_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfile_Order_By>>;
  where?: Maybe<AttendeeProfile_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeProfile_By_PkArgs = {
  attendeeId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootAttendee_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootBroadcastArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootBroadcastContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootBroadcastContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootBroadcastContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootBroadcast_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootBroadcast_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConferenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceConfiguration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceConfiguration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConferenceDemoCodeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceDemoCode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceDemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConferencePrepareJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferencePrepareJob_Order_By>>;
  where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferencePrepareJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferencePrepareJob_Order_By>>;
  where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferencePrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConference_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupHallwayArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupHallway_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentGroupPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentGroupTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentGroupTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupType_Order_By>>;
  where?: Maybe<ContentGroupType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupType_Order_By>>;
  where?: Maybe<ContentGroupType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootContentGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentType_Order_By>>;
  where?: Maybe<ContentType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentType_Order_By>>;
  where?: Maybe<ContentType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootEmailArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEmail_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEmail_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventParticipantStreamArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventParticipantStream_Order_By>>;
  where?: Maybe<EventParticipantStream_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventParticipantStream_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventParticipantStream_Order_By>>;
  where?: Maybe<EventParticipantStream_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPersonRole_Order_By>>;
  where?: Maybe<EventPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPersonRole_Order_By>>;
  where?: Maybe<EventPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootEventPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventRoomJoinRequestArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventRoomJoinRequest_Order_By>>;
  where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventRoomJoinRequest_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventRoomJoinRequest_Order_By>>;
  where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventRoomJoinRequest_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventVonageSessionArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventVonageSession_Order_By>>;
  where?: Maybe<EventVonageSession_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventVonageSession_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventVonageSession_Order_By>>;
  where?: Maybe<EventVonageSession_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEvent_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEvent_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootExecutedTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootFlatUnauthPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootFlatUnauthPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootFlatUserPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootFlatUserPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupAttendeeArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupAttendee_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootGroupRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootHallwayArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootHallway_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootInputTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<InputType_Order_By>>;
  where?: Maybe<InputType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInputType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<InputType_Order_By>>;
  where?: Maybe<InputType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInputType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootInvitationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInvitation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInvitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJobStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<JobStatus_Order_By>>;
  where?: Maybe<JobStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJobStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<JobStatus_Order_By>>;
  where?: Maybe<JobStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootMediaLiveChannelArgs = {
  distinct_on?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<MediaLiveChannel_Order_By>>;
  where?: Maybe<MediaLiveChannel_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootMediaLiveChannel_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<MediaLiveChannel_Order_By>>;
  where?: Maybe<MediaLiveChannel_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootMediaLiveChannel_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootOnlineStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OnlineStatus_Order_By>>;
  where?: Maybe<OnlineStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootOnlineStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OnlineStatus_Order_By>>;
  where?: Maybe<OnlineStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootOnlineStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootOriginatingDataArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootOriginatingData_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootOriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permission_Order_By>>;
  where?: Maybe<Permission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permission_Order_By>>;
  where?: Maybe<Permission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermission_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRequiredContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRequiredContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRequiredContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRolePermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRolePermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomMode_Order_By>>;
  where?: Maybe<RoomMode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomMode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomMode_Order_By>>;
  where?: Maybe<RoomMode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomMode_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoomParticipantArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomParticipant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomParticipant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoomPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPersonRole_Order_By>>;
  where?: Maybe<RoomPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPersonRole_Order_By>>;
  where?: Maybe<RoomPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoomPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoomPrivacyArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPrivacy_Order_By>>;
  where?: Maybe<RoomPrivacy_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPrivacy_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPrivacy_Order_By>>;
  where?: Maybe<RoomPrivacy_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPrivacy_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootTranscriptionJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<TranscriptionJob_Order_By>>;
  where?: Maybe<TranscriptionJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTranscriptionJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<TranscriptionJob_Order_By>>;
  where?: Maybe<TranscriptionJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootUploaderArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUploader_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootUserArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUser_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUser_By_PkArgs = {
  id: Scalars['String'];
};


/** subscription root */
export type Subscription_RootVideoRenderJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideoRenderJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_ChatArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Chat_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_FlagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_FlagTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_FlagType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootChat_Flag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootChat_MessageArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_MessageTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_MessageType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootChat_Message_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootChat_PinArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Pin_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Pin_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_ReactionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReactionTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReactionType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootChat_Reaction_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Reaction_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootChat_ReadUpToIndexArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReadUpToIndex_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReadUpToIndex_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_SubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Subscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Subscription_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_SubscriptionsWithUnnotifiedMessagesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Order_By>>;
  where?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_SubscriptionsWithUnnotifiedMessages_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_SubscriptionsWithUnnotifiedMessages_Order_By>>;
  where?: Maybe<Chat_SubscriptionsWithUnnotifiedMessages_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_TyperArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Typer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Typer_Order_By>>;
  where?: Maybe<Chat_Typer_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Typer_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Typer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Typer_Order_By>>;
  where?: Maybe<Chat_Typer_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Typer_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEchoArgs = {
  message: Scalars['String'];
};


/** subscription root */
export type Subscription_RootGetContentItemArgs = {
  magicToken: Scalars['String'];
};


/** subscription root */
export type Subscription_RootGetUploadAgreementArgs = {
  magicToken: Scalars['String'];
};


/** subscription root */
export type Subscription_RootJob_Queues_InvitationEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_InvitationEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_MediaPackageHarvestJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_MediaPackageHarvestJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_PublishVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_PublishVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_SubmissionRequestEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_SubmissionRequestEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootProtectedEchoArgs = {
  message: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_ShufflePeriodArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShufflePeriod_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoom_ShuffleQueueEntryArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleQueueEntry_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** subscription root */
export type Subscription_RootRoom_ShuffleRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


/** expression to compare columns of type timestamptz. All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['timestamptz']>;
  readonly _gt?: Maybe<Scalars['timestamptz']>;
  readonly _gte?: Maybe<Scalars['timestamptz']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['timestamptz']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['timestamptz']>;
  readonly _lte?: Maybe<Scalars['timestamptz']>;
  readonly _neq?: Maybe<Scalars['timestamptz']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['timestamptz']>>;
};


/** expression to compare columns of type uuid. All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['uuid']>;
  readonly _gt?: Maybe<Scalars['uuid']>;
  readonly _gte?: Maybe<Scalars['uuid']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['uuid']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['uuid']>;
  readonly _lte?: Maybe<Scalars['uuid']>;
  readonly _neq?: Maybe<Scalars['uuid']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['uuid']>>;
};

export type SubscribedChatsQueryVariables = Exact<{
  attendeeId: Scalars['uuid'];
}>;


export type SubscribedChatsQuery = { readonly __typename?: 'query_root', readonly chat_Subscription: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly attendeeId: any, readonly chatId: any }> };

export type SubdMessages_2021_01_21T08_24SubscriptionVariables = Exact<{
  chatIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type SubdMessages_2021_01_21T08_24Subscription = { readonly __typename?: 'subscription_root', readonly chat_Message: ReadonlyArray<{ readonly __typename?: 'chat_Message', readonly id: number, readonly chatId: any, readonly message: string, readonly type: Chat_MessageType_Enum, readonly senderId?: Maybe<any>, readonly senderName: string, readonly chatTitle: string }> };

export type SetNotifiedUpToIndexMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
  msgId: Scalars['Int'];
}>;


export type SetNotifiedUpToIndexMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_ReadUpToIndex_one?: Maybe<{ readonly __typename?: 'chat_ReadUpToIndex', readonly chatId: any, readonly attendeeId: any, readonly notifiedUpToMessageId: number }> };

export type GetChatPathQueryVariables = Exact<{
  chatId: Scalars['uuid'];
}>;


export type GetChatPathQuery = { readonly __typename?: 'query_root', readonly chat_Chat_by_pk?: Maybe<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly room: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }>, readonly contentGroup: ReadonlyArray<{ readonly __typename?: 'ContentGroup', readonly id: any }> }> };

export type SendChatMessageMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  senderId: Scalars['uuid'];
  type: Chat_MessageType_Enum;
  message: Scalars['String'];
  data?: Maybe<Scalars['jsonb']>;
  isPinned?: Maybe<Scalars['Boolean']>;
  chatTitle?: Maybe<Scalars['String']>;
  senderName?: Maybe<Scalars['String']>;
}>;


export type SendChatMessageMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Message?: Maybe<{ readonly __typename?: 'chat_Message_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'chat_Message', readonly id: number, readonly duplicatedMessageId?: Maybe<number> }> }> };

export type SendChatAnswerMutationVariables = Exact<{
  data: Scalars['jsonb'];
  senderId: Scalars['uuid'];
  answeringId: Scalars['Int'];
}>;


export type SendChatAnswerMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Reaction?: Maybe<{ readonly __typename?: 'chat_Reaction_mutation_response', readonly affected_rows: number }> };

export type AddReactionMutationVariables = Exact<{
  reaction: Chat_Reaction_Insert_Input;
}>;


export type AddReactionMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Reaction?: Maybe<{ readonly __typename?: 'chat_Reaction_mutation_response', readonly affected_rows: number }> };

export type DeleteReactionMutationVariables = Exact<{
  reactionId: Scalars['Int'];
}>;


export type DeleteReactionMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Reaction_by_pk?: Maybe<{ readonly __typename?: 'chat_Reaction', readonly id: number }> };

export type SelectReadUpToIndexQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type SelectReadUpToIndexQuery = { readonly __typename?: 'query_root', readonly chat_ReadUpToIndex_by_pk?: Maybe<{ readonly __typename?: 'chat_ReadUpToIndex', readonly chatId: any, readonly attendeeId: any, readonly messageId: number }> };

export type SetReadUpToIndexMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
  messageId: Scalars['Int'];
}>;


export type SetReadUpToIndexMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_ReadUpToIndex?: Maybe<{ readonly __typename?: 'chat_ReadUpToIndex_mutation_response', readonly affected_rows: number }> };

export type ChatFlagDataFragment = { readonly __typename?: 'chat_Flag', readonly discussionChatId?: Maybe<any>, readonly flaggedById?: Maybe<any>, readonly id: number, readonly messageId: number, readonly notes?: Maybe<string>, readonly resolution?: Maybe<string>, readonly resolved_at?: Maybe<any>, readonly type: Chat_FlagType_Enum, readonly updated_at: any, readonly created_at: any };

export type ChatReactionDataFragment = { readonly __typename?: 'chat_Reaction', readonly data: any, readonly id: number, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum };

export type ChatMessageDataFragment = { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageId?: Maybe<number>, readonly id: number, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly reactions: ReadonlyArray<(
    { readonly __typename?: 'chat_Reaction' }
    & ChatReactionDataFragment
  )> };

export type SubscribedChatReactionDataFragment = { readonly __typename?: 'chat_Reaction', readonly data: any, readonly id: number, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageId: number };

export type SubscribedChatMessageDataFragment = { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageId?: Maybe<number>, readonly id: number, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any };

export type SelectFirstMessagesPageQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  maxCount: Scalars['Int'];
}>;


export type SelectFirstMessagesPageQuery = { readonly __typename?: 'query_root', readonly chat_Message: ReadonlyArray<(
    { readonly __typename?: 'chat_Message' }
    & ChatMessageDataFragment
  )> };

export type SelectMessagesPageQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  startAtIndex: Scalars['Int'];
  maxCount: Scalars['Int'];
}>;


export type SelectMessagesPageQuery = { readonly __typename?: 'query_root', readonly chat_Message: ReadonlyArray<(
    { readonly __typename?: 'chat_Message' }
    & ChatMessageDataFragment
  )> };

export type SelectSingleMessageQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type SelectSingleMessageQuery = { readonly __typename?: 'query_root', readonly chat_Message_by_pk?: Maybe<(
    { readonly __typename?: 'chat_Message' }
    & ChatMessageDataFragment
  )> };

export type DeleteMessageMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type DeleteMessageMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Message_by_pk?: Maybe<{ readonly __typename?: 'chat_Message', readonly id: number }> };

export type NextMessageSubscriptionVariables = Exact<{
  prevId: Scalars['Int'];
  chatId: Scalars['uuid'];
}>;


export type NextMessageSubscription = { readonly __typename?: 'subscription_root', readonly chat_Message: ReadonlyArray<(
    { readonly __typename?: 'chat_Message' }
    & SubscribedChatMessageDataFragment
  )> };

export type NextReactionsSubscriptionVariables = Exact<{
  messageIds: ReadonlyArray<Scalars['Int']>;
}>;


export type NextReactionsSubscription = { readonly __typename?: 'subscription_root', readonly chat_Reaction: ReadonlyArray<(
    { readonly __typename?: 'chat_Reaction' }
    & SubscribedChatReactionDataFragment
  )> };

export type PinDataFragment = { readonly __typename?: 'chat_Pin', readonly chatId: any, readonly attendeeId: any, readonly wasManuallyPinned: boolean };

export type ChatPinConfigFragment = { readonly __typename?: 'chat_Chat', readonly id: any, readonly enableAutoPin: boolean, readonly enableMandatoryPin: boolean };

export type SelectPinQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type SelectPinQuery = { readonly __typename?: 'query_root', readonly chat_Chat_by_pk?: Maybe<(
    { readonly __typename?: 'chat_Chat' }
    & ChatPinConfigFragment
  )>, readonly chat_Pin: ReadonlyArray<(
    { readonly __typename?: 'chat_Pin' }
    & PinDataFragment
  )> };

export type PinChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type PinChatMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Pin?: Maybe<{ readonly __typename?: 'chat_Pin_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'chat_Pin' }
      & PinDataFragment
    )> }> };

export type UnpinChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type UnpinChatMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Pin_by_pk?: Maybe<(
    { readonly __typename?: 'chat_Pin' }
    & PinDataFragment
  )> };

export type SubscriptionDataFragment = { readonly __typename?: 'chat_Subscription', readonly chatId: any, readonly attendeeId: any, readonly wasManuallySubscribed: boolean };

export type ChatSubscriptionConfigFragment = { readonly __typename?: 'chat_Chat', readonly id: any, readonly enableAutoSubscribe: boolean, readonly enableMandatorySubscribe: boolean };

export type SelectSubscriptionQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type SelectSubscriptionQuery = { readonly __typename?: 'query_root', readonly chat_Chat_by_pk?: Maybe<(
    { readonly __typename?: 'chat_Chat' }
    & ChatSubscriptionConfigFragment
  )>, readonly chat_Subscription: ReadonlyArray<(
    { readonly __typename?: 'chat_Subscription' }
    & SubscriptionDataFragment
  )> };

export type SubscribeChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type SubscribeChatMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Subscription?: Maybe<{ readonly __typename?: 'chat_Subscription_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'chat_Subscription' }
      & SubscriptionDataFragment
    )> }>, readonly insert_chat_ReadUpToIndex?: Maybe<{ readonly __typename?: 'chat_ReadUpToIndex_mutation_response', readonly affected_rows: number }> };

export type UnsubscribeChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type UnsubscribeChatMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Subscription_by_pk?: Maybe<(
    { readonly __typename?: 'chat_Subscription' }
    & SubscriptionDataFragment
  )> };

export type SelectAttendeesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAttendeesQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type SearchAttendeesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type SearchAttendeesQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type ConferenceLandingPageContentGroupQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferenceLandingPageContentGroupQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupDataFragment
  )> };

export type ContentPersonDataFragment = { readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'ContentPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string> } };

export type ContentGroupList_ContentPersonDataFragment = { readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'ContentPerson', readonly id: any, readonly affiliation?: Maybe<string>, readonly name: string } };

export type ContentGroupList_ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentGroupList_ContentPersonDataFragment
  )> };

export type ContentGroupList_ContentGroupTagDataFragment = { readonly __typename?: 'ContentGroupTag', readonly contentGroup: (
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupList_ContentGroupDataFragment
  ) };

export type ContentGroupList_TagInfoFragment = { readonly __typename?: 'Tag', readonly id: any, readonly colour: string, readonly name: string };

export type ContentOfTagQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type ContentOfTagQuery = { readonly __typename?: 'query_root', readonly ContentGroupTag: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupTag' }
    & ContentGroupList_ContentGroupTagDataFragment
  )> };

export type TagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type TagsQuery = { readonly __typename?: 'query_root', readonly Tag: ReadonlyArray<(
    { readonly __typename?: 'Tag' }
    & ContentGroupList_TagInfoFragment
  )> };

export type GetContentGroupQueryVariables = Exact<{
  contentGroupId: Scalars['uuid'];
}>;


export type GetContentGroupQuery = { readonly __typename?: 'query_root', readonly ContentGroup_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupDataFragment
    & ContentGroupEventsFragment
    & ContentGroupPage_ContentGroupRoomsFragment
  )> };

export type ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly contentGroupTypeName: ContentGroupType_Enum, readonly chatId?: Maybe<any>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly room: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any, readonly name: string }> }>, readonly contentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & ContentItemDataFragment
  )>, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentPersonDataFragment
  )> };

export type ContentGroupPage_ContentGroupRoomsFragment = { readonly __typename?: 'ContentGroup', readonly rooms: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> };

export type ContentGroupEventsFragment = { readonly __typename?: 'ContentGroup', readonly events: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & ContentGroupEventFragment
  )> };

export type ContentGroupEventFragment = { readonly __typename?: 'Event', readonly startTime: any, readonly id: any, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly name: string, readonly intendedRoomModeName: RoomMode_Enum, readonly room: { readonly __typename?: 'Room', readonly name: string, readonly id: any } };

export type ContentGroup_CreateRoomMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  contentGroupId: Scalars['uuid'];
}>;


export type ContentGroup_CreateRoomMutation = { readonly __typename?: 'mutation_root', readonly createContentGroupRoom?: Maybe<{ readonly __typename?: 'CreateContentGroupRoomOutput', readonly roomId?: Maybe<string>, readonly message?: Maybe<string> }> };

export type ContentGroupSummary_GetContentGroupQueryVariables = Exact<{
  contentGroupId: Scalars['uuid'];
}>;


export type ContentGroupSummary_GetContentGroupQuery = { readonly __typename?: 'query_root', readonly ContentGroup_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupSummary_ContentGroupDataFragment
  )> };

export type ContentGroupSummary_ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly contentGroupTypeName: ContentGroupType_Enum, readonly chatId?: Maybe<any>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly room: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any, readonly name: string }> }>, readonly contentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & ContentItemDataFragment
  )>, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentPersonDataFragment
  )> };

export type ContentItemDataFragment = { readonly __typename?: 'ContentItem', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly contentTypeName: ContentType_Enum };

export type Timeline_EventPersonFragment = { readonly __typename?: 'EventPerson', readonly id: any, readonly attendeeId?: Maybe<any>, readonly name: string, readonly affiliation?: Maybe<string>, readonly roleName: EventPersonRole_Enum };

export type UpdateAttendeeProfileMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  profile?: Maybe<AttendeeProfile_Set_Input>;
}>;


export type UpdateAttendeeProfileMutation = { readonly __typename?: 'mutation_root', readonly update_AttendeeProfile_by_pk?: Maybe<{ readonly __typename?: 'AttendeeProfile', readonly attendeeId: any }> };

export type UpdateAttendeeDisplayNameMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  name: Scalars['String'];
}>;


export type UpdateAttendeeDisplayNameMutation = { readonly __typename?: 'mutation_root', readonly update_Attendee_by_pk?: Maybe<{ readonly __typename?: 'Attendee', readonly id: any }> };

export type SubmitProfilePhotoMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  s3URL: Scalars['String'];
}>;


export type SubmitProfilePhotoMutation = { readonly __typename?: 'mutation_root', readonly updateProfilePhoto?: Maybe<{ readonly __typename?: 'UpdateProfilePhotoResponse', readonly ok: boolean }> };

export type GetRoomVonageTokenMutationVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomVonageTokenMutation = { readonly __typename?: 'mutation_root', readonly joinRoomVonageSession?: Maybe<{ readonly __typename?: 'JoinRoomVonageSessionOutput', readonly accessToken?: Maybe<string>, readonly sessionId?: Maybe<string> }> };

export type CreateDmMutationVariables = Exact<{
  attendeeIds: ReadonlyArray<Maybe<Scalars['uuid']>>;
  conferenceId: Scalars['uuid'];
}>;


export type CreateDmMutation = { readonly __typename?: 'mutation_root', readonly createRoomDm?: Maybe<{ readonly __typename?: 'CreateRoomDmOutput', readonly message?: Maybe<string>, readonly roomId?: Maybe<any> }> };

export type AttendeeCreateRoomMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  name: Scalars['String'];
  roomPrivacyName: RoomPrivacy_Enum;
}>;


export type AttendeeCreateRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_Room_one?: Maybe<{ readonly __typename?: 'Room', readonly id: any }> };

export type UpdateEventVonageSessionLayoutMutationVariables = Exact<{
  eventVonageSessionId: Scalars['uuid'];
  layoutData: Scalars['jsonb'];
}>;


export type UpdateEventVonageSessionLayoutMutation = { readonly __typename?: 'mutation_root', readonly update_EventVonageSession_by_pk?: Maybe<{ readonly __typename?: 'EventVonageSession', readonly id: any }> };

export type DeleteEventPersonMutationVariables = Exact<{
  eventPersonId: Scalars['uuid'];
}>;


export type DeleteEventPersonMutation = { readonly __typename?: 'mutation_root', readonly delete_EventPerson_by_pk?: Maybe<{ readonly __typename?: 'EventPerson', readonly id: any }> };

export type GetEventParticipantStreamsSubscriptionVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventParticipantStreamsSubscription = { readonly __typename?: 'subscription_root', readonly EventParticipantStream: ReadonlyArray<(
    { readonly __typename?: 'EventParticipantStream' }
    & EventParticipantStreamDetailsFragment
  )> };

export type EventParticipantStreamDetailsFragment = { readonly __typename?: 'EventParticipantStream', readonly id: any, readonly conferenceId: any, readonly eventId: any, readonly vonageStreamType: string, readonly vonageStreamId: string, readonly attendeeId: any, readonly attendee: { readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string } };

export type UnapprovedEventRoomJoinRequestsSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
  eventId: Scalars['uuid'];
}>;


export type UnapprovedEventRoomJoinRequestsSubscription = { readonly __typename?: 'subscription_root', readonly EventRoomJoinRequest: ReadonlyArray<(
    { readonly __typename?: 'EventRoomJoinRequest' }
    & EventRoomJoinRequestDetailsFragment
  )> };

export type EventRoomJoinRequestDetailsFragment = { readonly __typename?: 'EventRoomJoinRequest', readonly id: any, readonly attendeeId: any };

export type GetEventVonageTokenMutationVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventVonageTokenMutation = { readonly __typename?: 'mutation_root', readonly joinEventVonageSession?: Maybe<{ readonly __typename?: 'JoinEventVonageSessionOutput', readonly accessToken?: Maybe<string> }> };

export type GetEventDetailsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventDetailsQuery = { readonly __typename?: 'query_root', readonly Event_by_pk?: Maybe<(
    { readonly __typename?: 'Event' }
    & RoomEventDetailsFragment
  )> };

export type RoomEventDetailsFragment = { readonly __typename?: 'Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: RoomMode_Enum, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'EventVonageSession', readonly id: any, readonly sessionId: string }> };

export type ApproveEventRoomJoinRequestMutationVariables = Exact<{
  eventRoomJoinRequestId: Scalars['uuid'];
}>;


export type ApproveEventRoomJoinRequestMutation = { readonly __typename?: 'mutation_root', readonly update_EventRoomJoinRequest_by_pk?: Maybe<{ readonly __typename?: 'EventRoomJoinRequest', readonly id: any }> };

export type GetBreakoutRoomFromEventQueryVariables = Exact<{
  originatingEventId: Scalars['uuid'];
}>;


export type GetBreakoutRoomFromEventQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> };

export type MakeEventRoomJoinRequestMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
  eventId: Scalars['uuid'];
}>;


export type MakeEventRoomJoinRequestMutation = { readonly __typename?: 'mutation_root', readonly insert_EventRoomJoinRequest_one?: Maybe<{ readonly __typename?: 'EventRoomJoinRequest', readonly id: any }> };

export type MyEventRoomJoinRequestSubscriptionVariables = Exact<{
  attendeeId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
  eventId: Scalars['uuid'];
}>;


export type MyEventRoomJoinRequestSubscription = { readonly __typename?: 'subscription_root', readonly EventRoomJoinRequest: ReadonlyArray<{ readonly __typename?: 'EventRoomJoinRequest', readonly id: any, readonly approved: boolean }> };

export type Room_GetCurrentEventQueryVariables = Exact<{
  currentEventId: Scalars['uuid'];
}>;


export type Room_GetCurrentEventQuery = { readonly __typename?: 'query_root', readonly Event_by_pk?: Maybe<(
    { readonly __typename?: 'Event' }
    & Room_CurrentEventSummaryFragment
  )> };

export type Room_CurrentEventSummaryFragment = { readonly __typename?: 'Event', readonly id: any, readonly contentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly contentGroupTypeName: ContentGroupType_Enum, readonly chatId?: Maybe<any>, readonly contentItems: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly data: any }> }> };

export type Room_GetEventsQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type Room_GetEventsQuery = { readonly __typename?: 'query_root', readonly Event: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & Room_EventSummaryFragment
  )> };

export type Room_EventSummaryFragment = { readonly __typename?: 'Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: RoomMode_Enum, readonly contentGroupId?: Maybe<any>, readonly contentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string }> };

export type RoomBackstage_GetEventBreakoutRoomQueryVariables = Exact<{
  originatingEventId: Scalars['uuid'];
}>;


export type RoomBackstage_GetEventBreakoutRoomQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> };

export type AddParticipantToRoomMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  roomId: Scalars['uuid'];
}>;


export type AddParticipantToRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_RoomPerson_one?: Maybe<{ readonly __typename?: 'RoomPerson', readonly id: any }> };

export type GetAllRoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetAllRoomsQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomListRoomDetailsFragment
  )> };

export type RoomListRoomDetailsFragment = { readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly roomPrivacyName: RoomPrivacy_Enum, readonly originatingContentGroupId?: Maybe<any>, readonly originatingEventId?: Maybe<any> };

export type RoomPage_GetRoomDetailsQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type RoomPage_GetRoomDetailsQuery = { readonly __typename?: 'query_root', readonly Room_by_pk?: Maybe<(
    { readonly __typename?: 'Room' }
    & RoomPage_RoomDetailsFragment
  )> };

export type RoomPage_RoomDetailsFragment = (
  { readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly currentModeName: RoomMode_Enum, readonly publicVonageSessionId?: Maybe<string>, readonly chatId?: Maybe<any>, readonly roomPrivacyName: RoomPrivacy_Enum, readonly mediaLiveChannel?: Maybe<{ readonly __typename?: 'MediaLiveChannel', readonly cloudFrontDomain: string, readonly endpointUri: string, readonly id: any }>, readonly originatingContentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly contentGroupTypeName: ContentGroupType_Enum, readonly title: string, readonly contentItems: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly data: any }> }>, readonly shuffleRooms: ReadonlyArray<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly durationMinutes: number, readonly reshuffleUponEnd: boolean }> }
  & RoomPage_RoomPeopleFragment
);

export type RoomPage_RoomPeopleFragment = { readonly __typename?: 'Room', readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'RoomPerson', readonly id: any, readonly roomPersonRoleName: RoomPersonRole_Enum, readonly attendeeId: any }> };

export type GetEventVonageDetailsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventVonageDetailsQuery = { readonly __typename?: 'query_root', readonly Event_by_pk?: Maybe<{ readonly __typename?: 'Event', readonly id: any, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'EventVonageSession', readonly sessionId: string, readonly id: any }> }> };

export type RoomSponsorContent_GetContentItemsQueryVariables = Exact<{
  contentGroupId: Scalars['uuid'];
}>;


export type RoomSponsorContent_GetContentItemsQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & RoomSponsorContent_ContentGroupDataFragment
  )> };

export type RoomSponsorContent_ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly contentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & RoomSponsorContent_ContentItemDataFragment
  )> };

export type RoomSponsorContent_ContentItemDataFragment = { readonly __typename?: 'ContentItem', readonly id: any, readonly name: string, readonly contentTypeName: ContentType_Enum, readonly data: any, readonly layoutData?: Maybe<any> };

export type VonageSubscriber_GetAttendeeQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type VonageSubscriber_GetAttendeeQuery = { readonly __typename?: 'query_root', readonly Attendee_by_pk?: Maybe<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type Timeline_ContentItemFragment = { readonly __typename?: 'ContentItem', readonly id: any, readonly contentTypeName: ContentType_Enum, readonly name: string, readonly isHidden: boolean, readonly layoutData?: Maybe<any> };

export type Timeline_ContentItem_WithDataFragment = (
  { readonly __typename?: 'ContentItem', readonly data: any }
  & Timeline_ContentItemFragment
);

export type Timeline_ContentPersonFragment = { readonly __typename?: 'ContentPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string> };

export type Timeline_ContentGroupPersonFragment = { readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person: (
    { readonly __typename?: 'ContentPerson' }
    & Timeline_ContentPersonFragment
  ) };

export type Timeline_ContentGroupFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly contentGroupTypeName: ContentGroupType_Enum, readonly title: string, readonly abstractContentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & Timeline_ContentItem_WithDataFragment
  )>, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & Timeline_ContentGroupPersonFragment
  )> };

export type Timeline_Event_FullInfoFragment = { readonly __typename?: 'Event', readonly id: any, readonly roomId: any, readonly intendedRoomModeName: RoomMode_Enum, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly contentGroup?: Maybe<(
    { readonly __typename?: 'ContentGroup' }
    & Timeline_ContentGroupFragment
  )> };

export type Timeline_EventFragment = { readonly __typename?: 'Event', readonly id: any, readonly roomId: any, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly contentGroupId?: Maybe<any> };

export type Timeline_RoomFragment = { readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly currentModeName: RoomMode_Enum, readonly priority: number };

export type Timeline_ContentGroup_PartialInfoFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string };

export type Timeline_SelectEventQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type Timeline_SelectEventQuery = { readonly __typename?: 'query_root', readonly Event_by_pk?: Maybe<(
    { readonly __typename?: 'Event' }
    & Timeline_Event_FullInfoFragment
  )> };

export type Timeline_SelectRoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type Timeline_SelectRoomsQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & Timeline_RoomFragment
  )>, readonly Event: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & Timeline_EventFragment
  )>, readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & Timeline_ContentGroup_PartialInfoFragment
  )> };

export type Timeline_TagFragment = { readonly __typename?: 'Tag', readonly id: any, readonly name: string, readonly colour: string };

export type Timeline_EventTagFragment = { readonly __typename?: 'EventTag', readonly id: any, readonly tag: (
    { readonly __typename?: 'Tag' }
    & Timeline_TagFragment
  ) };

export type AttendeesByIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  attendeeIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type AttendeesByIdQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type InsertSubmissionRequestEmailJobsMutationVariables = Exact<{
  objs: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input>;
}>;


export type InsertSubmissionRequestEmailJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_SubmissionRequestEmailJob?: Maybe<{ readonly __typename?: 'job_queues_SubmissionRequestEmailJob_mutation_response', readonly affected_rows: number }> };

export type UploaderInfoFragment = { readonly __typename?: 'Uploader', readonly id: any, readonly conferenceId: any, readonly email: string, readonly emailsSentCount: number, readonly name: string, readonly requiredContentItemId: any };

export type RequiredContentItemInfoFragment = { readonly __typename?: 'RequiredContentItem', readonly id: any, readonly name: string, readonly isHidden: boolean, readonly contentTypeName: ContentType_Enum, readonly conferenceId: any, readonly contentGroupId: any, readonly uploadsRemaining?: Maybe<number>, readonly originatingDataId?: Maybe<any>, readonly uploaders: ReadonlyArray<(
    { readonly __typename?: 'Uploader' }
    & UploaderInfoFragment
  )> };

export type ContentItemInfoFragment = { readonly __typename?: 'ContentItem', readonly conferenceId: any, readonly contentGroupId: any, readonly contentTypeName: ContentType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly requiredContentId?: Maybe<any>, readonly originatingDataId?: Maybe<any> };

export type OriginatingDataInfoFragment = { readonly __typename?: 'OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> };

export type ContentPersonInfoFragment = { readonly __typename?: 'ContentPerson', readonly id: any, readonly conferenceId: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any> };

export type ContentGroupTagInfoFragment = { readonly __typename?: 'ContentGroupTag', readonly id: any, readonly tagId: any, readonly contentGroupId: any };

export type ContentGroupHallwayInfoFragment = { readonly __typename?: 'ContentGroupHallway', readonly id: any, readonly groupId: any, readonly hallwayId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> };

export type ContentGroupPersonInfoFragment = { readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly conferenceId: any, readonly groupId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string };

export type ContentGroupFullNestedInfoFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly conferenceId: any, readonly contentGroupTypeName: ContentGroupType_Enum, readonly title: string, readonly shortTitle?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly requiredContentItems: ReadonlyArray<(
    { readonly __typename?: 'RequiredContentItem' }
    & RequiredContentItemInfoFragment
  )>, readonly contentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & ContentItemInfoFragment
  )>, readonly contentGroupTags: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupTag' }
    & ContentGroupTagInfoFragment
  )>, readonly hallways: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupHallway' }
    & ContentGroupHallwayInfoFragment
  )>, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentGroupPersonInfoFragment
  )> };

export type TagInfoFragment = { readonly __typename?: 'Tag', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly originatingDataId?: Maybe<any> };

export type HallwayInfoFragment = { readonly __typename?: 'Hallway', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly priority: number };

export type SelectAllContentQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllContentQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupFullNestedInfoFragment
  )>, readonly ContentPerson: ReadonlyArray<(
    { readonly __typename?: 'ContentPerson' }
    & ContentPersonInfoFragment
  )>, readonly OriginatingData: ReadonlyArray<(
    { readonly __typename?: 'OriginatingData' }
    & OriginatingDataInfoFragment
  )>, readonly Tag: ReadonlyArray<(
    { readonly __typename?: 'Tag' }
    & TagInfoFragment
  )>, readonly Hallway: ReadonlyArray<(
    { readonly __typename?: 'Hallway' }
    & HallwayInfoFragment
  )> };

export type InsertDeleteContentGroupsMutationVariables = Exact<{
  newGroups: ReadonlyArray<ContentGroup_Insert_Input>;
  deleteGroupIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type InsertDeleteContentGroupsMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentGroup?: Maybe<{ readonly __typename?: 'ContentGroup_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroup' }
      & ContentGroupFullNestedInfoFragment
    )> }>, readonly delete_ContentGroup?: Maybe<{ readonly __typename?: 'ContentGroup_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentGroup', readonly id: any }> }> };

export type InsertOriginatingDatasMutationVariables = Exact<{
  newDatas: ReadonlyArray<OriginatingData_Insert_Input>;
}>;


export type InsertOriginatingDatasMutation = { readonly __typename?: 'mutation_root', readonly insert_OriginatingData?: Maybe<{ readonly __typename?: 'OriginatingData_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'OriginatingData' }
      & OriginatingDataInfoFragment
    )> }> };

export type DeleteOriginatingDatasMutationVariables = Exact<{
  deleteDataIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type DeleteOriginatingDatasMutation = { readonly __typename?: 'mutation_root', readonly delete_OriginatingData?: Maybe<{ readonly __typename?: 'OriginatingData_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'OriginatingData', readonly id: any }> }> };

export type InsertTagsMutationVariables = Exact<{
  newTags: ReadonlyArray<Tag_Insert_Input>;
}>;


export type InsertTagsMutation = { readonly __typename?: 'mutation_root', readonly insert_Tag?: Maybe<{ readonly __typename?: 'Tag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Tag' }
      & TagInfoFragment
    )> }> };

export type InsertHallwaysMutationVariables = Exact<{
  newHallways: ReadonlyArray<Hallway_Insert_Input>;
}>;


export type InsertHallwaysMutation = { readonly __typename?: 'mutation_root', readonly insert_Hallway?: Maybe<{ readonly __typename?: 'Hallway_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Hallway' }
      & HallwayInfoFragment
    )> }> };

export type DeleteTagsMutationVariables = Exact<{
  deleteTagIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type DeleteTagsMutation = { readonly __typename?: 'mutation_root', readonly delete_Tag?: Maybe<{ readonly __typename?: 'Tag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Tag', readonly id: any }> }> };

export type DeleteHallwaysMutationVariables = Exact<{
  deleteHallwayIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type DeleteHallwaysMutation = { readonly __typename?: 'mutation_root', readonly delete_Hallway?: Maybe<{ readonly __typename?: 'Hallway_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Hallway', readonly id: any }> }> };

export type InsertContentPeopleMutationVariables = Exact<{
  newPeople: ReadonlyArray<ContentPerson_Insert_Input>;
}>;


export type InsertContentPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentPerson?: Maybe<{ readonly __typename?: 'ContentPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentPerson' }
      & ContentPersonInfoFragment
    )> }> };

export type DeleteContentPeopleMutationVariables = Exact<{
  deletePersonIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type DeleteContentPeopleMutation = { readonly __typename?: 'mutation_root', readonly delete_ContentPerson?: Maybe<{ readonly __typename?: 'ContentPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentPerson', readonly id: any }> }> };

export type UpdateContentGroupMutationVariables = Exact<{
  newItems: ReadonlyArray<ContentItem_Insert_Input>;
  newRequiredItems: ReadonlyArray<RequiredContentItem_Insert_Input>;
  newGroupTags: ReadonlyArray<ContentGroupTag_Insert_Input>;
  newGroupHallways: ReadonlyArray<ContentGroupHallway_Insert_Input>;
  groupId: Scalars['uuid'];
  contentGroupTypeName: ContentGroupType_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  shortTitle?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  deleteItemIds: ReadonlyArray<Scalars['uuid']>;
  deleteRequiredItemIds: ReadonlyArray<Scalars['uuid']>;
  deleteGroupTagIds: ReadonlyArray<Scalars['uuid']>;
  deleteGroupHallwayIds: ReadonlyArray<Scalars['uuid']>;
  newUploaders: ReadonlyArray<Uploader_Insert_Input>;
  deleteUploaderIds: ReadonlyArray<Scalars['uuid']>;
  newGroupPeople: ReadonlyArray<ContentGroupPerson_Insert_Input>;
  deleteGroupPeopleIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type UpdateContentGroupMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentItem?: Maybe<{ readonly __typename?: 'ContentItem_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentItem' }
      & ContentItemInfoFragment
    )> }>, readonly insert_RequiredContentItem?: Maybe<{ readonly __typename?: 'RequiredContentItem_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'RequiredContentItem' }
      & RequiredContentItemInfoFragment
    )> }>, readonly insert_ContentGroupTag?: Maybe<{ readonly __typename?: 'ContentGroupTag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroupTag' }
      & ContentGroupTagInfoFragment
    )> }>, readonly insert_ContentGroupHallway?: Maybe<{ readonly __typename?: 'ContentGroupHallway_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroupHallway' }
      & ContentGroupHallwayInfoFragment
    )> }>, readonly insert_Uploader?: Maybe<{ readonly __typename?: 'Uploader_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Uploader' }
      & UploaderInfoFragment
    )> }>, readonly insert_ContentGroupPerson?: Maybe<{ readonly __typename?: 'ContentGroupPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroupPerson' }
      & ContentGroupPersonInfoFragment
    )> }>, readonly update_ContentGroup_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupFullNestedInfoFragment
  )>, readonly delete_ContentItem?: Maybe<{ readonly __typename?: 'ContentItem_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any }> }>, readonly delete_RequiredContentItem?: Maybe<{ readonly __typename?: 'RequiredContentItem_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'RequiredContentItem', readonly id: any }> }>, readonly delete_ContentGroupTag?: Maybe<{ readonly __typename?: 'ContentGroupTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentGroupTag', readonly id: any }> }>, readonly delete_ContentGroupHallway?: Maybe<{ readonly __typename?: 'ContentGroupHallway_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentGroupHallway', readonly id: any }> }>, readonly delete_Uploader?: Maybe<{ readonly __typename?: 'Uploader_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Uploader', readonly id: any }> }>, readonly delete_ContentGroupPerson?: Maybe<{ readonly __typename?: 'ContentGroupPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentGroupPerson', readonly id: any }> }> };

export type UpdateContentItemMutationVariables = Exact<{
  id: Scalars['uuid'];
  contentTypeName: ContentType_Enum;
  layoutData?: Maybe<Scalars['jsonb']>;
  name: Scalars['String'];
  data: Scalars['jsonb'];
  isHidden: Scalars['Boolean'];
  originatingDataId?: Maybe<Scalars['uuid']>;
  requiredContentId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateContentItemMutation = { readonly __typename?: 'mutation_root', readonly update_ContentItem_by_pk?: Maybe<(
    { readonly __typename?: 'ContentItem' }
    & ContentItemInfoFragment
  )> };

export type UpdateRequiredContentItemMutationVariables = Exact<{
  id: Scalars['uuid'];
  contentTypeName: ContentType_Enum;
  name: Scalars['String'];
  isHidden: Scalars['Boolean'];
  uploadsRemaining?: Maybe<Scalars['Int']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateRequiredContentItemMutation = { readonly __typename?: 'mutation_root', readonly update_RequiredContentItem_by_pk?: Maybe<(
    { readonly __typename?: 'RequiredContentItem' }
    & RequiredContentItemInfoFragment
  )> };

export type UpdateUploaderMutationVariables = Exact<{
  id: Scalars['uuid'];
  email: Scalars['String'];
  name: Scalars['String'];
}>;


export type UpdateUploaderMutation = { readonly __typename?: 'mutation_root', readonly update_Uploader_by_pk?: Maybe<(
    { readonly __typename?: 'Uploader' }
    & UploaderInfoFragment
  )> };

export type UpdateGroupPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  roleName: Scalars['String'];
  priority?: Maybe<Scalars['Int']>;
}>;


export type UpdateGroupPersonMutation = { readonly __typename?: 'mutation_root', readonly update_ContentGroupPerson_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentGroupPersonInfoFragment
  )> };

export type UpdateGroupHallwayMutationVariables = Exact<{
  id: Scalars['uuid'];
  priority?: Maybe<Scalars['Int']>;
  layout?: Maybe<Scalars['jsonb']>;
}>;


export type UpdateGroupHallwayMutation = { readonly __typename?: 'mutation_root', readonly update_ContentGroupHallway_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroupHallway' }
    & ContentGroupHallwayInfoFragment
  )> };

export type UpdatePersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  affiliation?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
}>;


export type UpdatePersonMutation = { readonly __typename?: 'mutation_root', readonly update_ContentPerson_by_pk?: Maybe<(
    { readonly __typename?: 'ContentPerson' }
    & ContentPersonInfoFragment
  )> };

export type UpdateTagMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  colour: Scalars['String'];
  originatingDataId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateTagMutation = { readonly __typename?: 'mutation_root', readonly update_Tag_by_pk?: Maybe<(
    { readonly __typename?: 'Tag' }
    & TagInfoFragment
  )> };

export type UpdateHallwayMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  colour: Scalars['String'];
  priority: Scalars['Int'];
}>;


export type UpdateHallwayMutation = { readonly __typename?: 'mutation_root', readonly update_Hallway_by_pk?: Maybe<(
    { readonly __typename?: 'Hallway' }
    & HallwayInfoFragment
  )> };

export type ImportAttendeesMutationVariables = Exact<{
  insertAttendees: ReadonlyArray<Attendee_Insert_Input>;
  insertInvitations: ReadonlyArray<Invitation_Insert_Input>;
}>;


export type ImportAttendeesMutation = { readonly __typename?: 'mutation_root', readonly insert_Attendee?: Maybe<{ readonly __typename?: 'Attendee_mutation_response', readonly affected_rows: number }>, readonly insert_Invitation?: Maybe<{ readonly __typename?: 'Invitation_mutation_response', readonly affected_rows: number }> };

export type CreateConferencePrepareJobMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateConferencePrepareJobMutation = { readonly __typename?: 'mutation_root', readonly insert_ConferencePrepareJob_one?: Maybe<{ readonly __typename?: 'ConferencePrepareJob', readonly id: any, readonly conferenceId: any }> };

export type ConferencePrepareJobSubscriptionSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferencePrepareJobSubscriptionSubscription = { readonly __typename?: 'subscription_root', readonly ConferencePrepareJob: ReadonlyArray<{ readonly __typename?: 'ConferencePrepareJob', readonly id: any, readonly jobStatusName: JobStatus_Enum, readonly message?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly videoRenderJobs: ReadonlyArray<{ readonly __typename?: 'VideoRenderJob', readonly id: any, readonly jobStatusName: JobStatus_Enum, readonly updated_at: any, readonly created_at: any }> }> };

export type GetMediaLiveChannelsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetMediaLiveChannelsQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<{ readonly __typename?: 'Room', readonly name: string, readonly id: any, readonly mediaLiveChannel?: Maybe<{ readonly __typename?: 'MediaLiveChannel', readonly cloudFrontDomain: string, readonly endpointUri: string, readonly id: any }> }> };

export type EventVonageControls_GetEventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type EventVonageControls_GetEventsQuery = { readonly __typename?: 'query_root', readonly Event: ReadonlyArray<{ readonly __typename?: 'Event', readonly id: any, readonly name: string, readonly contentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string }> }> };

export type EventVonageControls_StopEventBroadcastMutationVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type EventVonageControls_StopEventBroadcastMutation = { readonly __typename?: 'mutation_root', readonly stopEventBroadcast?: Maybe<{ readonly __typename?: 'StopEventBroadcastOutput', readonly broadcastsStopped: number }> };

export type ManageConferenceExportPage_GetVideoFilesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageConferenceExportPage_GetVideoFilesQuery = { readonly __typename?: 'query_root', readonly ContentItem: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & ManageConferenceExportPage_ContentItemDataFragment
  )> };

export type ManageConferenceExportPage_ContentItemDataFragment = { readonly __typename?: 'ContentItem', readonly id: any, readonly data: any, readonly name: string, readonly contentGroup: { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string } };

export type SelectAllGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllGroupsQuery = { readonly __typename?: 'query_root', readonly Group: ReadonlyArray<{ readonly __typename?: 'Group', readonly conferenceId: any, readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any }> }> };

export type CreateDeleteGroupsMutationVariables = Exact<{
  deleteGroupIds?: Maybe<ReadonlyArray<Scalars['uuid']>>;
  insertGroups: ReadonlyArray<Group_Insert_Input>;
}>;


export type CreateDeleteGroupsMutation = { readonly __typename?: 'mutation_root', readonly delete_Group?: Maybe<{ readonly __typename?: 'Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any }> }>, readonly insert_Group?: Maybe<{ readonly __typename?: 'Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any, readonly conferenceId: any, readonly name: string, readonly enabled: boolean, readonly includeUnauthenticated: boolean, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }> }> };

export type UpdateGroupMutationVariables = Exact<{
  groupId: Scalars['uuid'];
  groupName: Scalars['String'];
  enabled: Scalars['Boolean'];
  includeUnauthenticated: Scalars['Boolean'];
  insertRoles: ReadonlyArray<GroupRole_Insert_Input>;
  deleteRoleIds?: Maybe<ReadonlyArray<Scalars['uuid']>>;
}>;


export type UpdateGroupMutation = { readonly __typename?: 'mutation_root', readonly update_Group?: Maybe<{ readonly __typename?: 'Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }> }>, readonly insert_GroupRole?: Maybe<{ readonly __typename?: 'GroupRole_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }>, readonly delete_GroupRole?: Maybe<{ readonly __typename?: 'GroupRole_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any }> }> };

export type UpdateConferenceMutationVariables = Exact<{
  id: Scalars['uuid'];
  name?: Maybe<Scalars['String']>;
  shortName?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
}>;


export type UpdateConferenceMutation = { readonly __typename?: 'mutation_root', readonly update_Conference?: Maybe<{ readonly __typename?: 'Conference_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }> }> };

export type AttendeePartsFragment = { readonly __typename?: 'Attendee', readonly conferenceId: any, readonly id: any, readonly userId?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly displayName: string, readonly inviteSent?: Maybe<boolean>, readonly groupAttendees: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly attendeeId: any, readonly id: any, readonly groupId: any }>, readonly invitation?: Maybe<{ readonly __typename?: 'Invitation', readonly attendeeId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> }> };

export type SelectAllAttendeesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllAttendeesQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeePartsFragment
  )> };

export type CreateDeleteAttendeesMutationVariables = Exact<{
  deleteAttendeeIds?: Maybe<ReadonlyArray<Scalars['uuid']>>;
  insertAttendees: ReadonlyArray<Attendee_Insert_Input>;
  insertInvitations: ReadonlyArray<Invitation_Insert_Input>;
}>;


export type CreateDeleteAttendeesMutation = { readonly __typename?: 'mutation_root', readonly delete_Attendee?: Maybe<{ readonly __typename?: 'Attendee_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Attendee', readonly id: any }> }>, readonly insert_Attendee?: Maybe<{ readonly __typename?: 'Attendee_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Attendee' }
      & AttendeePartsFragment
    )> }>, readonly insert_Invitation?: Maybe<{ readonly __typename?: 'Invitation_mutation_response', readonly affected_rows: number }> };

export type UpdateAttendeeMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  attendeeName: Scalars['String'];
  insertGroups: ReadonlyArray<GroupAttendee_Insert_Input>;
  deleteGroupIds?: Maybe<ReadonlyArray<Scalars['uuid']>>;
}>;


export type UpdateAttendeeMutation = { readonly __typename?: 'mutation_root', readonly update_Attendee_by_pk?: Maybe<(
    { readonly __typename?: 'Attendee' }
    & AttendeePartsFragment
  )>, readonly insert_GroupAttendee?: Maybe<{ readonly __typename?: 'GroupAttendee_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly id: any, readonly attendeeId: any, readonly groupId: any }> }>, readonly delete_GroupAttendee?: Maybe<{ readonly __typename?: 'GroupAttendee_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly id: any }> }> };

export type InsertInvitationEmailJobsMutationVariables = Exact<{
  attendeeIds: Scalars['jsonb'];
  conferenceId: Scalars['uuid'];
  sendRepeat: Scalars['Boolean'];
}>;


export type InsertInvitationEmailJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_InvitationEmailJob?: Maybe<{ readonly __typename?: 'job_queues_InvitationEmailJob_mutation_response', readonly affected_rows: number }> };

export type SelectAllPermissionsQueryVariables = Exact<{ [key: string]: never; }>;


export type SelectAllPermissionsQuery = { readonly __typename?: 'query_root', readonly Permission: ReadonlyArray<{ readonly __typename?: 'Permission', readonly name: string, readonly description: string }> };

export type SelectAllRolesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRolesQuery = { readonly __typename?: 'query_root', readonly Role: ReadonlyArray<{ readonly __typename?: 'Role', readonly conferenceId: any, readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum, readonly roleId: any }> }> };

export type CreateDeleteRolesMutationVariables = Exact<{
  deleteRoleIds?: Maybe<ReadonlyArray<Scalars['uuid']>>;
  insertRoles: ReadonlyArray<Role_Insert_Input>;
}>;


export type CreateDeleteRolesMutation = { readonly __typename?: 'mutation_root', readonly delete_Role?: Maybe<{ readonly __typename?: 'Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Role', readonly id: any }> }>, readonly insert_Role?: Maybe<{ readonly __typename?: 'Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Role', readonly id: any, readonly conferenceId: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum, readonly roleId: any }> }> }> };

export type UpdateRoleMutationVariables = Exact<{
  roleId: Scalars['uuid'];
  roleName: Scalars['String'];
  insertPermissions: ReadonlyArray<RolePermission_Insert_Input>;
  deletePermissionNames?: Maybe<ReadonlyArray<Permission_Enum>>;
}>;


export type UpdateRoleMutation = { readonly __typename?: 'mutation_root', readonly update_Role?: Maybe<{ readonly __typename?: 'Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum, readonly roleId: any }> }> }>, readonly insert_RolePermission?: Maybe<{ readonly __typename?: 'RolePermission_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum, readonly roleId: any }> }>, readonly delete_RolePermission?: Maybe<{ readonly __typename?: 'RolePermission_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any }> }> };

export type RoomParticipantWithAttendeeInfoFragment = { readonly __typename?: 'RoomParticipant', readonly id: any, readonly conferenceId: any, readonly attendeeId: any, readonly roomId: any, readonly attendee: { readonly __typename?: 'Attendee', readonly displayName: string } };

export type RoomWithParticipantInfoFragment = { readonly __typename?: 'Room', readonly id: any, readonly conferenceId: any, readonly name: string, readonly currentModeName: RoomMode_Enum, readonly capacity?: Maybe<number>, readonly priority: number, readonly participants: ReadonlyArray<(
    { readonly __typename?: 'RoomParticipant' }
    & RoomParticipantWithAttendeeInfoFragment
  )>, readonly originatingData?: Maybe<(
    { readonly __typename?: 'OriginatingData' }
    & OriginatingDataInfoFragment
  )> };

export type SelectAllRoomsWithParticipantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRoomsWithParticipantsQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomWithParticipantInfoFragment
  )> };

export type CreateRoomMutationVariables = Exact<{
  room: Room_Insert_Input;
}>;


export type CreateRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_Room?: Maybe<{ readonly __typename?: 'Room_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Room' }
      & RoomWithParticipantInfoFragment
    )> }> };

export type UpdateRoomsWithParticipantsMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  capacity: Scalars['Int'];
  priority: Scalars['Int'];
}>;


export type UpdateRoomsWithParticipantsMutation = { readonly __typename?: 'mutation_root', readonly update_Room_by_pk?: Maybe<(
    { readonly __typename?: 'Room' }
    & RoomWithParticipantInfoFragment
  )> };

export type RoomInfoFragment = { readonly __typename?: 'Room', readonly capacity?: Maybe<number>, readonly conferenceId: any, readonly currentModeName: RoomMode_Enum, readonly id: any, readonly name: string, readonly priority: number, readonly originatingDataId?: Maybe<any>, readonly originatingData?: Maybe<(
    { readonly __typename?: 'OriginatingData' }
    & OriginatingDataInfoFragment
  )>, readonly participants: ReadonlyArray<(
    { readonly __typename?: 'RoomParticipant' }
    & RoomParticipantInfoFragment
  )> };

export type RoomParticipantInfoFragment = { readonly __typename?: 'RoomParticipant', readonly attendeeId: any, readonly conferenceId: any, readonly id: any, readonly roomId: any };

export type EventInfoFragment = { readonly __typename?: 'Event', readonly conferenceId: any, readonly id: any, readonly durationSeconds: number, readonly intendedRoomModeName: RoomMode_Enum, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roomId: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly contentGroupId?: Maybe<any>, readonly eventPeople: ReadonlyArray<(
    { readonly __typename?: 'EventPerson' }
    & EventPersonInfoFragment
  )>, readonly eventTags: ReadonlyArray<(
    { readonly __typename?: 'EventTag' }
    & EventTagInfoFragment
  )> };

export type EventPersonInfoFragment = { readonly __typename?: 'EventPerson', readonly affiliation?: Maybe<string>, readonly attendeeId?: Maybe<any>, readonly conferenceId: any, readonly eventId: any, readonly id: any, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roleName: EventPersonRole_Enum, readonly attendee?: Maybe<{ readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string, readonly userId?: Maybe<string> }> };

export type EventTagInfoFragment = { readonly __typename?: 'EventTag', readonly eventId: any, readonly id: any, readonly tagId: any };

export type AttendeeInfoFragment = { readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string };

export type SelectWholeScheduleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectWholeScheduleQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomInfoFragment
  )>, readonly Event: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & EventInfoFragment
  )>, readonly OriginatingData: ReadonlyArray<(
    { readonly __typename?: 'OriginatingData' }
    & OriginatingDataInfoFragment
  )>, readonly Tag: ReadonlyArray<(
    { readonly __typename?: 'Tag' }
    & TagInfoFragment
  )>, readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupFullNestedInfoFragment
  )>, readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeInfoFragment
  )> };

export type InsertRoomsMutationVariables = Exact<{
  newRooms: ReadonlyArray<Room_Insert_Input>;
}>;


export type InsertRoomsMutation = { readonly __typename?: 'mutation_root', readonly insert_Room?: Maybe<{ readonly __typename?: 'Room_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Room' }
      & RoomInfoFragment
    )> }> };

export type DeleteRoomsMutationVariables = Exact<{
  deleteRoomIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type DeleteRoomsMutation = { readonly __typename?: 'mutation_root', readonly delete_Room?: Maybe<{ readonly __typename?: 'Room_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> }> };

export type UpdateRoomMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  capacity?: Maybe<Scalars['Int']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
  priority: Scalars['Int'];
}>;


export type UpdateRoomMutation = { readonly __typename?: 'mutation_root', readonly update_Room_by_pk?: Maybe<(
    { readonly __typename?: 'Room' }
    & RoomInfoFragment
  )> };

export type InsertDeleteEventsMutationVariables = Exact<{
  newEvents: ReadonlyArray<Event_Insert_Input>;
  deleteEventIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type InsertDeleteEventsMutation = { readonly __typename?: 'mutation_root', readonly insert_Event?: Maybe<{ readonly __typename?: 'Event_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Event' }
      & EventInfoFragment
    )> }>, readonly delete_Event?: Maybe<{ readonly __typename?: 'Event_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Event', readonly id: any }> }> };

export type UpdateEventMutationVariables = Exact<{
  eventId: Scalars['uuid'];
  roomId: Scalars['uuid'];
  intendedRoomModeName: RoomMode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  contentGroupId?: Maybe<Scalars['uuid']>;
  newEventTags: ReadonlyArray<EventTag_Insert_Input>;
  deleteEventTagIds: ReadonlyArray<Scalars['uuid']>;
  newEventPeople: ReadonlyArray<EventPerson_Insert_Input>;
  deleteEventPeopleIds: ReadonlyArray<Scalars['uuid']>;
}>;


export type UpdateEventMutation = { readonly __typename?: 'mutation_root', readonly insert_EventTag?: Maybe<{ readonly __typename?: 'EventTag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'EventTag' }
      & EventTagInfoFragment
    )> }>, readonly insert_EventPerson?: Maybe<{ readonly __typename?: 'EventPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'EventPerson' }
      & EventPersonInfoFragment
    )> }>, readonly update_Event_by_pk?: Maybe<(
    { readonly __typename?: 'Event' }
    & EventInfoFragment
  )>, readonly delete_EventTag?: Maybe<{ readonly __typename?: 'EventTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'EventTag', readonly id: any }> }>, readonly delete_EventPerson?: Maybe<{ readonly __typename?: 'EventPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'EventPerson', readonly id: any }> }> };

export type UpdateEventPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  attendeeId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  affiliation?: Maybe<Scalars['String']>;
  roleName: EventPersonRole_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateEventPersonMutation = { readonly __typename?: 'mutation_root', readonly update_EventPerson_by_pk?: Maybe<(
    { readonly __typename?: 'EventPerson' }
    & EventPersonInfoFragment
  )> };

export type ConferenceTakenQueryVariables = Exact<{
  name: Scalars['String'];
  shortName: Scalars['String'];
  slug: Scalars['String'];
}>;


export type ConferenceTakenQuery = { readonly __typename?: 'query_root', readonly Conference: ReadonlyArray<{ readonly __typename?: 'Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }> };

export type CreateConferenceMutationVariables = Exact<{
  name: Scalars['String'];
  shortName: Scalars['String'];
  slug: Scalars['String'];
  demoCode: Scalars['uuid'];
}>;


export type CreateConferenceMutation = { readonly __typename?: 'mutation_root', readonly insert_Conference?: Maybe<{ readonly __typename?: 'Conference_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Conference', readonly id: any, readonly slug: string }> }>, readonly update_ConferenceDemoCode?: Maybe<{ readonly __typename?: 'ConferenceDemoCode_mutation_response', readonly affected_rows: number }> };

export type CreateNewConferenceMetaStructureMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  attendeeDisplayName: Scalars['String'];
  userId: Scalars['String'];
  abstractData: Scalars['jsonb'];
  contentGroupListData: Scalars['jsonb'];
}>;


export type CreateNewConferenceMetaStructureMutation = { readonly __typename?: 'mutation_root', readonly insert_Attendee?: Maybe<{ readonly __typename?: 'Attendee_mutation_response', readonly affected_rows: number }>, readonly insert_Group?: Maybe<{ readonly __typename?: 'Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any, readonly conferenceId: any, readonly name: string, readonly enabled: boolean, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly roleId: any, readonly permissionName: Permission_Enum }> } }> }> }>, readonly insert_ContentGroup?: Maybe<{ readonly __typename?: 'ContentGroup_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroup' }
      & ContentGroupDataFragment
    )> }> };

export type ConferenceBySlugQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type ConferenceBySlugQuery = { readonly __typename?: 'query_root', readonly Conference: ReadonlyArray<{ readonly __typename?: 'Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }> };

export type GroupDataFragment = { readonly __typename?: 'Group', readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly permissionName: Permission_Enum, readonly id: any, readonly roleId: any }> } }> };

export type CurrentUserGroupsRolesPermissionsQueryVariables = Exact<{
  userId?: Maybe<Scalars['String']>;
  conferenceId: Scalars['uuid'];
}>;


export type CurrentUserGroupsRolesPermissionsQuery = { readonly __typename?: 'query_root', readonly User: ReadonlyArray<{ readonly __typename?: 'User', readonly id: string, readonly conferencesCreated: ReadonlyArray<{ readonly __typename?: 'Conference', readonly id: any }>, readonly attendees: ReadonlyArray<{ readonly __typename?: 'Attendee', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly groupAttendees: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly id: any, readonly groupId: any, readonly attendeeId: any, readonly group: (
          { readonly __typename?: 'Group' }
          & GroupDataFragment
        ) }> }> }>, readonly publicGroups: ReadonlyArray<(
    { readonly __typename?: 'Group' }
    & GroupDataFragment
  )> };

export type PublicUserGroupsRolesPermissionsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type PublicUserGroupsRolesPermissionsQuery = { readonly __typename?: 'query_root', readonly publicGroups: ReadonlyArray<(
    { readonly __typename?: 'Group' }
    & GroupDataFragment
  )> };

export type AttendeeProfileDataFragment = { readonly __typename?: 'AttendeeProfile', readonly attendeeId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean };

export type AttendeeDataFragment = { readonly __typename?: 'Attendee', readonly id: any, readonly userId?: Maybe<string>, readonly displayName: string, readonly profile?: Maybe<(
    { readonly __typename?: 'AttendeeProfile' }
    & AttendeeProfileDataFragment
  )> };

export type AttendeeByUserIdConferenceIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  userId: Scalars['String'];
}>;


export type AttendeeByUserIdConferenceIdQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type AttendeeByIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type AttendeeByIdQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type UpdateSubtitlesMutationVariables = Exact<{
  contentItemId: Scalars['String'];
  magicToken: Scalars['String'];
  subtitleText: Scalars['String'];
}>;


export type UpdateSubtitlesMutation = { readonly __typename?: 'mutation_root', readonly updateSubtitles?: Maybe<{ readonly __typename?: 'SubmitUpdatedSubtitlesOutput', readonly message: string, readonly success: boolean }> };

export type GetContentItemQueryVariables = Exact<{
  magicToken: Scalars['String'];
}>;


export type GetContentItemQuery = { readonly __typename?: 'query_root', readonly getContentItem?: Maybe<ReadonlyArray<Maybe<{ readonly __typename?: 'GetContentItemOutput', readonly contentTypeName: string, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly id: string, readonly contentGroupTitle: string }>>> };

export type SelectRequiredItemQueryVariables = Exact<{
  requiredContentItemId: Scalars['uuid'];
}>;


export type SelectRequiredItemQuery = { readonly __typename?: 'query_root', readonly RequiredContentItem: ReadonlyArray<(
    { readonly __typename?: 'RequiredContentItem' }
    & RequiredItemFieldsFragment
  )> };

export type RequiredItemFieldsFragment = { readonly __typename?: 'RequiredContentItem', readonly id: any, readonly contentTypeName: ContentType_Enum, readonly name: string, readonly uploadsRemaining?: Maybe<number>, readonly contentGroupTitle?: Maybe<string>, readonly conference: { readonly __typename?: 'Conference', readonly id: any, readonly name: string } };

export type SubmitContentItemMutationVariables = Exact<{
  contentItemData: Scalars['jsonb'];
  magicToken: Scalars['String'];
}>;


export type SubmitContentItemMutation = { readonly __typename?: 'mutation_root', readonly submitContentItem?: Maybe<{ readonly __typename?: 'SubmitContentItemOutput', readonly message: string, readonly success: boolean }> };

export type GetUploadAgreementQueryVariables = Exact<{
  magicToken: Scalars['String'];
}>;


export type GetUploadAgreementQuery = { readonly __typename?: 'query_root', readonly getUploadAgreement?: Maybe<{ readonly __typename?: 'GetUploadAgreementOutput', readonly agreementText?: Maybe<string> }> };

export type EchoQueryVariables = Exact<{
  message: Scalars['String'];
}>;


export type EchoQuery = { readonly __typename?: 'query_root', readonly echo?: Maybe<{ readonly __typename?: 'EchoOutput', readonly message: string }> };

export type ProtectedEchoQueryVariables = Exact<{
  message: Scalars['String'];
}>;


export type ProtectedEchoQuery = { readonly __typename?: 'query_root', readonly protectedEcho?: Maybe<{ readonly __typename?: 'ProtectedEchoOutput', readonly message: string }> };

export type UserEventRolesSubscriptionVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type UserEventRolesSubscription = { readonly __typename?: 'subscription_root', readonly Event_by_pk?: Maybe<{ readonly __typename?: 'Event', readonly eventPeople: ReadonlyArray<(
      { readonly __typename?: 'EventPerson' }
      & EventPersonDetailsFragment
    )> }> };

export type EventPersonDetailsFragment = { readonly __typename?: 'EventPerson', readonly id: any, readonly name: string, readonly roleName: EventPersonRole_Enum, readonly eventId: any, readonly attendeeId?: Maybe<any> };

export type SelectInvitationForAcceptQueryVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SelectInvitationForAcceptQuery = { readonly __typename?: 'query_root', readonly Invitation: ReadonlyArray<{ readonly __typename?: 'Invitation', readonly hash?: Maybe<string> }> };

export type Invitation_ConfirmCurrentMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type Invitation_ConfirmCurrentMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmCurrent?: Maybe<{ readonly __typename?: 'ConfirmInvitationOutput', readonly confSlug?: Maybe<string>, readonly ok: boolean }> };

export type Invitation_ConfirmWithCodeMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
  confirmationCode: Scalars['String'];
}>;


export type Invitation_ConfirmWithCodeMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmWithCode?: Maybe<{ readonly __typename?: 'ConfirmInvitationOutput', readonly confSlug?: Maybe<string>, readonly ok: boolean }> };

export type SendInitialConfirmationEmailMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SendInitialConfirmationEmailMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmSendInitialEmail?: Maybe<{ readonly __typename?: 'InvitationConfirmationEmailOutput', readonly sent: boolean }> };

export type SendRepeatConfirmationEmailMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SendRepeatConfirmationEmailMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmSendRepeatEmail?: Maybe<{ readonly __typename?: 'InvitationConfirmationEmailOutput', readonly sent: boolean }> };

export type SidebarChatInfoFragment = { readonly __typename?: 'chat_Chat', readonly id: any, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly contentGroup: ReadonlyArray<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string> }>, readonly nonDMRoom: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly priority: number, readonly roomPrivacyName: RoomPrivacy_Enum }>, readonly DMRoom: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'RoomPerson', readonly id: any, readonly attendee: { readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string } }> }>, readonly readUpToIndices: ReadonlyArray<{ readonly __typename?: 'chat_ReadUpToIndex', readonly attendeeId: any, readonly chatId: any, readonly unreadCount?: Maybe<number> }> };

export type PinnedChatsWithUnreadCountsQueryVariables = Exact<{
  attendeeId: Scalars['uuid'];
}>;


export type PinnedChatsWithUnreadCountsQuery = { readonly __typename?: 'query_root', readonly chat_Pin: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly attendeeId: any, readonly chatId: any, readonly chat: (
      { readonly __typename?: 'chat_Chat' }
      & SidebarChatInfoFragment
    ) }> };

export type MenuScheduleQueryVariables = Exact<{
  now: Scalars['timestamptz'];
  inThreeMinutes: Scalars['timestamptz'];
  in30Minutes: Scalars['timestamptz'];
  inOneHour: Scalars['timestamptz'];
  conferenceId: Scalars['uuid'];
}>;


export type MenuScheduleQuery = { readonly __typename?: 'query_root', readonly eventsNow: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & MenuSchedule_EventFragment
  )>, readonly eventsIn30mins: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & MenuSchedule_EventFragment
  )>, readonly eventsIn1Hour: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & MenuSchedule_EventFragment
  )> };

export type MenuSchedule_SearchEventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type MenuSchedule_SearchEventsQuery = { readonly __typename?: 'query_root', readonly Event: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & MenuSchedule_EventFragment
  )> };

export type MenuSchedule_EventFragment = { readonly __typename?: 'Event', readonly id: any, readonly name: string, readonly startTime: any, readonly room: { readonly __typename?: 'Room', readonly id: any, readonly name: string }, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'EventTag', readonly tag: { readonly __typename?: 'Tag', readonly id: any, readonly colour: string, readonly name: string } }>, readonly contentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly title: string }> };

export type MainMenuSponsors_GetSponsorsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type MainMenuSponsors_GetSponsorsQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & MainMenuSponsors_ContentGroupDataFragment
  )> };

export type MainMenuSponsors_ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly rooms: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }>, readonly logo: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly data: any }> };

export type GetRoomMembersSubscriptionVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomMembersSubscription = { readonly __typename?: 'subscription_root', readonly RoomPerson: ReadonlyArray<(
    { readonly __typename?: 'RoomPerson' }
    & RoomMemberFragment
  )> };

export type RoomMemberFragment = { readonly __typename?: 'RoomPerson', readonly id: any, readonly roomPersonRoleName: RoomPersonRole_Enum, readonly attendeeId: any };

export type GetRoomParticipantsSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
  roomId: Scalars['uuid'];
}>;


export type GetRoomParticipantsSubscription = { readonly __typename?: 'subscription_root', readonly RoomParticipant: ReadonlyArray<(
    { readonly __typename?: 'RoomParticipant' }
    & RoomParticipantDetailsFragment
  )> };

export type GetAllRoomParticipantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetAllRoomParticipantsQuery = { readonly __typename?: 'query_root', readonly RoomParticipant: ReadonlyArray<(
    { readonly __typename?: 'RoomParticipant' }
    & RoomParticipantDetailsFragment
  )> };

export type RoomParticipantDetailsFragment = { readonly __typename?: 'RoomParticipant', readonly attendeeId: any, readonly conferenceId: any, readonly id: any, readonly roomId: any };

export type ShufflePeriodDataFragment = { readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly conferenceId: any, readonly endAt: any, readonly maxAttendeesPerRoom: number, readonly name: string, readonly roomDurationMinutes: number, readonly startAt: any, readonly targetAttendeesPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly queueEntries: ReadonlyArray<(
    { readonly __typename?: 'room_ShuffleQueueEntry' }
    & PrefetchShuffleQueueEntryDataFragment
  )> };

export type PrefetchShuffleQueueEntryDataFragment = { readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly attendeeId: any, readonly created_at: any, readonly updated_at: any, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly isEnded: boolean, readonly roomId: any }> };

export type SubdShuffleQueueEntryDataFragment = { readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly allocatedShuffleRoomId?: Maybe<number> };

export type MyShuffleQueueEntrySubscriptionVariables = Exact<{
  id: Scalars['bigint'];
}>;


export type MyShuffleQueueEntrySubscription = { readonly __typename?: 'subscription_root', readonly room_ShuffleQueueEntry_by_pk?: Maybe<(
    { readonly __typename?: 'room_ShuffleQueueEntry' }
    & SubdShuffleQueueEntryDataFragment
  )> };

export type GetShuffleRoomQueryVariables = Exact<{
  id: Scalars['bigint'];
}>;


export type GetShuffleRoomQuery = { readonly __typename?: 'query_root', readonly room_ShuffleRoom_by_pk?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly roomId: any }> };

export type ShufflePeriodsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  start: Scalars['timestamptz'];
  end: Scalars['timestamptz'];
}>;


export type ShufflePeriodsQuery = { readonly __typename?: 'query_root', readonly room_ShufflePeriod: ReadonlyArray<(
    { readonly __typename?: 'room_ShufflePeriod' }
    & ShufflePeriodDataFragment
  )> };

export type JoinShuffleQueueMutationVariables = Exact<{
  shufflePeriodId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type JoinShuffleQueueMutation = { readonly __typename?: 'mutation_root', readonly insert_room_ShuffleQueueEntry_one?: Maybe<(
    { readonly __typename?: 'room_ShuffleQueueEntry' }
    & PrefetchShuffleQueueEntryDataFragment
  )> };

export type GetShuffleRoomsParticipantsCountQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetShuffleRoomsParticipantsCountQuery = { readonly __typename?: 'query_root', readonly RoomParticipant_aggregate: { readonly __typename?: 'RoomParticipant_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'RoomParticipant_aggregate_fields', readonly count?: Maybe<number> }> } };

export type AttendeeFieldsFragment = { readonly __typename?: 'Attendee', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly createdAt: any, readonly updatedAt: any, readonly conference: { readonly __typename?: 'Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }, readonly groupAttendees: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly id: any, readonly group: { readonly __typename?: 'Group', readonly id: any, readonly enabled: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly role: { readonly __typename?: 'Role', readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum }> } }> } }> };

export type SelectCurrentUserQueryVariables = Exact<{
  userId: Scalars['String'];
}>;


export type SelectCurrentUserQuery = { readonly __typename?: 'query_root', readonly User_by_pk?: Maybe<{ readonly __typename?: 'User', readonly id: string, readonly email?: Maybe<string>, readonly lastName: string, readonly firstName: string, readonly attendees: ReadonlyArray<(
      { readonly __typename?: 'Attendee' }
      & AttendeeFieldsFragment
    )> }> };

export type GetCurrentUserIsIncognitoQueryVariables = Exact<{
  userId: Scalars['String'];
}>;


export type GetCurrentUserIsIncognitoQuery = { readonly __typename?: 'query_root', readonly OnlineStatus: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly isIncognito: boolean }> };

export type UpdateCurrentUserIsIncognitoMutationVariables = Exact<{
  userId: Scalars['String'];
  isIncognito?: Maybe<Scalars['Boolean']>;
}>;


export type UpdateCurrentUserIsIncognitoMutation = { readonly __typename?: 'mutation_root', readonly update_OnlineStatus?: Maybe<{ readonly __typename?: 'OnlineStatus_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly isIncognito: boolean }> }> };

export type GetCurrentUserLastSeenQueryVariables = Exact<{
  userId: Scalars['String'];
}>;


export type GetCurrentUserLastSeenQuery = { readonly __typename?: 'query_root', readonly OnlineStatus: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly lastSeen: any }> };

export type InsertCurrentUserOnlineStatusMutationVariables = Exact<{
  userId: Scalars['String'];
}>;


export type InsertCurrentUserOnlineStatusMutation = { readonly __typename?: 'mutation_root', readonly insert_OnlineStatus?: Maybe<{ readonly __typename?: 'OnlineStatus_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly isIncognito: boolean, readonly lastSeen: any, readonly userId: string }> }> };

export type UpdateCurrentUserLastSeenMutationVariables = Exact<{
  userId: Scalars['String'];
  lastSeen?: Maybe<Scalars['timestamptz']>;
}>;


export type UpdateCurrentUserLastSeenMutation = { readonly __typename?: 'mutation_root', readonly update_OnlineStatus?: Maybe<{ readonly __typename?: 'OnlineStatus_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly lastSeen: any }> }> };

export const ChatFlagDataFragmentDoc = gql`
    fragment ChatFlagData on chat_Flag {
  discussionChatId
  flaggedById
  id
  messageId
  notes
  resolution
  resolved_at
  type
  updated_at
  created_at
}
    `;
export const ChatReactionDataFragmentDoc = gql`
    fragment ChatReactionData on chat_Reaction {
  data
  id
  senderId
  symbol
  type
}
    `;
export const ChatMessageDataFragmentDoc = gql`
    fragment ChatMessageData on chat_Message {
  created_at
  data
  duplicatedMessageId
  id
  message
  reactions {
    ...ChatReactionData
  }
  senderId
  type
  chatId
}
    ${ChatReactionDataFragmentDoc}`;
export const SubscribedChatReactionDataFragmentDoc = gql`
    fragment SubscribedChatReactionData on chat_Reaction {
  data
  id
  senderId
  symbol
  type
  messageId
}
    `;
export const SubscribedChatMessageDataFragmentDoc = gql`
    fragment SubscribedChatMessageData on chat_Message {
  created_at
  data
  duplicatedMessageId
  id
  message
  senderId
  type
  chatId
}
    `;
export const PinDataFragmentDoc = gql`
    fragment PinData on chat_Pin {
  chatId
  attendeeId
  wasManuallyPinned
}
    `;
export const ChatPinConfigFragmentDoc = gql`
    fragment ChatPinConfig on chat_Chat {
  id
  enableAutoPin
  enableMandatoryPin
}
    `;
export const SubscriptionDataFragmentDoc = gql`
    fragment SubscriptionData on chat_Subscription {
  chatId
  attendeeId
  wasManuallySubscribed
}
    `;
export const ChatSubscriptionConfigFragmentDoc = gql`
    fragment ChatSubscriptionConfig on chat_Chat {
  id
  enableAutoSubscribe
  enableMandatorySubscribe
}
    `;
export const ContentGroupList_ContentPersonDataFragmentDoc = gql`
    fragment ContentGroupList_ContentPersonData on ContentGroupPerson {
  id
  person {
    id
    affiliation
    name
  }
  priority
}
    `;
export const ContentGroupList_ContentGroupDataFragmentDoc = gql`
    fragment ContentGroupList_ContentGroupData on ContentGroup {
  id
  title
  people(where: {roleName: {_nilike: "chair"}}) {
    ...ContentGroupList_ContentPersonData
  }
}
    ${ContentGroupList_ContentPersonDataFragmentDoc}`;
export const ContentGroupList_ContentGroupTagDataFragmentDoc = gql`
    fragment ContentGroupList_ContentGroupTagData on ContentGroupTag {
  contentGroup {
    ...ContentGroupList_ContentGroupData
  }
}
    ${ContentGroupList_ContentGroupDataFragmentDoc}`;
export const ContentGroupList_TagInfoFragmentDoc = gql`
    fragment ContentGroupList_TagInfo on Tag {
  id
  colour
  name
}
    `;
export const ContentItemDataFragmentDoc = gql`
    fragment ContentItemData on ContentItem {
  id
  data
  layoutData
  name
  contentTypeName
}
    `;
export const ContentPersonDataFragmentDoc = gql`
    fragment ContentPersonData on ContentGroupPerson {
  id
  person {
    id
    name
    affiliation
  }
  roleName
  priority
}
    `;
export const ContentGroupDataFragmentDoc = gql`
    fragment ContentGroupData on ContentGroup {
  id
  title
  contentGroupTypeName
  chatId
  chat {
    room {
      id
      name
    }
  }
  contentItems(where: {isHidden: {_eq: false}}) {
    ...ContentItemData
  }
  people(order_by: {priority: asc}) {
    ...ContentPersonData
  }
}
    ${ContentItemDataFragmentDoc}
${ContentPersonDataFragmentDoc}`;
export const ContentGroupPage_ContentGroupRoomsFragmentDoc = gql`
    fragment ContentGroupPage_ContentGroupRooms on ContentGroup {
  rooms(where: {name: {_like: "Breakout:%"}}, order_by: {created_at: asc}) {
    id
  }
}
    `;
export const ContentGroupEventFragmentDoc = gql`
    fragment ContentGroupEvent on Event {
  startTime
  room {
    name
    id
  }
  id
  durationSeconds
  endTime
  name
  intendedRoomModeName
}
    `;
export const ContentGroupEventsFragmentDoc = gql`
    fragment ContentGroupEvents on ContentGroup {
  events {
    ...ContentGroupEvent
  }
}
    ${ContentGroupEventFragmentDoc}`;
export const ContentGroupSummary_ContentGroupDataFragmentDoc = gql`
    fragment ContentGroupSummary_ContentGroupData on ContentGroup {
  id
  title
  contentGroupTypeName
  chatId
  chat {
    room {
      id
      name
    }
  }
  contentItems(where: {isHidden: {_eq: false}}) {
    ...ContentItemData
  }
  people(order_by: {priority: asc}) {
    ...ContentPersonData
  }
}
    ${ContentItemDataFragmentDoc}
${ContentPersonDataFragmentDoc}`;
export const Timeline_EventPersonFragmentDoc = gql`
    fragment Timeline_EventPerson on EventPerson {
  id
  attendeeId
  name
  affiliation
  roleName
}
    `;
export const EventParticipantStreamDetailsFragmentDoc = gql`
    fragment EventParticipantStreamDetails on EventParticipantStream {
  id
  attendee {
    id
    displayName
  }
  conferenceId
  eventId
  vonageStreamType
  vonageStreamId
  attendeeId
}
    `;
export const EventRoomJoinRequestDetailsFragmentDoc = gql`
    fragment EventRoomJoinRequestDetails on EventRoomJoinRequest {
  id
  attendeeId
}
    `;
export const RoomEventDetailsFragmentDoc = gql`
    fragment RoomEventDetails on Event {
  id
  conferenceId
  startTime
  name
  durationSeconds
  endTime
  intendedRoomModeName
  eventVonageSession {
    id
    sessionId
  }
}
    `;
export const Room_CurrentEventSummaryFragmentDoc = gql`
    fragment Room_CurrentEventSummary on Event {
  id
  contentGroup {
    id
    title
    contentGroupTypeName
    contentItems(where: {contentTypeName: {_eq: ZOOM}}, limit: 1) {
      id
      data
    }
    chatId
  }
}
    `;
export const Room_EventSummaryFragmentDoc = gql`
    fragment Room_EventSummary on Event {
  id
  conferenceId
  startTime
  name
  endTime
  intendedRoomModeName
  contentGroupId
  contentGroup {
    id
    title
  }
}
    `;
export const RoomListRoomDetailsFragmentDoc = gql`
    fragment RoomListRoomDetails on Room {
  id
  name
  roomPrivacyName
  originatingContentGroupId
  originatingEventId
}
    `;
export const RoomPage_RoomPeopleFragmentDoc = gql`
    fragment RoomPage_RoomPeople on Room {
  roomPeople {
    id
    roomPersonRoleName
    attendeeId
  }
}
    `;
export const RoomPage_RoomDetailsFragmentDoc = gql`
    fragment RoomPage_RoomDetails on Room {
  id
  name
  currentModeName
  mediaLiveChannel {
    cloudFrontDomain
    endpointUri
    id
  }
  publicVonageSessionId
  chatId
  originatingContentGroup {
    id
    contentGroupTypeName
    contentItems(
      where: {contentTypeName: {_eq: IMAGE_URL}, layoutData: {_contains: {isLogo: true}}}
      limit: 1
      order_by: {updatedAt: desc}
    ) {
      id
      data
    }
    title
  }
  roomPrivacyName
  ...RoomPage_RoomPeople
  shuffleRooms(limit: 1, order_by: {id: desc}) {
    id
    startedAt
    durationMinutes
    reshuffleUponEnd
  }
}
    ${RoomPage_RoomPeopleFragmentDoc}`;
export const RoomSponsorContent_ContentItemDataFragmentDoc = gql`
    fragment RoomSponsorContent_ContentItemData on ContentItem {
  id
  name
  contentTypeName
  data
  layoutData
}
    `;
export const RoomSponsorContent_ContentGroupDataFragmentDoc = gql`
    fragment RoomSponsorContent_ContentGroupData on ContentGroup {
  id
  contentItems {
    ...RoomSponsorContent_ContentItemData
  }
}
    ${RoomSponsorContent_ContentItemDataFragmentDoc}`;
export const Timeline_ContentItemFragmentDoc = gql`
    fragment Timeline_ContentItem on ContentItem {
  id
  contentTypeName
  name
  isHidden
  layoutData
}
    `;
export const Timeline_ContentItem_WithDataFragmentDoc = gql`
    fragment Timeline_ContentItem_WithData on ContentItem {
  ...Timeline_ContentItem
  data
}
    ${Timeline_ContentItemFragmentDoc}`;
export const Timeline_ContentPersonFragmentDoc = gql`
    fragment Timeline_ContentPerson on ContentPerson {
  id
  name
  affiliation
}
    `;
export const Timeline_ContentGroupPersonFragmentDoc = gql`
    fragment Timeline_ContentGroupPerson on ContentGroupPerson {
  id
  priority
  roleName
  person {
    ...Timeline_ContentPerson
  }
}
    ${Timeline_ContentPersonFragmentDoc}`;
export const Timeline_ContentGroupFragmentDoc = gql`
    fragment Timeline_ContentGroup on ContentGroup {
  id
  contentGroupTypeName
  title
  abstractContentItems: contentItems(where: {contentTypeName: {_eq: ABSTRACT}}) {
    ...Timeline_ContentItem_WithData
  }
  people {
    ...Timeline_ContentGroupPerson
  }
}
    ${Timeline_ContentItem_WithDataFragmentDoc}
${Timeline_ContentGroupPersonFragmentDoc}`;
export const Timeline_Event_FullInfoFragmentDoc = gql`
    fragment Timeline_Event_FullInfo on Event {
  id
  roomId
  intendedRoomModeName
  name
  startTime
  durationSeconds
  contentGroup {
    ...Timeline_ContentGroup
  }
}
    ${Timeline_ContentGroupFragmentDoc}`;
export const Timeline_EventFragmentDoc = gql`
    fragment Timeline_Event on Event {
  id
  roomId
  name
  startTime
  durationSeconds
  contentGroupId
}
    `;
export const Timeline_RoomFragmentDoc = gql`
    fragment Timeline_Room on Room {
  id
  name
  currentModeName
  priority
}
    `;
export const Timeline_ContentGroup_PartialInfoFragmentDoc = gql`
    fragment Timeline_ContentGroup_PartialInfo on ContentGroup {
  id
  title
}
    `;
export const Timeline_TagFragmentDoc = gql`
    fragment Timeline_Tag on Tag {
  id
  name
  colour
}
    `;
export const Timeline_EventTagFragmentDoc = gql`
    fragment Timeline_EventTag on EventTag {
  id
  tag {
    ...Timeline_Tag
  }
}
    ${Timeline_TagFragmentDoc}`;
export const ContentPersonInfoFragmentDoc = gql`
    fragment ContentPersonInfo on ContentPerson {
  id
  conferenceId
  name
  affiliation
  email
  originatingDataId
}
    `;
export const UploaderInfoFragmentDoc = gql`
    fragment UploaderInfo on Uploader {
  id
  conferenceId
  email
  emailsSentCount
  name
  requiredContentItemId
}
    `;
export const RequiredContentItemInfoFragmentDoc = gql`
    fragment RequiredContentItemInfo on RequiredContentItem {
  id
  name
  isHidden
  contentTypeName
  conferenceId
  contentGroupId
  uploadsRemaining
  uploaders {
    ...UploaderInfo
  }
  originatingDataId
}
    ${UploaderInfoFragmentDoc}`;
export const ContentItemInfoFragmentDoc = gql`
    fragment ContentItemInfo on ContentItem {
  conferenceId
  contentGroupId
  contentTypeName
  data
  id
  isHidden
  layoutData
  name
  requiredContentId
  originatingDataId
}
    `;
export const ContentGroupTagInfoFragmentDoc = gql`
    fragment ContentGroupTagInfo on ContentGroupTag {
  id
  tagId
  contentGroupId
}
    `;
export const ContentGroupHallwayInfoFragmentDoc = gql`
    fragment ContentGroupHallwayInfo on ContentGroupHallway {
  id
  groupId
  hallwayId
  conferenceId
  priority
  layout
}
    `;
export const ContentGroupPersonInfoFragmentDoc = gql`
    fragment ContentGroupPersonInfo on ContentGroupPerson {
  id
  conferenceId
  groupId
  personId
  priority
  roleName
}
    `;
export const ContentGroupFullNestedInfoFragmentDoc = gql`
    fragment ContentGroupFullNestedInfo on ContentGroup {
  id
  conferenceId
  contentGroupTypeName
  title
  shortTitle
  requiredContentItems {
    ...RequiredContentItemInfo
  }
  contentItems {
    ...ContentItemInfo
  }
  contentGroupTags {
    ...ContentGroupTagInfo
  }
  hallways {
    ...ContentGroupHallwayInfo
  }
  people {
    ...ContentGroupPersonInfo
  }
  originatingDataId
}
    ${RequiredContentItemInfoFragmentDoc}
${ContentItemInfoFragmentDoc}
${ContentGroupTagInfoFragmentDoc}
${ContentGroupHallwayInfoFragmentDoc}
${ContentGroupPersonInfoFragmentDoc}`;
export const TagInfoFragmentDoc = gql`
    fragment TagInfo on Tag {
  id
  conferenceId
  colour
  name
  originatingDataId
}
    `;
export const HallwayInfoFragmentDoc = gql`
    fragment HallwayInfo on Hallway {
  id
  conferenceId
  colour
  name
  priority
}
    `;
export const ManageConferenceExportPage_ContentItemDataFragmentDoc = gql`
    fragment ManageConferenceExportPage_ContentItemData on ContentItem {
  id
  data
  name
  contentGroup {
    id
    title
  }
}
    `;
export const AttendeePartsFragmentDoc = gql`
    fragment AttendeeParts on Attendee {
  conferenceId
  id
  groupAttendees {
    attendeeId
    id
    groupId
  }
  invitation {
    attendeeId
    id
    inviteCode
    invitedEmailAddress
    linkToUserId
    createdAt
    updatedAt
    hash
  }
  userId
  updatedAt
  createdAt
  displayName
  inviteSent
}
    `;
export const RoomParticipantWithAttendeeInfoFragmentDoc = gql`
    fragment RoomParticipantWithAttendeeInfo on RoomParticipant {
  id
  conferenceId
  attendeeId
  roomId
  attendee {
    displayName
  }
}
    `;
export const OriginatingDataInfoFragmentDoc = gql`
    fragment OriginatingDataInfo on OriginatingData {
  id
  conferenceId
  sourceId
  data
}
    `;
export const RoomWithParticipantInfoFragmentDoc = gql`
    fragment RoomWithParticipantInfo on Room {
  id
  conferenceId
  name
  currentModeName
  capacity
  priority
  participants {
    ...RoomParticipantWithAttendeeInfo
  }
  originatingData {
    ...OriginatingDataInfo
  }
}
    ${RoomParticipantWithAttendeeInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}`;
export const RoomParticipantInfoFragmentDoc = gql`
    fragment RoomParticipantInfo on RoomParticipant {
  attendeeId
  conferenceId
  id
  roomId
}
    `;
export const RoomInfoFragmentDoc = gql`
    fragment RoomInfo on Room {
  capacity
  conferenceId
  currentModeName
  id
  name
  priority
  originatingDataId
  originatingData {
    ...OriginatingDataInfo
  }
  participants {
    ...RoomParticipantInfo
  }
}
    ${OriginatingDataInfoFragmentDoc}
${RoomParticipantInfoFragmentDoc}`;
export const EventPersonInfoFragmentDoc = gql`
    fragment EventPersonInfo on EventPerson {
  affiliation
  attendeeId
  attendee {
    id
    displayName
    userId
  }
  conferenceId
  eventId
  id
  name
  originatingDataId
  roleName
}
    `;
export const EventTagInfoFragmentDoc = gql`
    fragment EventTagInfo on EventTag {
  eventId
  id
  tagId
}
    `;
export const EventInfoFragmentDoc = gql`
    fragment EventInfo on Event {
  conferenceId
  id
  durationSeconds
  eventPeople {
    ...EventPersonInfo
  }
  eventTags {
    ...EventTagInfo
  }
  id
  intendedRoomModeName
  name
  originatingDataId
  roomId
  startTime
  endTime
  contentGroupId
}
    ${EventPersonInfoFragmentDoc}
${EventTagInfoFragmentDoc}`;
export const AttendeeInfoFragmentDoc = gql`
    fragment AttendeeInfo on Attendee {
  id
  displayName
}
    `;
export const GroupDataFragmentDoc = gql`
    fragment GroupData on Group {
  groupRoles {
    role {
      rolePermissions {
        permissionName
        id
        roleId
      }
      id
      name
      conferenceId
    }
    id
    roleId
    groupId
  }
  enabled
  id
  includeUnauthenticated
  name
  conferenceId
}
    `;
export const AttendeeProfileDataFragmentDoc = gql`
    fragment AttendeeProfileData on AttendeeProfile {
  attendeeId
  badges
  affiliation
  affiliationURL
  country
  timezoneUTCOffset
  bio
  website
  github
  twitter
  pronouns
  photoURL_50x50
  photoURL_350x350
  hasBeenEdited
}
    `;
export const AttendeeDataFragmentDoc = gql`
    fragment AttendeeData on Attendee {
  id
  userId
  displayName
  profile {
    ...AttendeeProfileData
  }
}
    ${AttendeeProfileDataFragmentDoc}`;
export const RequiredItemFieldsFragmentDoc = gql`
    fragment RequiredItemFields on RequiredContentItem {
  id
  contentTypeName
  name
  uploadsRemaining
  conference {
    id
    name
  }
  contentGroupTitle
}
    `;
export const EventPersonDetailsFragmentDoc = gql`
    fragment EventPersonDetails on EventPerson {
  id
  name
  roleName
  eventId
  attendeeId
}
    `;
export const SidebarChatInfoFragmentDoc = gql`
    fragment SidebarChatInfo on chat_Chat {
  id
  contentGroup {
    id
    title
    shortTitle
  }
  nonDMRoom: room(where: {roomPrivacyName: {_neq: DM}}) {
    id
    name
    priority
    roomPrivacyName
  }
  DMRoom: room(where: {roomPrivacyName: {_eq: DM}}) {
    id
    name
    roomPeople {
      id
      attendee {
        id
        displayName
      }
    }
  }
  enableAutoPin
  enableAutoSubscribe
  enableMandatoryPin
  enableMandatorySubscribe
  readUpToIndices(where: {attendeeId: {_eq: $attendeeId}}) {
    attendeeId
    chatId
    unreadCount
  }
}
    `;
export const MenuSchedule_EventFragmentDoc = gql`
    fragment MenuSchedule_Event on Event {
  id
  name
  startTime
  room {
    id
    name
  }
  eventTags {
    tag {
      id
      colour
      name
    }
  }
  contentGroup {
    title
  }
}
    `;
export const MainMenuSponsors_ContentGroupDataFragmentDoc = gql`
    fragment MainMenuSponsors_ContentGroupData on ContentGroup {
  id
  rooms(
    limit: 1
    order_by: {created_at: asc}
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    id
  }
  logo: contentItems(
    where: {contentTypeName: {_eq: IMAGE_URL}, layoutData: {_contains: {isLogo: true}}}
    order_by: {updatedAt: desc}
    limit: 1
  ) {
    id
    data
  }
  title
}
    `;
export const RoomMemberFragmentDoc = gql`
    fragment RoomMember on RoomPerson {
  id
  roomPersonRoleName
  attendeeId
}
    `;
export const RoomParticipantDetailsFragmentDoc = gql`
    fragment RoomParticipantDetails on RoomParticipant {
  attendeeId
  conferenceId
  id
  roomId
  attendeeId
}
    `;
export const PrefetchShuffleQueueEntryDataFragmentDoc = gql`
    fragment PrefetchShuffleQueueEntryData on room_ShuffleQueueEntry {
  id
  attendeeId
  created_at
  updated_at
  shuffleRoom {
    id
    startedAt
    isEnded
    roomId
  }
}
    `;
export const ShufflePeriodDataFragmentDoc = gql`
    fragment ShufflePeriodData on room_ShufflePeriod {
  id
  conferenceId
  endAt
  maxAttendeesPerRoom
  name
  queueEntries(distinct_on: [attendeeId], order_by: {attendeeId: asc, id: desc}) {
    ...PrefetchShuffleQueueEntryData
  }
  roomDurationMinutes
  startAt
  targetAttendeesPerRoom
  waitRoomMaxDurationSeconds
}
    ${PrefetchShuffleQueueEntryDataFragmentDoc}`;
export const SubdShuffleQueueEntryDataFragmentDoc = gql`
    fragment SubdShuffleQueueEntryData on room_ShuffleQueueEntry {
  id
  allocatedShuffleRoomId
}
    `;
export const AttendeeFieldsFragmentDoc = gql`
    fragment AttendeeFields on Attendee {
  id
  userId
  conferenceId
  displayName
  createdAt
  updatedAt
  conference {
    id
    name
    shortName
    slug
  }
  groupAttendees {
    id
    group {
      id
      enabled
      name
      groupRoles {
        id
        role {
          id
          name
          rolePermissions {
            id
            permissionName
          }
        }
      }
    }
  }
}
    `;
export const SubscribedChatsDocument = gql`
    query SubscribedChats($attendeeId: uuid!) {
  chat_Subscription(where: {attendeeId: {_eq: $attendeeId}}) {
    attendeeId
    chatId
  }
}
    `;

/**
 * __useSubscribedChatsQuery__
 *
 * To run a query within a React component, call `useSubscribedChatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubscribedChatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscribedChatsQuery({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useSubscribedChatsQuery(baseOptions: Apollo.QueryHookOptions<SubscribedChatsQuery, SubscribedChatsQueryVariables>) {
        return Apollo.useQuery<SubscribedChatsQuery, SubscribedChatsQueryVariables>(SubscribedChatsDocument, baseOptions);
      }
export function useSubscribedChatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubscribedChatsQuery, SubscribedChatsQueryVariables>) {
          return Apollo.useLazyQuery<SubscribedChatsQuery, SubscribedChatsQueryVariables>(SubscribedChatsDocument, baseOptions);
        }
export type SubscribedChatsQueryHookResult = ReturnType<typeof useSubscribedChatsQuery>;
export type SubscribedChatsLazyQueryHookResult = ReturnType<typeof useSubscribedChatsLazyQuery>;
export type SubscribedChatsQueryResult = Apollo.QueryResult<SubscribedChatsQuery, SubscribedChatsQueryVariables>;
export const SubdMessages_2021_01_21T08_24Document = gql`
    subscription SubdMessages_2021_01_21T08_24($chatIds: [uuid!]!) {
  chat_Message(limit: 1, order_by: {id: desc}, where: {chatId: {_in: $chatIds}}) {
    id
    chatId
    message
    type
    senderId
    senderName
    chatTitle
  }
}
    `;

/**
 * __useSubdMessages_2021_01_21T08_24Subscription__
 *
 * To run a query within a React component, call `useSubdMessages_2021_01_21T08_24Subscription` and pass it any options that fit your needs.
 * When your component renders, `useSubdMessages_2021_01_21T08_24Subscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubdMessages_2021_01_21T08_24Subscription({
 *   variables: {
 *      chatIds: // value for 'chatIds'
 *   },
 * });
 */
export function useSubdMessages_2021_01_21T08_24Subscription(baseOptions: Apollo.SubscriptionHookOptions<SubdMessages_2021_01_21T08_24Subscription, SubdMessages_2021_01_21T08_24SubscriptionVariables>) {
        return Apollo.useSubscription<SubdMessages_2021_01_21T08_24Subscription, SubdMessages_2021_01_21T08_24SubscriptionVariables>(SubdMessages_2021_01_21T08_24Document, baseOptions);
      }
export type SubdMessages_2021_01_21T08_24SubscriptionHookResult = ReturnType<typeof useSubdMessages_2021_01_21T08_24Subscription>;
export type SubdMessages_2021_01_21T08_24SubscriptionResult = Apollo.SubscriptionResult<SubdMessages_2021_01_21T08_24Subscription>;
export const SetNotifiedUpToIndexDocument = gql`
    mutation SetNotifiedUpToIndex($attendeeId: uuid!, $chatId: uuid!, $msgId: Int!) {
  insert_chat_ReadUpToIndex_one(
    object: {attendeeId: $attendeeId, chatId: $chatId, messageId: -1, notifiedUpToMessageId: $msgId}
    on_conflict: {constraint: ReadUpToIndex_pkey, update_columns: [notifiedUpToMessageId]}
  ) {
    chatId
    attendeeId
    notifiedUpToMessageId
  }
}
    `;
export type SetNotifiedUpToIndexMutationFn = Apollo.MutationFunction<SetNotifiedUpToIndexMutation, SetNotifiedUpToIndexMutationVariables>;

/**
 * __useSetNotifiedUpToIndexMutation__
 *
 * To run a mutation, you first call `useSetNotifiedUpToIndexMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetNotifiedUpToIndexMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setNotifiedUpToIndexMutation, { data, loading, error }] = useSetNotifiedUpToIndexMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      chatId: // value for 'chatId'
 *      msgId: // value for 'msgId'
 *   },
 * });
 */
export function useSetNotifiedUpToIndexMutation(baseOptions?: Apollo.MutationHookOptions<SetNotifiedUpToIndexMutation, SetNotifiedUpToIndexMutationVariables>) {
        return Apollo.useMutation<SetNotifiedUpToIndexMutation, SetNotifiedUpToIndexMutationVariables>(SetNotifiedUpToIndexDocument, baseOptions);
      }
export type SetNotifiedUpToIndexMutationHookResult = ReturnType<typeof useSetNotifiedUpToIndexMutation>;
export type SetNotifiedUpToIndexMutationResult = Apollo.MutationResult<SetNotifiedUpToIndexMutation>;
export type SetNotifiedUpToIndexMutationOptions = Apollo.BaseMutationOptions<SetNotifiedUpToIndexMutation, SetNotifiedUpToIndexMutationVariables>;
export const GetChatPathDocument = gql`
    query GetChatPath($chatId: uuid!) {
  chat_Chat_by_pk(id: $chatId) {
    id
    room {
      id
    }
    contentGroup {
      id
    }
  }
}
    `;

/**
 * __useGetChatPathQuery__
 *
 * To run a query within a React component, call `useGetChatPathQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChatPathQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChatPathQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *   },
 * });
 */
export function useGetChatPathQuery(baseOptions: Apollo.QueryHookOptions<GetChatPathQuery, GetChatPathQueryVariables>) {
        return Apollo.useQuery<GetChatPathQuery, GetChatPathQueryVariables>(GetChatPathDocument, baseOptions);
      }
export function useGetChatPathLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetChatPathQuery, GetChatPathQueryVariables>) {
          return Apollo.useLazyQuery<GetChatPathQuery, GetChatPathQueryVariables>(GetChatPathDocument, baseOptions);
        }
export type GetChatPathQueryHookResult = ReturnType<typeof useGetChatPathQuery>;
export type GetChatPathLazyQueryHookResult = ReturnType<typeof useGetChatPathLazyQuery>;
export type GetChatPathQueryResult = Apollo.QueryResult<GetChatPathQuery, GetChatPathQueryVariables>;
export const SendChatMessageDocument = gql`
    mutation SendChatMessage($chatId: uuid!, $senderId: uuid!, $type: chat_MessageType_enum!, $message: String!, $data: jsonb = {}, $isPinned: Boolean = false, $chatTitle: String = " ", $senderName: String = " ") {
  insert_chat_Message(
    objects: {chatId: $chatId, data: $data, isPinned: $isPinned, message: $message, senderId: $senderId, type: $type, chatTitle: $chatTitle, senderName: $senderName}
  ) {
    returning {
      id
      duplicatedMessageId
    }
  }
}
    `;
export type SendChatMessageMutationFn = Apollo.MutationFunction<SendChatMessageMutation, SendChatMessageMutationVariables>;

/**
 * __useSendChatMessageMutation__
 *
 * To run a mutation, you first call `useSendChatMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendChatMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendChatMessageMutation, { data, loading, error }] = useSendChatMessageMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      senderId: // value for 'senderId'
 *      type: // value for 'type'
 *      message: // value for 'message'
 *      data: // value for 'data'
 *      isPinned: // value for 'isPinned'
 *      chatTitle: // value for 'chatTitle'
 *      senderName: // value for 'senderName'
 *   },
 * });
 */
export function useSendChatMessageMutation(baseOptions?: Apollo.MutationHookOptions<SendChatMessageMutation, SendChatMessageMutationVariables>) {
        return Apollo.useMutation<SendChatMessageMutation, SendChatMessageMutationVariables>(SendChatMessageDocument, baseOptions);
      }
export type SendChatMessageMutationHookResult = ReturnType<typeof useSendChatMessageMutation>;
export type SendChatMessageMutationResult = Apollo.MutationResult<SendChatMessageMutation>;
export type SendChatMessageMutationOptions = Apollo.BaseMutationOptions<SendChatMessageMutation, SendChatMessageMutationVariables>;
export const SendChatAnswerDocument = gql`
    mutation SendChatAnswer($data: jsonb!, $senderId: uuid!, $answeringId: Int!) {
  insert_chat_Reaction(
    objects: {messageId: $answeringId, senderId: $senderId, symbol: "ANSWER", type: ANSWER, data: $data}
  ) {
    affected_rows
  }
}
    `;
export type SendChatAnswerMutationFn = Apollo.MutationFunction<SendChatAnswerMutation, SendChatAnswerMutationVariables>;

/**
 * __useSendChatAnswerMutation__
 *
 * To run a mutation, you first call `useSendChatAnswerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendChatAnswerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendChatAnswerMutation, { data, loading, error }] = useSendChatAnswerMutation({
 *   variables: {
 *      data: // value for 'data'
 *      senderId: // value for 'senderId'
 *      answeringId: // value for 'answeringId'
 *   },
 * });
 */
export function useSendChatAnswerMutation(baseOptions?: Apollo.MutationHookOptions<SendChatAnswerMutation, SendChatAnswerMutationVariables>) {
        return Apollo.useMutation<SendChatAnswerMutation, SendChatAnswerMutationVariables>(SendChatAnswerDocument, baseOptions);
      }
export type SendChatAnswerMutationHookResult = ReturnType<typeof useSendChatAnswerMutation>;
export type SendChatAnswerMutationResult = Apollo.MutationResult<SendChatAnswerMutation>;
export type SendChatAnswerMutationOptions = Apollo.BaseMutationOptions<SendChatAnswerMutation, SendChatAnswerMutationVariables>;
export const AddReactionDocument = gql`
    mutation AddReaction($reaction: chat_Reaction_insert_input!) {
  insert_chat_Reaction(objects: [$reaction]) {
    affected_rows
  }
}
    `;
export type AddReactionMutationFn = Apollo.MutationFunction<AddReactionMutation, AddReactionMutationVariables>;

/**
 * __useAddReactionMutation__
 *
 * To run a mutation, you first call `useAddReactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddReactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addReactionMutation, { data, loading, error }] = useAddReactionMutation({
 *   variables: {
 *      reaction: // value for 'reaction'
 *   },
 * });
 */
export function useAddReactionMutation(baseOptions?: Apollo.MutationHookOptions<AddReactionMutation, AddReactionMutationVariables>) {
        return Apollo.useMutation<AddReactionMutation, AddReactionMutationVariables>(AddReactionDocument, baseOptions);
      }
export type AddReactionMutationHookResult = ReturnType<typeof useAddReactionMutation>;
export type AddReactionMutationResult = Apollo.MutationResult<AddReactionMutation>;
export type AddReactionMutationOptions = Apollo.BaseMutationOptions<AddReactionMutation, AddReactionMutationVariables>;
export const DeleteReactionDocument = gql`
    mutation DeleteReaction($reactionId: Int!) {
  delete_chat_Reaction_by_pk(id: $reactionId) {
    id
  }
}
    `;
export type DeleteReactionMutationFn = Apollo.MutationFunction<DeleteReactionMutation, DeleteReactionMutationVariables>;

/**
 * __useDeleteReactionMutation__
 *
 * To run a mutation, you first call `useDeleteReactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteReactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteReactionMutation, { data, loading, error }] = useDeleteReactionMutation({
 *   variables: {
 *      reactionId: // value for 'reactionId'
 *   },
 * });
 */
export function useDeleteReactionMutation(baseOptions?: Apollo.MutationHookOptions<DeleteReactionMutation, DeleteReactionMutationVariables>) {
        return Apollo.useMutation<DeleteReactionMutation, DeleteReactionMutationVariables>(DeleteReactionDocument, baseOptions);
      }
export type DeleteReactionMutationHookResult = ReturnType<typeof useDeleteReactionMutation>;
export type DeleteReactionMutationResult = Apollo.MutationResult<DeleteReactionMutation>;
export type DeleteReactionMutationOptions = Apollo.BaseMutationOptions<DeleteReactionMutation, DeleteReactionMutationVariables>;
export const SelectReadUpToIndexDocument = gql`
    query SelectReadUpToIndex($chatId: uuid!, $attendeeId: uuid!) {
  chat_ReadUpToIndex_by_pk(chatId: $chatId, attendeeId: $attendeeId) {
    chatId
    attendeeId
    messageId
  }
}
    `;

/**
 * __useSelectReadUpToIndexQuery__
 *
 * To run a query within a React component, call `useSelectReadUpToIndexQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectReadUpToIndexQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectReadUpToIndexQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useSelectReadUpToIndexQuery(baseOptions: Apollo.QueryHookOptions<SelectReadUpToIndexQuery, SelectReadUpToIndexQueryVariables>) {
        return Apollo.useQuery<SelectReadUpToIndexQuery, SelectReadUpToIndexQueryVariables>(SelectReadUpToIndexDocument, baseOptions);
      }
export function useSelectReadUpToIndexLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectReadUpToIndexQuery, SelectReadUpToIndexQueryVariables>) {
          return Apollo.useLazyQuery<SelectReadUpToIndexQuery, SelectReadUpToIndexQueryVariables>(SelectReadUpToIndexDocument, baseOptions);
        }
export type SelectReadUpToIndexQueryHookResult = ReturnType<typeof useSelectReadUpToIndexQuery>;
export type SelectReadUpToIndexLazyQueryHookResult = ReturnType<typeof useSelectReadUpToIndexLazyQuery>;
export type SelectReadUpToIndexQueryResult = Apollo.QueryResult<SelectReadUpToIndexQuery, SelectReadUpToIndexQueryVariables>;
export const SetReadUpToIndexDocument = gql`
    mutation SetReadUpToIndex($chatId: uuid!, $attendeeId: uuid!, $messageId: Int!) {
  insert_chat_ReadUpToIndex(
    objects: {attendeeId: $attendeeId, chatId: $chatId, messageId: $messageId}
    on_conflict: {constraint: ReadUpToIndex_pkey, update_columns: [messageId]}
  ) {
    affected_rows
  }
}
    `;
export type SetReadUpToIndexMutationFn = Apollo.MutationFunction<SetReadUpToIndexMutation, SetReadUpToIndexMutationVariables>;

/**
 * __useSetReadUpToIndexMutation__
 *
 * To run a mutation, you first call `useSetReadUpToIndexMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetReadUpToIndexMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setReadUpToIndexMutation, { data, loading, error }] = useSetReadUpToIndexMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *      messageId: // value for 'messageId'
 *   },
 * });
 */
export function useSetReadUpToIndexMutation(baseOptions?: Apollo.MutationHookOptions<SetReadUpToIndexMutation, SetReadUpToIndexMutationVariables>) {
        return Apollo.useMutation<SetReadUpToIndexMutation, SetReadUpToIndexMutationVariables>(SetReadUpToIndexDocument, baseOptions);
      }
export type SetReadUpToIndexMutationHookResult = ReturnType<typeof useSetReadUpToIndexMutation>;
export type SetReadUpToIndexMutationResult = Apollo.MutationResult<SetReadUpToIndexMutation>;
export type SetReadUpToIndexMutationOptions = Apollo.BaseMutationOptions<SetReadUpToIndexMutation, SetReadUpToIndexMutationVariables>;
export const SelectFirstMessagesPageDocument = gql`
    query SelectFirstMessagesPage($chatId: uuid!, $maxCount: Int!) {
  chat_Message(
    order_by: {id: desc}
    where: {chatId: {_eq: $chatId}}
    limit: $maxCount
  ) {
    ...ChatMessageData
  }
}
    ${ChatMessageDataFragmentDoc}`;

/**
 * __useSelectFirstMessagesPageQuery__
 *
 * To run a query within a React component, call `useSelectFirstMessagesPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectFirstMessagesPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectFirstMessagesPageQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      maxCount: // value for 'maxCount'
 *   },
 * });
 */
export function useSelectFirstMessagesPageQuery(baseOptions: Apollo.QueryHookOptions<SelectFirstMessagesPageQuery, SelectFirstMessagesPageQueryVariables>) {
        return Apollo.useQuery<SelectFirstMessagesPageQuery, SelectFirstMessagesPageQueryVariables>(SelectFirstMessagesPageDocument, baseOptions);
      }
export function useSelectFirstMessagesPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectFirstMessagesPageQuery, SelectFirstMessagesPageQueryVariables>) {
          return Apollo.useLazyQuery<SelectFirstMessagesPageQuery, SelectFirstMessagesPageQueryVariables>(SelectFirstMessagesPageDocument, baseOptions);
        }
export type SelectFirstMessagesPageQueryHookResult = ReturnType<typeof useSelectFirstMessagesPageQuery>;
export type SelectFirstMessagesPageLazyQueryHookResult = ReturnType<typeof useSelectFirstMessagesPageLazyQuery>;
export type SelectFirstMessagesPageQueryResult = Apollo.QueryResult<SelectFirstMessagesPageQuery, SelectFirstMessagesPageQueryVariables>;
export const SelectMessagesPageDocument = gql`
    query SelectMessagesPage($chatId: uuid!, $startAtIndex: Int!, $maxCount: Int!) {
  chat_Message(
    order_by: {id: desc}
    where: {chatId: {_eq: $chatId}, id: {_lte: $startAtIndex}}
    limit: $maxCount
  ) {
    ...ChatMessageData
  }
}
    ${ChatMessageDataFragmentDoc}`;

/**
 * __useSelectMessagesPageQuery__
 *
 * To run a query within a React component, call `useSelectMessagesPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectMessagesPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectMessagesPageQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      startAtIndex: // value for 'startAtIndex'
 *      maxCount: // value for 'maxCount'
 *   },
 * });
 */
export function useSelectMessagesPageQuery(baseOptions: Apollo.QueryHookOptions<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>) {
        return Apollo.useQuery<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>(SelectMessagesPageDocument, baseOptions);
      }
export function useSelectMessagesPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>) {
          return Apollo.useLazyQuery<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>(SelectMessagesPageDocument, baseOptions);
        }
export type SelectMessagesPageQueryHookResult = ReturnType<typeof useSelectMessagesPageQuery>;
export type SelectMessagesPageLazyQueryHookResult = ReturnType<typeof useSelectMessagesPageLazyQuery>;
export type SelectMessagesPageQueryResult = Apollo.QueryResult<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>;
export const SelectSingleMessageDocument = gql`
    query SelectSingleMessage($id: Int!) {
  chat_Message_by_pk(id: $id) {
    ...ChatMessageData
  }
}
    ${ChatMessageDataFragmentDoc}`;

/**
 * __useSelectSingleMessageQuery__
 *
 * To run a query within a React component, call `useSelectSingleMessageQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectSingleMessageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectSingleMessageQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSelectSingleMessageQuery(baseOptions: Apollo.QueryHookOptions<SelectSingleMessageQuery, SelectSingleMessageQueryVariables>) {
        return Apollo.useQuery<SelectSingleMessageQuery, SelectSingleMessageQueryVariables>(SelectSingleMessageDocument, baseOptions);
      }
export function useSelectSingleMessageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectSingleMessageQuery, SelectSingleMessageQueryVariables>) {
          return Apollo.useLazyQuery<SelectSingleMessageQuery, SelectSingleMessageQueryVariables>(SelectSingleMessageDocument, baseOptions);
        }
export type SelectSingleMessageQueryHookResult = ReturnType<typeof useSelectSingleMessageQuery>;
export type SelectSingleMessageLazyQueryHookResult = ReturnType<typeof useSelectSingleMessageLazyQuery>;
export type SelectSingleMessageQueryResult = Apollo.QueryResult<SelectSingleMessageQuery, SelectSingleMessageQueryVariables>;
export const DeleteMessageDocument = gql`
    mutation DeleteMessage($id: Int!) {
  delete_chat_Message_by_pk(id: $id) {
    id
  }
}
    `;
export type DeleteMessageMutationFn = Apollo.MutationFunction<DeleteMessageMutation, DeleteMessageMutationVariables>;

/**
 * __useDeleteMessageMutation__
 *
 * To run a mutation, you first call `useDeleteMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteMessageMutation, { data, loading, error }] = useDeleteMessageMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteMessageMutation(baseOptions?: Apollo.MutationHookOptions<DeleteMessageMutation, DeleteMessageMutationVariables>) {
        return Apollo.useMutation<DeleteMessageMutation, DeleteMessageMutationVariables>(DeleteMessageDocument, baseOptions);
      }
export type DeleteMessageMutationHookResult = ReturnType<typeof useDeleteMessageMutation>;
export type DeleteMessageMutationResult = Apollo.MutationResult<DeleteMessageMutation>;
export type DeleteMessageMutationOptions = Apollo.BaseMutationOptions<DeleteMessageMutation, DeleteMessageMutationVariables>;
export const NextMessageDocument = gql`
    subscription NextMessage($prevId: Int!, $chatId: uuid!) {
  chat_Message(
    order_by: {id: desc}
    where: {id: {_gt: $prevId}, chatId: {_eq: $chatId}}
    limit: 1
  ) {
    ...SubscribedChatMessageData
  }
}
    ${SubscribedChatMessageDataFragmentDoc}`;

/**
 * __useNextMessageSubscription__
 *
 * To run a query within a React component, call `useNextMessageSubscription` and pass it any options that fit your needs.
 * When your component renders, `useNextMessageSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNextMessageSubscription({
 *   variables: {
 *      prevId: // value for 'prevId'
 *      chatId: // value for 'chatId'
 *   },
 * });
 */
export function useNextMessageSubscription(baseOptions: Apollo.SubscriptionHookOptions<NextMessageSubscription, NextMessageSubscriptionVariables>) {
        return Apollo.useSubscription<NextMessageSubscription, NextMessageSubscriptionVariables>(NextMessageDocument, baseOptions);
      }
export type NextMessageSubscriptionHookResult = ReturnType<typeof useNextMessageSubscription>;
export type NextMessageSubscriptionResult = Apollo.SubscriptionResult<NextMessageSubscription>;
export const NextReactionsDocument = gql`
    subscription NextReactions($messageIds: [Int!]!) {
  chat_Reaction(where: {messageId: {_in: $messageIds}}) {
    ...SubscribedChatReactionData
  }
}
    ${SubscribedChatReactionDataFragmentDoc}`;

/**
 * __useNextReactionsSubscription__
 *
 * To run a query within a React component, call `useNextReactionsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useNextReactionsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNextReactionsSubscription({
 *   variables: {
 *      messageIds: // value for 'messageIds'
 *   },
 * });
 */
export function useNextReactionsSubscription(baseOptions: Apollo.SubscriptionHookOptions<NextReactionsSubscription, NextReactionsSubscriptionVariables>) {
        return Apollo.useSubscription<NextReactionsSubscription, NextReactionsSubscriptionVariables>(NextReactionsDocument, baseOptions);
      }
export type NextReactionsSubscriptionHookResult = ReturnType<typeof useNextReactionsSubscription>;
export type NextReactionsSubscriptionResult = Apollo.SubscriptionResult<NextReactionsSubscription>;
export const SelectPinDocument = gql`
    query SelectPin($chatId: uuid!, $attendeeId: uuid!) {
  chat_Chat_by_pk(id: $chatId) {
    ...ChatPinConfig
  }
  chat_Pin(where: {chatId: {_eq: $chatId}, attendeeId: {_eq: $attendeeId}}) {
    ...PinData
  }
}
    ${ChatPinConfigFragmentDoc}
${PinDataFragmentDoc}`;

/**
 * __useSelectPinQuery__
 *
 * To run a query within a React component, call `useSelectPinQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectPinQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectPinQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useSelectPinQuery(baseOptions: Apollo.QueryHookOptions<SelectPinQuery, SelectPinQueryVariables>) {
        return Apollo.useQuery<SelectPinQuery, SelectPinQueryVariables>(SelectPinDocument, baseOptions);
      }
export function useSelectPinLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectPinQuery, SelectPinQueryVariables>) {
          return Apollo.useLazyQuery<SelectPinQuery, SelectPinQueryVariables>(SelectPinDocument, baseOptions);
        }
export type SelectPinQueryHookResult = ReturnType<typeof useSelectPinQuery>;
export type SelectPinLazyQueryHookResult = ReturnType<typeof useSelectPinLazyQuery>;
export type SelectPinQueryResult = Apollo.QueryResult<SelectPinQuery, SelectPinQueryVariables>;
export const PinChatDocument = gql`
    mutation PinChat($chatId: uuid!, $attendeeId: uuid!) {
  insert_chat_Pin(
    objects: {chatId: $chatId, attendeeId: $attendeeId}
    on_conflict: {constraint: ChatPin_pkey, update_columns: wasManuallyPinned}
  ) {
    returning {
      ...PinData
    }
  }
}
    ${PinDataFragmentDoc}`;
export type PinChatMutationFn = Apollo.MutationFunction<PinChatMutation, PinChatMutationVariables>;

/**
 * __usePinChatMutation__
 *
 * To run a mutation, you first call `usePinChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePinChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [pinChatMutation, { data, loading, error }] = usePinChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function usePinChatMutation(baseOptions?: Apollo.MutationHookOptions<PinChatMutation, PinChatMutationVariables>) {
        return Apollo.useMutation<PinChatMutation, PinChatMutationVariables>(PinChatDocument, baseOptions);
      }
export type PinChatMutationHookResult = ReturnType<typeof usePinChatMutation>;
export type PinChatMutationResult = Apollo.MutationResult<PinChatMutation>;
export type PinChatMutationOptions = Apollo.BaseMutationOptions<PinChatMutation, PinChatMutationVariables>;
export const UnpinChatDocument = gql`
    mutation UnpinChat($chatId: uuid!, $attendeeId: uuid!) {
  delete_chat_Pin_by_pk(chatId: $chatId, attendeeId: $attendeeId) {
    ...PinData
  }
}
    ${PinDataFragmentDoc}`;
export type UnpinChatMutationFn = Apollo.MutationFunction<UnpinChatMutation, UnpinChatMutationVariables>;

/**
 * __useUnpinChatMutation__
 *
 * To run a mutation, you first call `useUnpinChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpinChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpinChatMutation, { data, loading, error }] = useUnpinChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useUnpinChatMutation(baseOptions?: Apollo.MutationHookOptions<UnpinChatMutation, UnpinChatMutationVariables>) {
        return Apollo.useMutation<UnpinChatMutation, UnpinChatMutationVariables>(UnpinChatDocument, baseOptions);
      }
export type UnpinChatMutationHookResult = ReturnType<typeof useUnpinChatMutation>;
export type UnpinChatMutationResult = Apollo.MutationResult<UnpinChatMutation>;
export type UnpinChatMutationOptions = Apollo.BaseMutationOptions<UnpinChatMutation, UnpinChatMutationVariables>;
export const SelectSubscriptionDocument = gql`
    query SelectSubscription($chatId: uuid!, $attendeeId: uuid!) {
  chat_Chat_by_pk(id: $chatId) {
    ...ChatSubscriptionConfig
  }
  chat_Subscription(
    where: {chatId: {_eq: $chatId}, attendeeId: {_eq: $attendeeId}}
  ) {
    ...SubscriptionData
  }
}
    ${ChatSubscriptionConfigFragmentDoc}
${SubscriptionDataFragmentDoc}`;

/**
 * __useSelectSubscriptionQuery__
 *
 * To run a query within a React component, call `useSelectSubscriptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectSubscriptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectSubscriptionQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useSelectSubscriptionQuery(baseOptions: Apollo.QueryHookOptions<SelectSubscriptionQuery, SelectSubscriptionQueryVariables>) {
        return Apollo.useQuery<SelectSubscriptionQuery, SelectSubscriptionQueryVariables>(SelectSubscriptionDocument, baseOptions);
      }
export function useSelectSubscriptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectSubscriptionQuery, SelectSubscriptionQueryVariables>) {
          return Apollo.useLazyQuery<SelectSubscriptionQuery, SelectSubscriptionQueryVariables>(SelectSubscriptionDocument, baseOptions);
        }
export type SelectSubscriptionQueryHookResult = ReturnType<typeof useSelectSubscriptionQuery>;
export type SelectSubscriptionLazyQueryHookResult = ReturnType<typeof useSelectSubscriptionLazyQuery>;
export type SelectSubscriptionQueryResult = Apollo.QueryResult<SelectSubscriptionQuery, SelectSubscriptionQueryVariables>;
export const SubscribeChatDocument = gql`
    mutation SubscribeChat($chatId: uuid!, $attendeeId: uuid!) {
  insert_chat_Subscription(
    objects: {chatId: $chatId, attendeeId: $attendeeId}
    on_conflict: {constraint: Subscription_pkey, update_columns: wasManuallySubscribed}
  ) {
    returning {
      ...SubscriptionData
    }
  }
  insert_chat_ReadUpToIndex(
    objects: {chatId: $chatId, attendeeId: $attendeeId, messageId: -1}
    on_conflict: {constraint: ReadUpToIndex_pkey, update_columns: []}
  ) {
    affected_rows
  }
}
    ${SubscriptionDataFragmentDoc}`;
export type SubscribeChatMutationFn = Apollo.MutationFunction<SubscribeChatMutation, SubscribeChatMutationVariables>;

/**
 * __useSubscribeChatMutation__
 *
 * To run a mutation, you first call `useSubscribeChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubscribeChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [subscribeChatMutation, { data, loading, error }] = useSubscribeChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useSubscribeChatMutation(baseOptions?: Apollo.MutationHookOptions<SubscribeChatMutation, SubscribeChatMutationVariables>) {
        return Apollo.useMutation<SubscribeChatMutation, SubscribeChatMutationVariables>(SubscribeChatDocument, baseOptions);
      }
export type SubscribeChatMutationHookResult = ReturnType<typeof useSubscribeChatMutation>;
export type SubscribeChatMutationResult = Apollo.MutationResult<SubscribeChatMutation>;
export type SubscribeChatMutationOptions = Apollo.BaseMutationOptions<SubscribeChatMutation, SubscribeChatMutationVariables>;
export const UnsubscribeChatDocument = gql`
    mutation UnsubscribeChat($chatId: uuid!, $attendeeId: uuid!) {
  delete_chat_Subscription_by_pk(chatId: $chatId, attendeeId: $attendeeId) {
    ...SubscriptionData
  }
}
    ${SubscriptionDataFragmentDoc}`;
export type UnsubscribeChatMutationFn = Apollo.MutationFunction<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>;

/**
 * __useUnsubscribeChatMutation__
 *
 * To run a mutation, you first call `useUnsubscribeChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnsubscribeChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unsubscribeChatMutation, { data, loading, error }] = useUnsubscribeChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useUnsubscribeChatMutation(baseOptions?: Apollo.MutationHookOptions<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>) {
        return Apollo.useMutation<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>(UnsubscribeChatDocument, baseOptions);
      }
export type UnsubscribeChatMutationHookResult = ReturnType<typeof useUnsubscribeChatMutation>;
export type UnsubscribeChatMutationResult = Apollo.MutationResult<UnsubscribeChatMutation>;
export type UnsubscribeChatMutationOptions = Apollo.BaseMutationOptions<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>;
export const SelectAttendeesDocument = gql`
    query SelectAttendees($conferenceId: uuid!) {
  Attendee(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {displayName: asc}
  ) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useSelectAttendeesQuery__
 *
 * To run a query within a React component, call `useSelectAttendeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAttendeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAttendeesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAttendeesQuery(baseOptions: Apollo.QueryHookOptions<SelectAttendeesQuery, SelectAttendeesQueryVariables>) {
        return Apollo.useQuery<SelectAttendeesQuery, SelectAttendeesQueryVariables>(SelectAttendeesDocument, baseOptions);
      }
export function useSelectAttendeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAttendeesQuery, SelectAttendeesQueryVariables>) {
          return Apollo.useLazyQuery<SelectAttendeesQuery, SelectAttendeesQueryVariables>(SelectAttendeesDocument, baseOptions);
        }
export type SelectAttendeesQueryHookResult = ReturnType<typeof useSelectAttendeesQuery>;
export type SelectAttendeesLazyQueryHookResult = ReturnType<typeof useSelectAttendeesLazyQuery>;
export type SelectAttendeesQueryResult = Apollo.QueryResult<SelectAttendeesQuery, SelectAttendeesQueryVariables>;
export const SearchAttendeesDocument = gql`
    query SearchAttendees($conferenceId: uuid!, $search: String!) {
  Attendee(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {_or: [{displayName: {_ilike: $search}}, {profile: {_or: [{affiliation: {_ilike: $search}}, {bio: {_ilike: $search}}]}}]}]}
    order_by: {displayName: asc}
  ) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useSearchAttendeesQuery__
 *
 * To run a query within a React component, call `useSearchAttendeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchAttendeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchAttendeesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useSearchAttendeesQuery(baseOptions: Apollo.QueryHookOptions<SearchAttendeesQuery, SearchAttendeesQueryVariables>) {
        return Apollo.useQuery<SearchAttendeesQuery, SearchAttendeesQueryVariables>(SearchAttendeesDocument, baseOptions);
      }
export function useSearchAttendeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchAttendeesQuery, SearchAttendeesQueryVariables>) {
          return Apollo.useLazyQuery<SearchAttendeesQuery, SearchAttendeesQueryVariables>(SearchAttendeesDocument, baseOptions);
        }
export type SearchAttendeesQueryHookResult = ReturnType<typeof useSearchAttendeesQuery>;
export type SearchAttendeesLazyQueryHookResult = ReturnType<typeof useSearchAttendeesLazyQuery>;
export type SearchAttendeesQueryResult = Apollo.QueryResult<SearchAttendeesQuery, SearchAttendeesQueryVariables>;
export const ConferenceLandingPageContentGroupDocument = gql`
    query ConferenceLandingPageContentGroup($conferenceId: uuid!) {
  ContentGroup(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {contentGroupTypeName: {_eq: LANDING_PAGE}}]}
  ) {
    ...ContentGroupData
  }
}
    ${ContentGroupDataFragmentDoc}`;

/**
 * __useConferenceLandingPageContentGroupQuery__
 *
 * To run a query within a React component, call `useConferenceLandingPageContentGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceLandingPageContentGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceLandingPageContentGroupQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferenceLandingPageContentGroupQuery(baseOptions: Apollo.QueryHookOptions<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>) {
        return Apollo.useQuery<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>(ConferenceLandingPageContentGroupDocument, baseOptions);
      }
export function useConferenceLandingPageContentGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>) {
          return Apollo.useLazyQuery<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>(ConferenceLandingPageContentGroupDocument, baseOptions);
        }
export type ConferenceLandingPageContentGroupQueryHookResult = ReturnType<typeof useConferenceLandingPageContentGroupQuery>;
export type ConferenceLandingPageContentGroupLazyQueryHookResult = ReturnType<typeof useConferenceLandingPageContentGroupLazyQuery>;
export type ConferenceLandingPageContentGroupQueryResult = Apollo.QueryResult<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>;
export const ContentOfTagDocument = gql`
    query ContentOfTag($id: uuid!) {
  ContentGroupTag(where: {tagId: {_eq: $id}}) {
    ...ContentGroupList_ContentGroupTagData
  }
}
    ${ContentGroupList_ContentGroupTagDataFragmentDoc}`;

/**
 * __useContentOfTagQuery__
 *
 * To run a query within a React component, call `useContentOfTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useContentOfTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContentOfTagQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useContentOfTagQuery(baseOptions: Apollo.QueryHookOptions<ContentOfTagQuery, ContentOfTagQueryVariables>) {
        return Apollo.useQuery<ContentOfTagQuery, ContentOfTagQueryVariables>(ContentOfTagDocument, baseOptions);
      }
export function useContentOfTagLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContentOfTagQuery, ContentOfTagQueryVariables>) {
          return Apollo.useLazyQuery<ContentOfTagQuery, ContentOfTagQueryVariables>(ContentOfTagDocument, baseOptions);
        }
export type ContentOfTagQueryHookResult = ReturnType<typeof useContentOfTagQuery>;
export type ContentOfTagLazyQueryHookResult = ReturnType<typeof useContentOfTagLazyQuery>;
export type ContentOfTagQueryResult = Apollo.QueryResult<ContentOfTagQuery, ContentOfTagQueryVariables>;
export const TagsDocument = gql`
    query Tags($conferenceId: uuid!) {
  Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ContentGroupList_TagInfo
  }
}
    ${ContentGroupList_TagInfoFragmentDoc}`;

/**
 * __useTagsQuery__
 *
 * To run a query within a React component, call `useTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useTagsQuery(baseOptions: Apollo.QueryHookOptions<TagsQuery, TagsQueryVariables>) {
        return Apollo.useQuery<TagsQuery, TagsQueryVariables>(TagsDocument, baseOptions);
      }
export function useTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TagsQuery, TagsQueryVariables>) {
          return Apollo.useLazyQuery<TagsQuery, TagsQueryVariables>(TagsDocument, baseOptions);
        }
export type TagsQueryHookResult = ReturnType<typeof useTagsQuery>;
export type TagsLazyQueryHookResult = ReturnType<typeof useTagsLazyQuery>;
export type TagsQueryResult = Apollo.QueryResult<TagsQuery, TagsQueryVariables>;
export const GetContentGroupDocument = gql`
    query GetContentGroup($contentGroupId: uuid!) {
  ContentGroup_by_pk(id: $contentGroupId) {
    ...ContentGroupData
    ...ContentGroupEvents
    ...ContentGroupPage_ContentGroupRooms
  }
}
    ${ContentGroupDataFragmentDoc}
${ContentGroupEventsFragmentDoc}
${ContentGroupPage_ContentGroupRoomsFragmentDoc}`;

/**
 * __useGetContentGroupQuery__
 *
 * To run a query within a React component, call `useGetContentGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetContentGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetContentGroupQuery({
 *   variables: {
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useGetContentGroupQuery(baseOptions: Apollo.QueryHookOptions<GetContentGroupQuery, GetContentGroupQueryVariables>) {
        return Apollo.useQuery<GetContentGroupQuery, GetContentGroupQueryVariables>(GetContentGroupDocument, baseOptions);
      }
export function useGetContentGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetContentGroupQuery, GetContentGroupQueryVariables>) {
          return Apollo.useLazyQuery<GetContentGroupQuery, GetContentGroupQueryVariables>(GetContentGroupDocument, baseOptions);
        }
export type GetContentGroupQueryHookResult = ReturnType<typeof useGetContentGroupQuery>;
export type GetContentGroupLazyQueryHookResult = ReturnType<typeof useGetContentGroupLazyQuery>;
export type GetContentGroupQueryResult = Apollo.QueryResult<GetContentGroupQuery, GetContentGroupQueryVariables>;
export const ContentGroup_CreateRoomDocument = gql`
    mutation ContentGroup_CreateRoom($conferenceId: uuid!, $contentGroupId: uuid!) {
  createContentGroupRoom(
    conferenceId: $conferenceId
    contentGroupId: $contentGroupId
  ) {
    roomId
    message
  }
}
    `;
export type ContentGroup_CreateRoomMutationFn = Apollo.MutationFunction<ContentGroup_CreateRoomMutation, ContentGroup_CreateRoomMutationVariables>;

/**
 * __useContentGroup_CreateRoomMutation__
 *
 * To run a mutation, you first call `useContentGroup_CreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useContentGroup_CreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [contentGroupCreateRoomMutation, { data, loading, error }] = useContentGroup_CreateRoomMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useContentGroup_CreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<ContentGroup_CreateRoomMutation, ContentGroup_CreateRoomMutationVariables>) {
        return Apollo.useMutation<ContentGroup_CreateRoomMutation, ContentGroup_CreateRoomMutationVariables>(ContentGroup_CreateRoomDocument, baseOptions);
      }
export type ContentGroup_CreateRoomMutationHookResult = ReturnType<typeof useContentGroup_CreateRoomMutation>;
export type ContentGroup_CreateRoomMutationResult = Apollo.MutationResult<ContentGroup_CreateRoomMutation>;
export type ContentGroup_CreateRoomMutationOptions = Apollo.BaseMutationOptions<ContentGroup_CreateRoomMutation, ContentGroup_CreateRoomMutationVariables>;
export const ContentGroupSummary_GetContentGroupDocument = gql`
    query ContentGroupSummary_GetContentGroup($contentGroupId: uuid!) {
  ContentGroup_by_pk(id: $contentGroupId) {
    ...ContentGroupSummary_ContentGroupData
  }
}
    ${ContentGroupSummary_ContentGroupDataFragmentDoc}`;

/**
 * __useContentGroupSummary_GetContentGroupQuery__
 *
 * To run a query within a React component, call `useContentGroupSummary_GetContentGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useContentGroupSummary_GetContentGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContentGroupSummary_GetContentGroupQuery({
 *   variables: {
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useContentGroupSummary_GetContentGroupQuery(baseOptions: Apollo.QueryHookOptions<ContentGroupSummary_GetContentGroupQuery, ContentGroupSummary_GetContentGroupQueryVariables>) {
        return Apollo.useQuery<ContentGroupSummary_GetContentGroupQuery, ContentGroupSummary_GetContentGroupQueryVariables>(ContentGroupSummary_GetContentGroupDocument, baseOptions);
      }
export function useContentGroupSummary_GetContentGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContentGroupSummary_GetContentGroupQuery, ContentGroupSummary_GetContentGroupQueryVariables>) {
          return Apollo.useLazyQuery<ContentGroupSummary_GetContentGroupQuery, ContentGroupSummary_GetContentGroupQueryVariables>(ContentGroupSummary_GetContentGroupDocument, baseOptions);
        }
export type ContentGroupSummary_GetContentGroupQueryHookResult = ReturnType<typeof useContentGroupSummary_GetContentGroupQuery>;
export type ContentGroupSummary_GetContentGroupLazyQueryHookResult = ReturnType<typeof useContentGroupSummary_GetContentGroupLazyQuery>;
export type ContentGroupSummary_GetContentGroupQueryResult = Apollo.QueryResult<ContentGroupSummary_GetContentGroupQuery, ContentGroupSummary_GetContentGroupQueryVariables>;
export const UpdateAttendeeProfileDocument = gql`
    mutation UpdateAttendeeProfile($attendeeId: uuid!, $profile: AttendeeProfile_set_input = {}) {
  update_AttendeeProfile_by_pk(
    pk_columns: {attendeeId: $attendeeId}
    _set: $profile
  ) {
    attendeeId
  }
}
    `;
export type UpdateAttendeeProfileMutationFn = Apollo.MutationFunction<UpdateAttendeeProfileMutation, UpdateAttendeeProfileMutationVariables>;

/**
 * __useUpdateAttendeeProfileMutation__
 *
 * To run a mutation, you first call `useUpdateAttendeeProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAttendeeProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAttendeeProfileMutation, { data, loading, error }] = useUpdateAttendeeProfileMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      profile: // value for 'profile'
 *   },
 * });
 */
export function useUpdateAttendeeProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAttendeeProfileMutation, UpdateAttendeeProfileMutationVariables>) {
        return Apollo.useMutation<UpdateAttendeeProfileMutation, UpdateAttendeeProfileMutationVariables>(UpdateAttendeeProfileDocument, baseOptions);
      }
export type UpdateAttendeeProfileMutationHookResult = ReturnType<typeof useUpdateAttendeeProfileMutation>;
export type UpdateAttendeeProfileMutationResult = Apollo.MutationResult<UpdateAttendeeProfileMutation>;
export type UpdateAttendeeProfileMutationOptions = Apollo.BaseMutationOptions<UpdateAttendeeProfileMutation, UpdateAttendeeProfileMutationVariables>;
export const UpdateAttendeeDisplayNameDocument = gql`
    mutation UpdateAttendeeDisplayName($attendeeId: uuid!, $name: String!) {
  update_Attendee_by_pk(pk_columns: {id: $attendeeId}, _set: {displayName: $name}) {
    id
  }
}
    `;
export type UpdateAttendeeDisplayNameMutationFn = Apollo.MutationFunction<UpdateAttendeeDisplayNameMutation, UpdateAttendeeDisplayNameMutationVariables>;

/**
 * __useUpdateAttendeeDisplayNameMutation__
 *
 * To run a mutation, you first call `useUpdateAttendeeDisplayNameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAttendeeDisplayNameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAttendeeDisplayNameMutation, { data, loading, error }] = useUpdateAttendeeDisplayNameMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpdateAttendeeDisplayNameMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAttendeeDisplayNameMutation, UpdateAttendeeDisplayNameMutationVariables>) {
        return Apollo.useMutation<UpdateAttendeeDisplayNameMutation, UpdateAttendeeDisplayNameMutationVariables>(UpdateAttendeeDisplayNameDocument, baseOptions);
      }
export type UpdateAttendeeDisplayNameMutationHookResult = ReturnType<typeof useUpdateAttendeeDisplayNameMutation>;
export type UpdateAttendeeDisplayNameMutationResult = Apollo.MutationResult<UpdateAttendeeDisplayNameMutation>;
export type UpdateAttendeeDisplayNameMutationOptions = Apollo.BaseMutationOptions<UpdateAttendeeDisplayNameMutation, UpdateAttendeeDisplayNameMutationVariables>;
export const SubmitProfilePhotoDocument = gql`
    mutation SubmitProfilePhoto($attendeeId: uuid!, $s3URL: String!) {
  updateProfilePhoto(attendeeId: $attendeeId, s3URL: $s3URL) {
    ok
  }
}
    `;
export type SubmitProfilePhotoMutationFn = Apollo.MutationFunction<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>;

/**
 * __useSubmitProfilePhotoMutation__
 *
 * To run a mutation, you first call `useSubmitProfilePhotoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitProfilePhotoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitProfilePhotoMutation, { data, loading, error }] = useSubmitProfilePhotoMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      s3URL: // value for 's3URL'
 *   },
 * });
 */
export function useSubmitProfilePhotoMutation(baseOptions?: Apollo.MutationHookOptions<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>) {
        return Apollo.useMutation<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>(SubmitProfilePhotoDocument, baseOptions);
      }
export type SubmitProfilePhotoMutationHookResult = ReturnType<typeof useSubmitProfilePhotoMutation>;
export type SubmitProfilePhotoMutationResult = Apollo.MutationResult<SubmitProfilePhotoMutation>;
export type SubmitProfilePhotoMutationOptions = Apollo.BaseMutationOptions<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>;
export const GetRoomVonageTokenDocument = gql`
    mutation GetRoomVonageToken($roomId: uuid!) {
  joinRoomVonageSession(roomId: $roomId) {
    accessToken
    sessionId
  }
}
    `;
export type GetRoomVonageTokenMutationFn = Apollo.MutationFunction<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>;

/**
 * __useGetRoomVonageTokenMutation__
 *
 * To run a mutation, you first call `useGetRoomVonageTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetRoomVonageTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getRoomVonageTokenMutation, { data, loading, error }] = useGetRoomVonageTokenMutation({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomVonageTokenMutation(baseOptions?: Apollo.MutationHookOptions<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>) {
        return Apollo.useMutation<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>(GetRoomVonageTokenDocument, baseOptions);
      }
export type GetRoomVonageTokenMutationHookResult = ReturnType<typeof useGetRoomVonageTokenMutation>;
export type GetRoomVonageTokenMutationResult = Apollo.MutationResult<GetRoomVonageTokenMutation>;
export type GetRoomVonageTokenMutationOptions = Apollo.BaseMutationOptions<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>;
export const CreateDmDocument = gql`
    mutation CreateDm($attendeeIds: [uuid]!, $conferenceId: uuid!) {
  createRoomDm(attendeeIds: $attendeeIds, conferenceId: $conferenceId) {
    message
    roomId
  }
}
    `;
export type CreateDmMutationFn = Apollo.MutationFunction<CreateDmMutation, CreateDmMutationVariables>;

/**
 * __useCreateDmMutation__
 *
 * To run a mutation, you first call `useCreateDmMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDmMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDmMutation, { data, loading, error }] = useCreateDmMutation({
 *   variables: {
 *      attendeeIds: // value for 'attendeeIds'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateDmMutation(baseOptions?: Apollo.MutationHookOptions<CreateDmMutation, CreateDmMutationVariables>) {
        return Apollo.useMutation<CreateDmMutation, CreateDmMutationVariables>(CreateDmDocument, baseOptions);
      }
export type CreateDmMutationHookResult = ReturnType<typeof useCreateDmMutation>;
export type CreateDmMutationResult = Apollo.MutationResult<CreateDmMutation>;
export type CreateDmMutationOptions = Apollo.BaseMutationOptions<CreateDmMutation, CreateDmMutationVariables>;
export const AttendeeCreateRoomDocument = gql`
    mutation AttendeeCreateRoom($conferenceId: uuid!, $name: String!, $roomPrivacyName: RoomPrivacy_enum!) {
  insert_Room_one(
    object: {capacity: 50, conferenceId: $conferenceId, currentModeName: BREAKOUT, name: $name, roomPrivacyName: $roomPrivacyName}
  ) {
    id
  }
}
    `;
export type AttendeeCreateRoomMutationFn = Apollo.MutationFunction<AttendeeCreateRoomMutation, AttendeeCreateRoomMutationVariables>;

/**
 * __useAttendeeCreateRoomMutation__
 *
 * To run a mutation, you first call `useAttendeeCreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAttendeeCreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [attendeeCreateRoomMutation, { data, loading, error }] = useAttendeeCreateRoomMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      name: // value for 'name'
 *      roomPrivacyName: // value for 'roomPrivacyName'
 *   },
 * });
 */
export function useAttendeeCreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<AttendeeCreateRoomMutation, AttendeeCreateRoomMutationVariables>) {
        return Apollo.useMutation<AttendeeCreateRoomMutation, AttendeeCreateRoomMutationVariables>(AttendeeCreateRoomDocument, baseOptions);
      }
export type AttendeeCreateRoomMutationHookResult = ReturnType<typeof useAttendeeCreateRoomMutation>;
export type AttendeeCreateRoomMutationResult = Apollo.MutationResult<AttendeeCreateRoomMutation>;
export type AttendeeCreateRoomMutationOptions = Apollo.BaseMutationOptions<AttendeeCreateRoomMutation, AttendeeCreateRoomMutationVariables>;
export const UpdateEventVonageSessionLayoutDocument = gql`
    mutation UpdateEventVonageSessionLayout($eventVonageSessionId: uuid!, $layoutData: jsonb!) {
  update_EventVonageSession_by_pk(
    pk_columns: {id: $eventVonageSessionId}
    _set: {layoutData: $layoutData}
  ) {
    id
  }
}
    `;
export type UpdateEventVonageSessionLayoutMutationFn = Apollo.MutationFunction<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>;

/**
 * __useUpdateEventVonageSessionLayoutMutation__
 *
 * To run a mutation, you first call `useUpdateEventVonageSessionLayoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventVonageSessionLayoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventVonageSessionLayoutMutation, { data, loading, error }] = useUpdateEventVonageSessionLayoutMutation({
 *   variables: {
 *      eventVonageSessionId: // value for 'eventVonageSessionId'
 *      layoutData: // value for 'layoutData'
 *   },
 * });
 */
export function useUpdateEventVonageSessionLayoutMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>) {
        return Apollo.useMutation<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>(UpdateEventVonageSessionLayoutDocument, baseOptions);
      }
export type UpdateEventVonageSessionLayoutMutationHookResult = ReturnType<typeof useUpdateEventVonageSessionLayoutMutation>;
export type UpdateEventVonageSessionLayoutMutationResult = Apollo.MutationResult<UpdateEventVonageSessionLayoutMutation>;
export type UpdateEventVonageSessionLayoutMutationOptions = Apollo.BaseMutationOptions<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>;
export const DeleteEventPersonDocument = gql`
    mutation DeleteEventPerson($eventPersonId: uuid!) {
  delete_EventPerson_by_pk(id: $eventPersonId) {
    id
  }
}
    `;
export type DeleteEventPersonMutationFn = Apollo.MutationFunction<DeleteEventPersonMutation, DeleteEventPersonMutationVariables>;

/**
 * __useDeleteEventPersonMutation__
 *
 * To run a mutation, you first call `useDeleteEventPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventPersonMutation, { data, loading, error }] = useDeleteEventPersonMutation({
 *   variables: {
 *      eventPersonId: // value for 'eventPersonId'
 *   },
 * });
 */
export function useDeleteEventPersonMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventPersonMutation, DeleteEventPersonMutationVariables>) {
        return Apollo.useMutation<DeleteEventPersonMutation, DeleteEventPersonMutationVariables>(DeleteEventPersonDocument, baseOptions);
      }
export type DeleteEventPersonMutationHookResult = ReturnType<typeof useDeleteEventPersonMutation>;
export type DeleteEventPersonMutationResult = Apollo.MutationResult<DeleteEventPersonMutation>;
export type DeleteEventPersonMutationOptions = Apollo.BaseMutationOptions<DeleteEventPersonMutation, DeleteEventPersonMutationVariables>;
export const GetEventParticipantStreamsDocument = gql`
    subscription GetEventParticipantStreams($eventId: uuid!) {
  EventParticipantStream(where: {eventId: {_eq: $eventId}}) {
    ...EventParticipantStreamDetails
  }
}
    ${EventParticipantStreamDetailsFragmentDoc}`;

/**
 * __useGetEventParticipantStreamsSubscription__
 *
 * To run a query within a React component, call `useGetEventParticipantStreamsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetEventParticipantStreamsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventParticipantStreamsSubscription({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventParticipantStreamsSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetEventParticipantStreamsSubscription, GetEventParticipantStreamsSubscriptionVariables>) {
        return Apollo.useSubscription<GetEventParticipantStreamsSubscription, GetEventParticipantStreamsSubscriptionVariables>(GetEventParticipantStreamsDocument, baseOptions);
      }
export type GetEventParticipantStreamsSubscriptionHookResult = ReturnType<typeof useGetEventParticipantStreamsSubscription>;
export type GetEventParticipantStreamsSubscriptionResult = Apollo.SubscriptionResult<GetEventParticipantStreamsSubscription>;
export const UnapprovedEventRoomJoinRequestsDocument = gql`
    subscription UnapprovedEventRoomJoinRequests($conferenceId: uuid!, $eventId: uuid!) {
  EventRoomJoinRequest(
    where: {conferenceId: {_eq: $conferenceId}, eventId: {_eq: $eventId}, approved: {_eq: false}}
  ) {
    ...EventRoomJoinRequestDetails
  }
}
    ${EventRoomJoinRequestDetailsFragmentDoc}`;

/**
 * __useUnapprovedEventRoomJoinRequestsSubscription__
 *
 * To run a query within a React component, call `useUnapprovedEventRoomJoinRequestsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useUnapprovedEventRoomJoinRequestsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUnapprovedEventRoomJoinRequestsSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useUnapprovedEventRoomJoinRequestsSubscription(baseOptions: Apollo.SubscriptionHookOptions<UnapprovedEventRoomJoinRequestsSubscription, UnapprovedEventRoomJoinRequestsSubscriptionVariables>) {
        return Apollo.useSubscription<UnapprovedEventRoomJoinRequestsSubscription, UnapprovedEventRoomJoinRequestsSubscriptionVariables>(UnapprovedEventRoomJoinRequestsDocument, baseOptions);
      }
export type UnapprovedEventRoomJoinRequestsSubscriptionHookResult = ReturnType<typeof useUnapprovedEventRoomJoinRequestsSubscription>;
export type UnapprovedEventRoomJoinRequestsSubscriptionResult = Apollo.SubscriptionResult<UnapprovedEventRoomJoinRequestsSubscription>;
export const GetEventVonageTokenDocument = gql`
    mutation GetEventVonageToken($eventId: uuid!) {
  joinEventVonageSession(eventId: $eventId) {
    accessToken
  }
}
    `;
export type GetEventVonageTokenMutationFn = Apollo.MutationFunction<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>;

/**
 * __useGetEventVonageTokenMutation__
 *
 * To run a mutation, you first call `useGetEventVonageTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetEventVonageTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getEventVonageTokenMutation, { data, loading, error }] = useGetEventVonageTokenMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventVonageTokenMutation(baseOptions?: Apollo.MutationHookOptions<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>) {
        return Apollo.useMutation<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>(GetEventVonageTokenDocument, baseOptions);
      }
export type GetEventVonageTokenMutationHookResult = ReturnType<typeof useGetEventVonageTokenMutation>;
export type GetEventVonageTokenMutationResult = Apollo.MutationResult<GetEventVonageTokenMutation>;
export type GetEventVonageTokenMutationOptions = Apollo.BaseMutationOptions<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>;
export const GetEventDetailsDocument = gql`
    query GetEventDetails($eventId: uuid!) {
  Event_by_pk(id: $eventId) {
    ...RoomEventDetails
  }
}
    ${RoomEventDetailsFragmentDoc}`;

/**
 * __useGetEventDetailsQuery__
 *
 * To run a query within a React component, call `useGetEventDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventDetailsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
        return Apollo.useQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, baseOptions);
      }
export function useGetEventDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
          return Apollo.useLazyQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, baseOptions);
        }
export type GetEventDetailsQueryHookResult = ReturnType<typeof useGetEventDetailsQuery>;
export type GetEventDetailsLazyQueryHookResult = ReturnType<typeof useGetEventDetailsLazyQuery>;
export type GetEventDetailsQueryResult = Apollo.QueryResult<GetEventDetailsQuery, GetEventDetailsQueryVariables>;
export const ApproveEventRoomJoinRequestDocument = gql`
    mutation ApproveEventRoomJoinRequest($eventRoomJoinRequestId: uuid!) {
  update_EventRoomJoinRequest_by_pk(
    pk_columns: {id: $eventRoomJoinRequestId}
    _set: {approved: true}
  ) {
    id
  }
}
    `;
export type ApproveEventRoomJoinRequestMutationFn = Apollo.MutationFunction<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>;

/**
 * __useApproveEventRoomJoinRequestMutation__
 *
 * To run a mutation, you first call `useApproveEventRoomJoinRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveEventRoomJoinRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveEventRoomJoinRequestMutation, { data, loading, error }] = useApproveEventRoomJoinRequestMutation({
 *   variables: {
 *      eventRoomJoinRequestId: // value for 'eventRoomJoinRequestId'
 *   },
 * });
 */
export function useApproveEventRoomJoinRequestMutation(baseOptions?: Apollo.MutationHookOptions<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>) {
        return Apollo.useMutation<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>(ApproveEventRoomJoinRequestDocument, baseOptions);
      }
export type ApproveEventRoomJoinRequestMutationHookResult = ReturnType<typeof useApproveEventRoomJoinRequestMutation>;
export type ApproveEventRoomJoinRequestMutationResult = Apollo.MutationResult<ApproveEventRoomJoinRequestMutation>;
export type ApproveEventRoomJoinRequestMutationOptions = Apollo.BaseMutationOptions<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>;
export const GetBreakoutRoomFromEventDocument = gql`
    query GetBreakoutRoomFromEvent($originatingEventId: uuid!) {
  Room(where: {originatingEventId: {_eq: $originatingEventId}}) {
    id
  }
}
    `;

/**
 * __useGetBreakoutRoomFromEventQuery__
 *
 * To run a query within a React component, call `useGetBreakoutRoomFromEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBreakoutRoomFromEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBreakoutRoomFromEventQuery({
 *   variables: {
 *      originatingEventId: // value for 'originatingEventId'
 *   },
 * });
 */
export function useGetBreakoutRoomFromEventQuery(baseOptions: Apollo.QueryHookOptions<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>) {
        return Apollo.useQuery<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>(GetBreakoutRoomFromEventDocument, baseOptions);
      }
export function useGetBreakoutRoomFromEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>) {
          return Apollo.useLazyQuery<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>(GetBreakoutRoomFromEventDocument, baseOptions);
        }
export type GetBreakoutRoomFromEventQueryHookResult = ReturnType<typeof useGetBreakoutRoomFromEventQuery>;
export type GetBreakoutRoomFromEventLazyQueryHookResult = ReturnType<typeof useGetBreakoutRoomFromEventLazyQuery>;
export type GetBreakoutRoomFromEventQueryResult = Apollo.QueryResult<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>;
export const MakeEventRoomJoinRequestDocument = gql`
    mutation MakeEventRoomJoinRequest($attendeeId: uuid!, $conferenceId: uuid!, $eventId: uuid!) {
  insert_EventRoomJoinRequest_one(
    object: {attendeeId: $attendeeId, conferenceId: $conferenceId, eventId: $eventId}
  ) {
    id
  }
}
    `;
export type MakeEventRoomJoinRequestMutationFn = Apollo.MutationFunction<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>;

/**
 * __useMakeEventRoomJoinRequestMutation__
 *
 * To run a mutation, you first call `useMakeEventRoomJoinRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMakeEventRoomJoinRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [makeEventRoomJoinRequestMutation, { data, loading, error }] = useMakeEventRoomJoinRequestMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      conferenceId: // value for 'conferenceId'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useMakeEventRoomJoinRequestMutation(baseOptions?: Apollo.MutationHookOptions<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>) {
        return Apollo.useMutation<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>(MakeEventRoomJoinRequestDocument, baseOptions);
      }
export type MakeEventRoomJoinRequestMutationHookResult = ReturnType<typeof useMakeEventRoomJoinRequestMutation>;
export type MakeEventRoomJoinRequestMutationResult = Apollo.MutationResult<MakeEventRoomJoinRequestMutation>;
export type MakeEventRoomJoinRequestMutationOptions = Apollo.BaseMutationOptions<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>;
export const MyEventRoomJoinRequestDocument = gql`
    subscription MyEventRoomJoinRequest($attendeeId: uuid!, $conferenceId: uuid!, $eventId: uuid!) {
  EventRoomJoinRequest(
    where: {attendeeId: {_eq: $attendeeId}, conferenceId: {_eq: $conferenceId}, eventId: {_eq: $eventId}}
  ) {
    id
    approved
  }
}
    `;

/**
 * __useMyEventRoomJoinRequestSubscription__
 *
 * To run a query within a React component, call `useMyEventRoomJoinRequestSubscription` and pass it any options that fit your needs.
 * When your component renders, `useMyEventRoomJoinRequestSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyEventRoomJoinRequestSubscription({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      conferenceId: // value for 'conferenceId'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useMyEventRoomJoinRequestSubscription(baseOptions: Apollo.SubscriptionHookOptions<MyEventRoomJoinRequestSubscription, MyEventRoomJoinRequestSubscriptionVariables>) {
        return Apollo.useSubscription<MyEventRoomJoinRequestSubscription, MyEventRoomJoinRequestSubscriptionVariables>(MyEventRoomJoinRequestDocument, baseOptions);
      }
export type MyEventRoomJoinRequestSubscriptionHookResult = ReturnType<typeof useMyEventRoomJoinRequestSubscription>;
export type MyEventRoomJoinRequestSubscriptionResult = Apollo.SubscriptionResult<MyEventRoomJoinRequestSubscription>;
export const Room_GetCurrentEventDocument = gql`
    query Room_GetCurrentEvent($currentEventId: uuid!) {
  Event_by_pk(id: $currentEventId) {
    ...Room_CurrentEventSummary
  }
}
    ${Room_CurrentEventSummaryFragmentDoc}`;

/**
 * __useRoom_GetCurrentEventQuery__
 *
 * To run a query within a React component, call `useRoom_GetCurrentEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetCurrentEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetCurrentEventQuery({
 *   variables: {
 *      currentEventId: // value for 'currentEventId'
 *   },
 * });
 */
export function useRoom_GetCurrentEventQuery(baseOptions: Apollo.QueryHookOptions<Room_GetCurrentEventQuery, Room_GetCurrentEventQueryVariables>) {
        return Apollo.useQuery<Room_GetCurrentEventQuery, Room_GetCurrentEventQueryVariables>(Room_GetCurrentEventDocument, baseOptions);
      }
export function useRoom_GetCurrentEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetCurrentEventQuery, Room_GetCurrentEventQueryVariables>) {
          return Apollo.useLazyQuery<Room_GetCurrentEventQuery, Room_GetCurrentEventQueryVariables>(Room_GetCurrentEventDocument, baseOptions);
        }
export type Room_GetCurrentEventQueryHookResult = ReturnType<typeof useRoom_GetCurrentEventQuery>;
export type Room_GetCurrentEventLazyQueryHookResult = ReturnType<typeof useRoom_GetCurrentEventLazyQuery>;
export type Room_GetCurrentEventQueryResult = Apollo.QueryResult<Room_GetCurrentEventQuery, Room_GetCurrentEventQueryVariables>;
export const Room_GetEventsDocument = gql`
    query Room_GetEvents($roomId: uuid!) {
  Event(where: {roomId: {_eq: $roomId}}) {
    ...Room_EventSummary
  }
}
    ${Room_EventSummaryFragmentDoc}`;

/**
 * __useRoom_GetEventsQuery__
 *
 * To run a query within a React component, call `useRoom_GetEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetEventsQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useRoom_GetEventsQuery(baseOptions: Apollo.QueryHookOptions<Room_GetEventsQuery, Room_GetEventsQueryVariables>) {
        return Apollo.useQuery<Room_GetEventsQuery, Room_GetEventsQueryVariables>(Room_GetEventsDocument, baseOptions);
      }
export function useRoom_GetEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetEventsQuery, Room_GetEventsQueryVariables>) {
          return Apollo.useLazyQuery<Room_GetEventsQuery, Room_GetEventsQueryVariables>(Room_GetEventsDocument, baseOptions);
        }
export type Room_GetEventsQueryHookResult = ReturnType<typeof useRoom_GetEventsQuery>;
export type Room_GetEventsLazyQueryHookResult = ReturnType<typeof useRoom_GetEventsLazyQuery>;
export type Room_GetEventsQueryResult = Apollo.QueryResult<Room_GetEventsQuery, Room_GetEventsQueryVariables>;
export const RoomBackstage_GetEventBreakoutRoomDocument = gql`
    query RoomBackstage_GetEventBreakoutRoom($originatingEventId: uuid!) {
  Room(where: {originatingEventId: {_eq: $originatingEventId}}) {
    id
  }
}
    `;

/**
 * __useRoomBackstage_GetEventBreakoutRoomQuery__
 *
 * To run a query within a React component, call `useRoomBackstage_GetEventBreakoutRoomQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomBackstage_GetEventBreakoutRoomQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomBackstage_GetEventBreakoutRoomQuery({
 *   variables: {
 *      originatingEventId: // value for 'originatingEventId'
 *   },
 * });
 */
export function useRoomBackstage_GetEventBreakoutRoomQuery(baseOptions: Apollo.QueryHookOptions<RoomBackstage_GetEventBreakoutRoomQuery, RoomBackstage_GetEventBreakoutRoomQueryVariables>) {
        return Apollo.useQuery<RoomBackstage_GetEventBreakoutRoomQuery, RoomBackstage_GetEventBreakoutRoomQueryVariables>(RoomBackstage_GetEventBreakoutRoomDocument, baseOptions);
      }
export function useRoomBackstage_GetEventBreakoutRoomLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomBackstage_GetEventBreakoutRoomQuery, RoomBackstage_GetEventBreakoutRoomQueryVariables>) {
          return Apollo.useLazyQuery<RoomBackstage_GetEventBreakoutRoomQuery, RoomBackstage_GetEventBreakoutRoomQueryVariables>(RoomBackstage_GetEventBreakoutRoomDocument, baseOptions);
        }
export type RoomBackstage_GetEventBreakoutRoomQueryHookResult = ReturnType<typeof useRoomBackstage_GetEventBreakoutRoomQuery>;
export type RoomBackstage_GetEventBreakoutRoomLazyQueryHookResult = ReturnType<typeof useRoomBackstage_GetEventBreakoutRoomLazyQuery>;
export type RoomBackstage_GetEventBreakoutRoomQueryResult = Apollo.QueryResult<RoomBackstage_GetEventBreakoutRoomQuery, RoomBackstage_GetEventBreakoutRoomQueryVariables>;
export const AddParticipantToRoomDocument = gql`
    mutation AddParticipantToRoom($attendeeId: uuid!, $roomId: uuid!) {
  insert_RoomPerson_one(
    object: {attendeeId: $attendeeId, roomId: $roomId, roomPersonRoleName: PARTICIPANT}
  ) {
    id
  }
}
    `;
export type AddParticipantToRoomMutationFn = Apollo.MutationFunction<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>;

/**
 * __useAddParticipantToRoomMutation__
 *
 * To run a mutation, you first call `useAddParticipantToRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddParticipantToRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addParticipantToRoomMutation, { data, loading, error }] = useAddParticipantToRoomMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useAddParticipantToRoomMutation(baseOptions?: Apollo.MutationHookOptions<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>) {
        return Apollo.useMutation<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>(AddParticipantToRoomDocument, baseOptions);
      }
export type AddParticipantToRoomMutationHookResult = ReturnType<typeof useAddParticipantToRoomMutation>;
export type AddParticipantToRoomMutationResult = Apollo.MutationResult<AddParticipantToRoomMutation>;
export type AddParticipantToRoomMutationOptions = Apollo.BaseMutationOptions<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>;
export const GetAllRoomsDocument = gql`
    query GetAllRooms($conferenceId: uuid!) {
  Room(
    where: {conferenceId: {_eq: $conferenceId}, roomPrivacyName: {_neq: MANAGED}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;

/**
 * __useGetAllRoomsQuery__
 *
 * To run a query within a React component, call `useGetAllRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllRoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetAllRoomsQuery(baseOptions: Apollo.QueryHookOptions<GetAllRoomsQuery, GetAllRoomsQueryVariables>) {
        return Apollo.useQuery<GetAllRoomsQuery, GetAllRoomsQueryVariables>(GetAllRoomsDocument, baseOptions);
      }
export function useGetAllRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllRoomsQuery, GetAllRoomsQueryVariables>) {
          return Apollo.useLazyQuery<GetAllRoomsQuery, GetAllRoomsQueryVariables>(GetAllRoomsDocument, baseOptions);
        }
export type GetAllRoomsQueryHookResult = ReturnType<typeof useGetAllRoomsQuery>;
export type GetAllRoomsLazyQueryHookResult = ReturnType<typeof useGetAllRoomsLazyQuery>;
export type GetAllRoomsQueryResult = Apollo.QueryResult<GetAllRoomsQuery, GetAllRoomsQueryVariables>;
export const RoomPage_GetRoomDetailsDocument = gql`
    query RoomPage_GetRoomDetails($roomId: uuid!) {
  Room_by_pk(id: $roomId) {
    ...RoomPage_RoomDetails
  }
}
    ${RoomPage_RoomDetailsFragmentDoc}`;

/**
 * __useRoomPage_GetRoomDetailsQuery__
 *
 * To run a query within a React component, call `useRoomPage_GetRoomDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomPage_GetRoomDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomPage_GetRoomDetailsQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useRoomPage_GetRoomDetailsQuery(baseOptions: Apollo.QueryHookOptions<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>) {
        return Apollo.useQuery<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>(RoomPage_GetRoomDetailsDocument, baseOptions);
      }
export function useRoomPage_GetRoomDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>) {
          return Apollo.useLazyQuery<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>(RoomPage_GetRoomDetailsDocument, baseOptions);
        }
export type RoomPage_GetRoomDetailsQueryHookResult = ReturnType<typeof useRoomPage_GetRoomDetailsQuery>;
export type RoomPage_GetRoomDetailsLazyQueryHookResult = ReturnType<typeof useRoomPage_GetRoomDetailsLazyQuery>;
export type RoomPage_GetRoomDetailsQueryResult = Apollo.QueryResult<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>;
export const GetEventVonageDetailsDocument = gql`
    query GetEventVonageDetails($eventId: uuid!) {
  Event_by_pk(id: $eventId) {
    eventVonageSession {
      sessionId
      id
    }
    id
  }
}
    `;

/**
 * __useGetEventVonageDetailsQuery__
 *
 * To run a query within a React component, call `useGetEventVonageDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventVonageDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventVonageDetailsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventVonageDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>) {
        return Apollo.useQuery<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>(GetEventVonageDetailsDocument, baseOptions);
      }
export function useGetEventVonageDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>) {
          return Apollo.useLazyQuery<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>(GetEventVonageDetailsDocument, baseOptions);
        }
export type GetEventVonageDetailsQueryHookResult = ReturnType<typeof useGetEventVonageDetailsQuery>;
export type GetEventVonageDetailsLazyQueryHookResult = ReturnType<typeof useGetEventVonageDetailsLazyQuery>;
export type GetEventVonageDetailsQueryResult = Apollo.QueryResult<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>;
export const RoomSponsorContent_GetContentItemsDocument = gql`
    query RoomSponsorContent_GetContentItems($contentGroupId: uuid!) {
  ContentGroup(
    where: {id: {_eq: $contentGroupId}, contentGroupTypeName: {_eq: SPONSOR}}
  ) {
    ...RoomSponsorContent_ContentGroupData
  }
}
    ${RoomSponsorContent_ContentGroupDataFragmentDoc}`;

/**
 * __useRoomSponsorContent_GetContentItemsQuery__
 *
 * To run a query within a React component, call `useRoomSponsorContent_GetContentItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomSponsorContent_GetContentItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomSponsorContent_GetContentItemsQuery({
 *   variables: {
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useRoomSponsorContent_GetContentItemsQuery(baseOptions: Apollo.QueryHookOptions<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>) {
        return Apollo.useQuery<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>(RoomSponsorContent_GetContentItemsDocument, baseOptions);
      }
export function useRoomSponsorContent_GetContentItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>) {
          return Apollo.useLazyQuery<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>(RoomSponsorContent_GetContentItemsDocument, baseOptions);
        }
export type RoomSponsorContent_GetContentItemsQueryHookResult = ReturnType<typeof useRoomSponsorContent_GetContentItemsQuery>;
export type RoomSponsorContent_GetContentItemsLazyQueryHookResult = ReturnType<typeof useRoomSponsorContent_GetContentItemsLazyQuery>;
export type RoomSponsorContent_GetContentItemsQueryResult = Apollo.QueryResult<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>;
export const VonageSubscriber_GetAttendeeDocument = gql`
    query VonageSubscriber_GetAttendee($id: uuid!) {
  Attendee_by_pk(id: $id) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useVonageSubscriber_GetAttendeeQuery__
 *
 * To run a query within a React component, call `useVonageSubscriber_GetAttendeeQuery` and pass it any options that fit your needs.
 * When your component renders, `useVonageSubscriber_GetAttendeeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVonageSubscriber_GetAttendeeQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useVonageSubscriber_GetAttendeeQuery(baseOptions: Apollo.QueryHookOptions<VonageSubscriber_GetAttendeeQuery, VonageSubscriber_GetAttendeeQueryVariables>) {
        return Apollo.useQuery<VonageSubscriber_GetAttendeeQuery, VonageSubscriber_GetAttendeeQueryVariables>(VonageSubscriber_GetAttendeeDocument, baseOptions);
      }
export function useVonageSubscriber_GetAttendeeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VonageSubscriber_GetAttendeeQuery, VonageSubscriber_GetAttendeeQueryVariables>) {
          return Apollo.useLazyQuery<VonageSubscriber_GetAttendeeQuery, VonageSubscriber_GetAttendeeQueryVariables>(VonageSubscriber_GetAttendeeDocument, baseOptions);
        }
export type VonageSubscriber_GetAttendeeQueryHookResult = ReturnType<typeof useVonageSubscriber_GetAttendeeQuery>;
export type VonageSubscriber_GetAttendeeLazyQueryHookResult = ReturnType<typeof useVonageSubscriber_GetAttendeeLazyQuery>;
export type VonageSubscriber_GetAttendeeQueryResult = Apollo.QueryResult<VonageSubscriber_GetAttendeeQuery, VonageSubscriber_GetAttendeeQueryVariables>;
export const Timeline_SelectEventDocument = gql`
    query Timeline_SelectEvent($id: uuid!) {
  Event_by_pk(id: $id) {
    ...Timeline_Event_FullInfo
  }
}
    ${Timeline_Event_FullInfoFragmentDoc}`;

/**
 * __useTimeline_SelectEventQuery__
 *
 * To run a query within a React component, call `useTimeline_SelectEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useTimeline_SelectEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTimeline_SelectEventQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useTimeline_SelectEventQuery(baseOptions: Apollo.QueryHookOptions<Timeline_SelectEventQuery, Timeline_SelectEventQueryVariables>) {
        return Apollo.useQuery<Timeline_SelectEventQuery, Timeline_SelectEventQueryVariables>(Timeline_SelectEventDocument, baseOptions);
      }
export function useTimeline_SelectEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Timeline_SelectEventQuery, Timeline_SelectEventQueryVariables>) {
          return Apollo.useLazyQuery<Timeline_SelectEventQuery, Timeline_SelectEventQueryVariables>(Timeline_SelectEventDocument, baseOptions);
        }
export type Timeline_SelectEventQueryHookResult = ReturnType<typeof useTimeline_SelectEventQuery>;
export type Timeline_SelectEventLazyQueryHookResult = ReturnType<typeof useTimeline_SelectEventLazyQuery>;
export type Timeline_SelectEventQueryResult = Apollo.QueryResult<Timeline_SelectEventQuery, Timeline_SelectEventQueryVariables>;
export const Timeline_SelectRoomsDocument = gql`
    query Timeline_SelectRooms($conferenceId: uuid!) {
  Room(
    where: {conferenceId: {_eq: $conferenceId}, roomPrivacyName: {_eq: PUBLIC}, events: {id: {_is_null: false}}}
  ) {
    ...Timeline_Room
  }
  Event(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Timeline_Event
  }
  ContentGroup(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Timeline_ContentGroup_PartialInfo
  }
}
    ${Timeline_RoomFragmentDoc}
${Timeline_EventFragmentDoc}
${Timeline_ContentGroup_PartialInfoFragmentDoc}`;

/**
 * __useTimeline_SelectRoomsQuery__
 *
 * To run a query within a React component, call `useTimeline_SelectRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTimeline_SelectRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTimeline_SelectRoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useTimeline_SelectRoomsQuery(baseOptions: Apollo.QueryHookOptions<Timeline_SelectRoomsQuery, Timeline_SelectRoomsQueryVariables>) {
        return Apollo.useQuery<Timeline_SelectRoomsQuery, Timeline_SelectRoomsQueryVariables>(Timeline_SelectRoomsDocument, baseOptions);
      }
export function useTimeline_SelectRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Timeline_SelectRoomsQuery, Timeline_SelectRoomsQueryVariables>) {
          return Apollo.useLazyQuery<Timeline_SelectRoomsQuery, Timeline_SelectRoomsQueryVariables>(Timeline_SelectRoomsDocument, baseOptions);
        }
export type Timeline_SelectRoomsQueryHookResult = ReturnType<typeof useTimeline_SelectRoomsQuery>;
export type Timeline_SelectRoomsLazyQueryHookResult = ReturnType<typeof useTimeline_SelectRoomsLazyQuery>;
export type Timeline_SelectRoomsQueryResult = Apollo.QueryResult<Timeline_SelectRoomsQuery, Timeline_SelectRoomsQueryVariables>;
export const AttendeesByIdDocument = gql`
    query AttendeesById($conferenceId: uuid!, $attendeeIds: [uuid!]!) {
  Attendee(where: {id: {_in: $attendeeIds}, conferenceId: {_eq: $conferenceId}}) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useAttendeesByIdQuery__
 *
 * To run a query within a React component, call `useAttendeesByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useAttendeesByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAttendeesByIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      attendeeIds: // value for 'attendeeIds'
 *   },
 * });
 */
export function useAttendeesByIdQuery(baseOptions: Apollo.QueryHookOptions<AttendeesByIdQuery, AttendeesByIdQueryVariables>) {
        return Apollo.useQuery<AttendeesByIdQuery, AttendeesByIdQueryVariables>(AttendeesByIdDocument, baseOptions);
      }
export function useAttendeesByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AttendeesByIdQuery, AttendeesByIdQueryVariables>) {
          return Apollo.useLazyQuery<AttendeesByIdQuery, AttendeesByIdQueryVariables>(AttendeesByIdDocument, baseOptions);
        }
export type AttendeesByIdQueryHookResult = ReturnType<typeof useAttendeesByIdQuery>;
export type AttendeesByIdLazyQueryHookResult = ReturnType<typeof useAttendeesByIdLazyQuery>;
export type AttendeesByIdQueryResult = Apollo.QueryResult<AttendeesByIdQuery, AttendeesByIdQueryVariables>;
export const InsertSubmissionRequestEmailJobsDocument = gql`
    mutation InsertSubmissionRequestEmailJobs($objs: [job_queues_SubmissionRequestEmailJob_insert_input!]!) {
  insert_job_queues_SubmissionRequestEmailJob(objects: $objs) {
    affected_rows
  }
}
    `;
export type InsertSubmissionRequestEmailJobsMutationFn = Apollo.MutationFunction<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>;

/**
 * __useInsertSubmissionRequestEmailJobsMutation__
 *
 * To run a mutation, you first call `useInsertSubmissionRequestEmailJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertSubmissionRequestEmailJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertSubmissionRequestEmailJobsMutation, { data, loading, error }] = useInsertSubmissionRequestEmailJobsMutation({
 *   variables: {
 *      objs: // value for 'objs'
 *   },
 * });
 */
export function useInsertSubmissionRequestEmailJobsMutation(baseOptions?: Apollo.MutationHookOptions<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>) {
        return Apollo.useMutation<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>(InsertSubmissionRequestEmailJobsDocument, baseOptions);
      }
export type InsertSubmissionRequestEmailJobsMutationHookResult = ReturnType<typeof useInsertSubmissionRequestEmailJobsMutation>;
export type InsertSubmissionRequestEmailJobsMutationResult = Apollo.MutationResult<InsertSubmissionRequestEmailJobsMutation>;
export type InsertSubmissionRequestEmailJobsMutationOptions = Apollo.BaseMutationOptions<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>;
export const SelectAllContentDocument = gql`
    query SelectAllContent($conferenceId: uuid!) {
  ContentGroup(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ContentGroupFullNestedInfo
  }
  ContentPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ContentPersonInfo
  }
  OriginatingData(where: {conferenceId: {_eq: $conferenceId}}) {
    ...OriginatingDataInfo
  }
  Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...TagInfo
  }
  Hallway(where: {conferenceId: {_eq: $conferenceId}}) {
    ...HallwayInfo
  }
}
    ${ContentGroupFullNestedInfoFragmentDoc}
${ContentPersonInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}
${TagInfoFragmentDoc}
${HallwayInfoFragmentDoc}`;

/**
 * __useSelectAllContentQuery__
 *
 * To run a query within a React component, call `useSelectAllContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllContentQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllContentQuery(baseOptions: Apollo.QueryHookOptions<SelectAllContentQuery, SelectAllContentQueryVariables>) {
        return Apollo.useQuery<SelectAllContentQuery, SelectAllContentQueryVariables>(SelectAllContentDocument, baseOptions);
      }
export function useSelectAllContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllContentQuery, SelectAllContentQueryVariables>) {
          return Apollo.useLazyQuery<SelectAllContentQuery, SelectAllContentQueryVariables>(SelectAllContentDocument, baseOptions);
        }
export type SelectAllContentQueryHookResult = ReturnType<typeof useSelectAllContentQuery>;
export type SelectAllContentLazyQueryHookResult = ReturnType<typeof useSelectAllContentLazyQuery>;
export type SelectAllContentQueryResult = Apollo.QueryResult<SelectAllContentQuery, SelectAllContentQueryVariables>;
export const InsertDeleteContentGroupsDocument = gql`
    mutation InsertDeleteContentGroups($newGroups: [ContentGroup_insert_input!]!, $deleteGroupIds: [uuid!]!) {
  insert_ContentGroup(objects: $newGroups) {
    returning {
      ...ContentGroupFullNestedInfo
    }
  }
  delete_ContentGroup(where: {id: {_in: $deleteGroupIds}}) {
    returning {
      id
    }
  }
}
    ${ContentGroupFullNestedInfoFragmentDoc}`;
export type InsertDeleteContentGroupsMutationFn = Apollo.MutationFunction<InsertDeleteContentGroupsMutation, InsertDeleteContentGroupsMutationVariables>;

/**
 * __useInsertDeleteContentGroupsMutation__
 *
 * To run a mutation, you first call `useInsertDeleteContentGroupsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertDeleteContentGroupsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertDeleteContentGroupsMutation, { data, loading, error }] = useInsertDeleteContentGroupsMutation({
 *   variables: {
 *      newGroups: // value for 'newGroups'
 *      deleteGroupIds: // value for 'deleteGroupIds'
 *   },
 * });
 */
export function useInsertDeleteContentGroupsMutation(baseOptions?: Apollo.MutationHookOptions<InsertDeleteContentGroupsMutation, InsertDeleteContentGroupsMutationVariables>) {
        return Apollo.useMutation<InsertDeleteContentGroupsMutation, InsertDeleteContentGroupsMutationVariables>(InsertDeleteContentGroupsDocument, baseOptions);
      }
export type InsertDeleteContentGroupsMutationHookResult = ReturnType<typeof useInsertDeleteContentGroupsMutation>;
export type InsertDeleteContentGroupsMutationResult = Apollo.MutationResult<InsertDeleteContentGroupsMutation>;
export type InsertDeleteContentGroupsMutationOptions = Apollo.BaseMutationOptions<InsertDeleteContentGroupsMutation, InsertDeleteContentGroupsMutationVariables>;
export const InsertOriginatingDatasDocument = gql`
    mutation InsertOriginatingDatas($newDatas: [OriginatingData_insert_input!]!) {
  insert_OriginatingData(objects: $newDatas) {
    returning {
      ...OriginatingDataInfo
    }
  }
}
    ${OriginatingDataInfoFragmentDoc}`;
export type InsertOriginatingDatasMutationFn = Apollo.MutationFunction<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>;

/**
 * __useInsertOriginatingDatasMutation__
 *
 * To run a mutation, you first call `useInsertOriginatingDatasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertOriginatingDatasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertOriginatingDatasMutation, { data, loading, error }] = useInsertOriginatingDatasMutation({
 *   variables: {
 *      newDatas: // value for 'newDatas'
 *   },
 * });
 */
export function useInsertOriginatingDatasMutation(baseOptions?: Apollo.MutationHookOptions<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>) {
        return Apollo.useMutation<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>(InsertOriginatingDatasDocument, baseOptions);
      }
export type InsertOriginatingDatasMutationHookResult = ReturnType<typeof useInsertOriginatingDatasMutation>;
export type InsertOriginatingDatasMutationResult = Apollo.MutationResult<InsertOriginatingDatasMutation>;
export type InsertOriginatingDatasMutationOptions = Apollo.BaseMutationOptions<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>;
export const DeleteOriginatingDatasDocument = gql`
    mutation DeleteOriginatingDatas($deleteDataIds: [uuid!]!) {
  delete_OriginatingData(where: {id: {_in: $deleteDataIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteOriginatingDatasMutationFn = Apollo.MutationFunction<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>;

/**
 * __useDeleteOriginatingDatasMutation__
 *
 * To run a mutation, you first call `useDeleteOriginatingDatasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOriginatingDatasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOriginatingDatasMutation, { data, loading, error }] = useDeleteOriginatingDatasMutation({
 *   variables: {
 *      deleteDataIds: // value for 'deleteDataIds'
 *   },
 * });
 */
export function useDeleteOriginatingDatasMutation(baseOptions?: Apollo.MutationHookOptions<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>) {
        return Apollo.useMutation<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>(DeleteOriginatingDatasDocument, baseOptions);
      }
export type DeleteOriginatingDatasMutationHookResult = ReturnType<typeof useDeleteOriginatingDatasMutation>;
export type DeleteOriginatingDatasMutationResult = Apollo.MutationResult<DeleteOriginatingDatasMutation>;
export type DeleteOriginatingDatasMutationOptions = Apollo.BaseMutationOptions<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>;
export const InsertTagsDocument = gql`
    mutation InsertTags($newTags: [Tag_insert_input!]!) {
  insert_Tag(objects: $newTags) {
    returning {
      ...TagInfo
    }
  }
}
    ${TagInfoFragmentDoc}`;
export type InsertTagsMutationFn = Apollo.MutationFunction<InsertTagsMutation, InsertTagsMutationVariables>;

/**
 * __useInsertTagsMutation__
 *
 * To run a mutation, you first call `useInsertTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertTagsMutation, { data, loading, error }] = useInsertTagsMutation({
 *   variables: {
 *      newTags: // value for 'newTags'
 *   },
 * });
 */
export function useInsertTagsMutation(baseOptions?: Apollo.MutationHookOptions<InsertTagsMutation, InsertTagsMutationVariables>) {
        return Apollo.useMutation<InsertTagsMutation, InsertTagsMutationVariables>(InsertTagsDocument, baseOptions);
      }
export type InsertTagsMutationHookResult = ReturnType<typeof useInsertTagsMutation>;
export type InsertTagsMutationResult = Apollo.MutationResult<InsertTagsMutation>;
export type InsertTagsMutationOptions = Apollo.BaseMutationOptions<InsertTagsMutation, InsertTagsMutationVariables>;
export const InsertHallwaysDocument = gql`
    mutation InsertHallways($newHallways: [Hallway_insert_input!]!) {
  insert_Hallway(objects: $newHallways) {
    returning {
      ...HallwayInfo
    }
  }
}
    ${HallwayInfoFragmentDoc}`;
export type InsertHallwaysMutationFn = Apollo.MutationFunction<InsertHallwaysMutation, InsertHallwaysMutationVariables>;

/**
 * __useInsertHallwaysMutation__
 *
 * To run a mutation, you first call `useInsertHallwaysMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertHallwaysMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertHallwaysMutation, { data, loading, error }] = useInsertHallwaysMutation({
 *   variables: {
 *      newHallways: // value for 'newHallways'
 *   },
 * });
 */
export function useInsertHallwaysMutation(baseOptions?: Apollo.MutationHookOptions<InsertHallwaysMutation, InsertHallwaysMutationVariables>) {
        return Apollo.useMutation<InsertHallwaysMutation, InsertHallwaysMutationVariables>(InsertHallwaysDocument, baseOptions);
      }
export type InsertHallwaysMutationHookResult = ReturnType<typeof useInsertHallwaysMutation>;
export type InsertHallwaysMutationResult = Apollo.MutationResult<InsertHallwaysMutation>;
export type InsertHallwaysMutationOptions = Apollo.BaseMutationOptions<InsertHallwaysMutation, InsertHallwaysMutationVariables>;
export const DeleteTagsDocument = gql`
    mutation DeleteTags($deleteTagIds: [uuid!]!) {
  delete_Tag(where: {id: {_in: $deleteTagIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteTagsMutationFn = Apollo.MutationFunction<DeleteTagsMutation, DeleteTagsMutationVariables>;

/**
 * __useDeleteTagsMutation__
 *
 * To run a mutation, you first call `useDeleteTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTagsMutation, { data, loading, error }] = useDeleteTagsMutation({
 *   variables: {
 *      deleteTagIds: // value for 'deleteTagIds'
 *   },
 * });
 */
export function useDeleteTagsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTagsMutation, DeleteTagsMutationVariables>) {
        return Apollo.useMutation<DeleteTagsMutation, DeleteTagsMutationVariables>(DeleteTagsDocument, baseOptions);
      }
export type DeleteTagsMutationHookResult = ReturnType<typeof useDeleteTagsMutation>;
export type DeleteTagsMutationResult = Apollo.MutationResult<DeleteTagsMutation>;
export type DeleteTagsMutationOptions = Apollo.BaseMutationOptions<DeleteTagsMutation, DeleteTagsMutationVariables>;
export const DeleteHallwaysDocument = gql`
    mutation DeleteHallways($deleteHallwayIds: [uuid!]!) {
  delete_Hallway(where: {id: {_in: $deleteHallwayIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteHallwaysMutationFn = Apollo.MutationFunction<DeleteHallwaysMutation, DeleteHallwaysMutationVariables>;

/**
 * __useDeleteHallwaysMutation__
 *
 * To run a mutation, you first call `useDeleteHallwaysMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteHallwaysMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteHallwaysMutation, { data, loading, error }] = useDeleteHallwaysMutation({
 *   variables: {
 *      deleteHallwayIds: // value for 'deleteHallwayIds'
 *   },
 * });
 */
export function useDeleteHallwaysMutation(baseOptions?: Apollo.MutationHookOptions<DeleteHallwaysMutation, DeleteHallwaysMutationVariables>) {
        return Apollo.useMutation<DeleteHallwaysMutation, DeleteHallwaysMutationVariables>(DeleteHallwaysDocument, baseOptions);
      }
export type DeleteHallwaysMutationHookResult = ReturnType<typeof useDeleteHallwaysMutation>;
export type DeleteHallwaysMutationResult = Apollo.MutationResult<DeleteHallwaysMutation>;
export type DeleteHallwaysMutationOptions = Apollo.BaseMutationOptions<DeleteHallwaysMutation, DeleteHallwaysMutationVariables>;
export const InsertContentPeopleDocument = gql`
    mutation InsertContentPeople($newPeople: [ContentPerson_insert_input!]!) {
  insert_ContentPerson(objects: $newPeople) {
    returning {
      ...ContentPersonInfo
    }
  }
}
    ${ContentPersonInfoFragmentDoc}`;
export type InsertContentPeopleMutationFn = Apollo.MutationFunction<InsertContentPeopleMutation, InsertContentPeopleMutationVariables>;

/**
 * __useInsertContentPeopleMutation__
 *
 * To run a mutation, you first call `useInsertContentPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertContentPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertContentPeopleMutation, { data, loading, error }] = useInsertContentPeopleMutation({
 *   variables: {
 *      newPeople: // value for 'newPeople'
 *   },
 * });
 */
export function useInsertContentPeopleMutation(baseOptions?: Apollo.MutationHookOptions<InsertContentPeopleMutation, InsertContentPeopleMutationVariables>) {
        return Apollo.useMutation<InsertContentPeopleMutation, InsertContentPeopleMutationVariables>(InsertContentPeopleDocument, baseOptions);
      }
export type InsertContentPeopleMutationHookResult = ReturnType<typeof useInsertContentPeopleMutation>;
export type InsertContentPeopleMutationResult = Apollo.MutationResult<InsertContentPeopleMutation>;
export type InsertContentPeopleMutationOptions = Apollo.BaseMutationOptions<InsertContentPeopleMutation, InsertContentPeopleMutationVariables>;
export const DeleteContentPeopleDocument = gql`
    mutation DeleteContentPeople($deletePersonIds: [uuid!]!) {
  delete_ContentPerson(where: {id: {_in: $deletePersonIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteContentPeopleMutationFn = Apollo.MutationFunction<DeleteContentPeopleMutation, DeleteContentPeopleMutationVariables>;

/**
 * __useDeleteContentPeopleMutation__
 *
 * To run a mutation, you first call `useDeleteContentPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteContentPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteContentPeopleMutation, { data, loading, error }] = useDeleteContentPeopleMutation({
 *   variables: {
 *      deletePersonIds: // value for 'deletePersonIds'
 *   },
 * });
 */
export function useDeleteContentPeopleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteContentPeopleMutation, DeleteContentPeopleMutationVariables>) {
        return Apollo.useMutation<DeleteContentPeopleMutation, DeleteContentPeopleMutationVariables>(DeleteContentPeopleDocument, baseOptions);
      }
export type DeleteContentPeopleMutationHookResult = ReturnType<typeof useDeleteContentPeopleMutation>;
export type DeleteContentPeopleMutationResult = Apollo.MutationResult<DeleteContentPeopleMutation>;
export type DeleteContentPeopleMutationOptions = Apollo.BaseMutationOptions<DeleteContentPeopleMutation, DeleteContentPeopleMutationVariables>;
export const UpdateContentGroupDocument = gql`
    mutation UpdateContentGroup($newItems: [ContentItem_insert_input!]!, $newRequiredItems: [RequiredContentItem_insert_input!]!, $newGroupTags: [ContentGroupTag_insert_input!]!, $newGroupHallways: [ContentGroupHallway_insert_input!]!, $groupId: uuid!, $contentGroupTypeName: ContentGroupType_enum!, $originatingDataId: uuid = null, $shortTitle: String = null, $title: String!, $deleteItemIds: [uuid!]!, $deleteRequiredItemIds: [uuid!]!, $deleteGroupTagIds: [uuid!]!, $deleteGroupHallwayIds: [uuid!]!, $newUploaders: [Uploader_insert_input!]!, $deleteUploaderIds: [uuid!]!, $newGroupPeople: [ContentGroupPerson_insert_input!]!, $deleteGroupPeopleIds: [uuid!]!) {
  insert_ContentItem(objects: $newItems) {
    returning {
      ...ContentItemInfo
    }
  }
  insert_RequiredContentItem(objects: $newRequiredItems) {
    returning {
      ...RequiredContentItemInfo
    }
  }
  insert_ContentGroupTag(objects: $newGroupTags) {
    returning {
      ...ContentGroupTagInfo
    }
  }
  insert_ContentGroupHallway(objects: $newGroupHallways) {
    returning {
      ...ContentGroupHallwayInfo
    }
  }
  insert_Uploader(objects: $newUploaders) {
    returning {
      ...UploaderInfo
    }
  }
  insert_ContentGroupPerson(objects: $newGroupPeople) {
    returning {
      ...ContentGroupPersonInfo
    }
  }
  update_ContentGroup_by_pk(
    pk_columns: {id: $groupId}
    _set: {contentGroupTypeName: $contentGroupTypeName, originatingDataId: $originatingDataId, shortTitle: $shortTitle, title: $title}
  ) {
    ...ContentGroupFullNestedInfo
  }
  delete_ContentItem(where: {id: {_in: $deleteItemIds}}) {
    returning {
      id
    }
  }
  delete_RequiredContentItem(where: {id: {_in: $deleteRequiredItemIds}}) {
    returning {
      id
    }
  }
  delete_ContentGroupTag(where: {tag: {id: {_in: $deleteGroupTagIds}}}) {
    returning {
      id
    }
  }
  delete_ContentGroupHallway(where: {id: {_in: $deleteGroupHallwayIds}}) {
    returning {
      id
    }
  }
  delete_Uploader(where: {id: {_in: $deleteUploaderIds}}) {
    returning {
      id
    }
  }
  delete_ContentGroupPerson(where: {id: {_in: $deleteGroupPeopleIds}}) {
    returning {
      id
    }
  }
}
    ${ContentItemInfoFragmentDoc}
${RequiredContentItemInfoFragmentDoc}
${ContentGroupTagInfoFragmentDoc}
${ContentGroupHallwayInfoFragmentDoc}
${UploaderInfoFragmentDoc}
${ContentGroupPersonInfoFragmentDoc}
${ContentGroupFullNestedInfoFragmentDoc}`;
export type UpdateContentGroupMutationFn = Apollo.MutationFunction<UpdateContentGroupMutation, UpdateContentGroupMutationVariables>;

/**
 * __useUpdateContentGroupMutation__
 *
 * To run a mutation, you first call `useUpdateContentGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateContentGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateContentGroupMutation, { data, loading, error }] = useUpdateContentGroupMutation({
 *   variables: {
 *      newItems: // value for 'newItems'
 *      newRequiredItems: // value for 'newRequiredItems'
 *      newGroupTags: // value for 'newGroupTags'
 *      newGroupHallways: // value for 'newGroupHallways'
 *      groupId: // value for 'groupId'
 *      contentGroupTypeName: // value for 'contentGroupTypeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      shortTitle: // value for 'shortTitle'
 *      title: // value for 'title'
 *      deleteItemIds: // value for 'deleteItemIds'
 *      deleteRequiredItemIds: // value for 'deleteRequiredItemIds'
 *      deleteGroupTagIds: // value for 'deleteGroupTagIds'
 *      deleteGroupHallwayIds: // value for 'deleteGroupHallwayIds'
 *      newUploaders: // value for 'newUploaders'
 *      deleteUploaderIds: // value for 'deleteUploaderIds'
 *      newGroupPeople: // value for 'newGroupPeople'
 *      deleteGroupPeopleIds: // value for 'deleteGroupPeopleIds'
 *   },
 * });
 */
export function useUpdateContentGroupMutation(baseOptions?: Apollo.MutationHookOptions<UpdateContentGroupMutation, UpdateContentGroupMutationVariables>) {
        return Apollo.useMutation<UpdateContentGroupMutation, UpdateContentGroupMutationVariables>(UpdateContentGroupDocument, baseOptions);
      }
export type UpdateContentGroupMutationHookResult = ReturnType<typeof useUpdateContentGroupMutation>;
export type UpdateContentGroupMutationResult = Apollo.MutationResult<UpdateContentGroupMutation>;
export type UpdateContentGroupMutationOptions = Apollo.BaseMutationOptions<UpdateContentGroupMutation, UpdateContentGroupMutationVariables>;
export const UpdateContentItemDocument = gql`
    mutation UpdateContentItem($id: uuid!, $contentTypeName: ContentType_enum!, $layoutData: jsonb = null, $name: String!, $data: jsonb!, $isHidden: Boolean!, $originatingDataId: uuid = null, $requiredContentId: uuid = null) {
  update_ContentItem_by_pk(
    pk_columns: {id: $id}
    _set: {contentTypeName: $contentTypeName, layoutData: $layoutData, name: $name, data: $data, isHidden: $isHidden, originatingDataId: $originatingDataId, requiredContentId: $requiredContentId}
  ) {
    ...ContentItemInfo
  }
}
    ${ContentItemInfoFragmentDoc}`;
export type UpdateContentItemMutationFn = Apollo.MutationFunction<UpdateContentItemMutation, UpdateContentItemMutationVariables>;

/**
 * __useUpdateContentItemMutation__
 *
 * To run a mutation, you first call `useUpdateContentItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateContentItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateContentItemMutation, { data, loading, error }] = useUpdateContentItemMutation({
 *   variables: {
 *      id: // value for 'id'
 *      contentTypeName: // value for 'contentTypeName'
 *      layoutData: // value for 'layoutData'
 *      name: // value for 'name'
 *      data: // value for 'data'
 *      isHidden: // value for 'isHidden'
 *      originatingDataId: // value for 'originatingDataId'
 *      requiredContentId: // value for 'requiredContentId'
 *   },
 * });
 */
export function useUpdateContentItemMutation(baseOptions?: Apollo.MutationHookOptions<UpdateContentItemMutation, UpdateContentItemMutationVariables>) {
        return Apollo.useMutation<UpdateContentItemMutation, UpdateContentItemMutationVariables>(UpdateContentItemDocument, baseOptions);
      }
export type UpdateContentItemMutationHookResult = ReturnType<typeof useUpdateContentItemMutation>;
export type UpdateContentItemMutationResult = Apollo.MutationResult<UpdateContentItemMutation>;
export type UpdateContentItemMutationOptions = Apollo.BaseMutationOptions<UpdateContentItemMutation, UpdateContentItemMutationVariables>;
export const UpdateRequiredContentItemDocument = gql`
    mutation UpdateRequiredContentItem($id: uuid!, $contentTypeName: ContentType_enum!, $name: String!, $isHidden: Boolean!, $uploadsRemaining: Int = null, $originatingDataId: uuid = null) {
  update_RequiredContentItem_by_pk(
    pk_columns: {id: $id}
    _set: {contentTypeName: $contentTypeName, name: $name, isHidden: $isHidden, originatingDataId: $originatingDataId, uploadsRemaining: $uploadsRemaining}
  ) {
    ...RequiredContentItemInfo
  }
}
    ${RequiredContentItemInfoFragmentDoc}`;
export type UpdateRequiredContentItemMutationFn = Apollo.MutationFunction<UpdateRequiredContentItemMutation, UpdateRequiredContentItemMutationVariables>;

/**
 * __useUpdateRequiredContentItemMutation__
 *
 * To run a mutation, you first call `useUpdateRequiredContentItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRequiredContentItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRequiredContentItemMutation, { data, loading, error }] = useUpdateRequiredContentItemMutation({
 *   variables: {
 *      id: // value for 'id'
 *      contentTypeName: // value for 'contentTypeName'
 *      name: // value for 'name'
 *      isHidden: // value for 'isHidden'
 *      uploadsRemaining: // value for 'uploadsRemaining'
 *      originatingDataId: // value for 'originatingDataId'
 *   },
 * });
 */
export function useUpdateRequiredContentItemMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRequiredContentItemMutation, UpdateRequiredContentItemMutationVariables>) {
        return Apollo.useMutation<UpdateRequiredContentItemMutation, UpdateRequiredContentItemMutationVariables>(UpdateRequiredContentItemDocument, baseOptions);
      }
export type UpdateRequiredContentItemMutationHookResult = ReturnType<typeof useUpdateRequiredContentItemMutation>;
export type UpdateRequiredContentItemMutationResult = Apollo.MutationResult<UpdateRequiredContentItemMutation>;
export type UpdateRequiredContentItemMutationOptions = Apollo.BaseMutationOptions<UpdateRequiredContentItemMutation, UpdateRequiredContentItemMutationVariables>;
export const UpdateUploaderDocument = gql`
    mutation UpdateUploader($id: uuid!, $email: String!, $name: String!) {
  update_Uploader_by_pk(pk_columns: {id: $id}, _set: {email: $email, name: $name}) {
    ...UploaderInfo
  }
}
    ${UploaderInfoFragmentDoc}`;
export type UpdateUploaderMutationFn = Apollo.MutationFunction<UpdateUploaderMutation, UpdateUploaderMutationVariables>;

/**
 * __useUpdateUploaderMutation__
 *
 * To run a mutation, you first call `useUpdateUploaderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUploaderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUploaderMutation, { data, loading, error }] = useUpdateUploaderMutation({
 *   variables: {
 *      id: // value for 'id'
 *      email: // value for 'email'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpdateUploaderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUploaderMutation, UpdateUploaderMutationVariables>) {
        return Apollo.useMutation<UpdateUploaderMutation, UpdateUploaderMutationVariables>(UpdateUploaderDocument, baseOptions);
      }
export type UpdateUploaderMutationHookResult = ReturnType<typeof useUpdateUploaderMutation>;
export type UpdateUploaderMutationResult = Apollo.MutationResult<UpdateUploaderMutation>;
export type UpdateUploaderMutationOptions = Apollo.BaseMutationOptions<UpdateUploaderMutation, UpdateUploaderMutationVariables>;
export const UpdateGroupPersonDocument = gql`
    mutation UpdateGroupPerson($id: uuid!, $roleName: String!, $priority: Int = null) {
  update_ContentGroupPerson_by_pk(
    pk_columns: {id: $id}
    _set: {roleName: $roleName, priority: $priority}
  ) {
    ...ContentGroupPersonInfo
  }
}
    ${ContentGroupPersonInfoFragmentDoc}`;
export type UpdateGroupPersonMutationFn = Apollo.MutationFunction<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>;

/**
 * __useUpdateGroupPersonMutation__
 *
 * To run a mutation, you first call `useUpdateGroupPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupPersonMutation, { data, loading, error }] = useUpdateGroupPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      roleName: // value for 'roleName'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateGroupPersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>) {
        return Apollo.useMutation<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>(UpdateGroupPersonDocument, baseOptions);
      }
export type UpdateGroupPersonMutationHookResult = ReturnType<typeof useUpdateGroupPersonMutation>;
export type UpdateGroupPersonMutationResult = Apollo.MutationResult<UpdateGroupPersonMutation>;
export type UpdateGroupPersonMutationOptions = Apollo.BaseMutationOptions<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>;
export const UpdateGroupHallwayDocument = gql`
    mutation UpdateGroupHallway($id: uuid!, $priority: Int = null, $layout: jsonb = null) {
  update_ContentGroupHallway_by_pk(
    pk_columns: {id: $id}
    _set: {layout: $layout, priority: $priority}
  ) {
    ...ContentGroupHallwayInfo
  }
}
    ${ContentGroupHallwayInfoFragmentDoc}`;
export type UpdateGroupHallwayMutationFn = Apollo.MutationFunction<UpdateGroupHallwayMutation, UpdateGroupHallwayMutationVariables>;

/**
 * __useUpdateGroupHallwayMutation__
 *
 * To run a mutation, you first call `useUpdateGroupHallwayMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupHallwayMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupHallwayMutation, { data, loading, error }] = useUpdateGroupHallwayMutation({
 *   variables: {
 *      id: // value for 'id'
 *      priority: // value for 'priority'
 *      layout: // value for 'layout'
 *   },
 * });
 */
export function useUpdateGroupHallwayMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupHallwayMutation, UpdateGroupHallwayMutationVariables>) {
        return Apollo.useMutation<UpdateGroupHallwayMutation, UpdateGroupHallwayMutationVariables>(UpdateGroupHallwayDocument, baseOptions);
      }
export type UpdateGroupHallwayMutationHookResult = ReturnType<typeof useUpdateGroupHallwayMutation>;
export type UpdateGroupHallwayMutationResult = Apollo.MutationResult<UpdateGroupHallwayMutation>;
export type UpdateGroupHallwayMutationOptions = Apollo.BaseMutationOptions<UpdateGroupHallwayMutation, UpdateGroupHallwayMutationVariables>;
export const UpdatePersonDocument = gql`
    mutation UpdatePerson($id: uuid!, $name: String!, $affiliation: String = null, $email: String = null, $originatingDataId: uuid = null) {
  update_ContentPerson_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, affiliation: $affiliation, email: $email, originatingDataId: $originatingDataId}
  ) {
    ...ContentPersonInfo
  }
}
    ${ContentPersonInfoFragmentDoc}`;
export type UpdatePersonMutationFn = Apollo.MutationFunction<UpdatePersonMutation, UpdatePersonMutationVariables>;

/**
 * __useUpdatePersonMutation__
 *
 * To run a mutation, you first call `useUpdatePersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePersonMutation, { data, loading, error }] = useUpdatePersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      affiliation: // value for 'affiliation'
 *      email: // value for 'email'
 *      originatingDataId: // value for 'originatingDataId'
 *   },
 * });
 */
export function useUpdatePersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePersonMutation, UpdatePersonMutationVariables>) {
        return Apollo.useMutation<UpdatePersonMutation, UpdatePersonMutationVariables>(UpdatePersonDocument, baseOptions);
      }
export type UpdatePersonMutationHookResult = ReturnType<typeof useUpdatePersonMutation>;
export type UpdatePersonMutationResult = Apollo.MutationResult<UpdatePersonMutation>;
export type UpdatePersonMutationOptions = Apollo.BaseMutationOptions<UpdatePersonMutation, UpdatePersonMutationVariables>;
export const UpdateTagDocument = gql`
    mutation UpdateTag($id: uuid!, $name: String!, $colour: String!, $originatingDataId: uuid = null) {
  update_Tag_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, colour: $colour, originatingDataId: $originatingDataId}
  ) {
    ...TagInfo
  }
}
    ${TagInfoFragmentDoc}`;
export type UpdateTagMutationFn = Apollo.MutationFunction<UpdateTagMutation, UpdateTagMutationVariables>;

/**
 * __useUpdateTagMutation__
 *
 * To run a mutation, you first call `useUpdateTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTagMutation, { data, loading, error }] = useUpdateTagMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      colour: // value for 'colour'
 *      originatingDataId: // value for 'originatingDataId'
 *   },
 * });
 */
export function useUpdateTagMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTagMutation, UpdateTagMutationVariables>) {
        return Apollo.useMutation<UpdateTagMutation, UpdateTagMutationVariables>(UpdateTagDocument, baseOptions);
      }
export type UpdateTagMutationHookResult = ReturnType<typeof useUpdateTagMutation>;
export type UpdateTagMutationResult = Apollo.MutationResult<UpdateTagMutation>;
export type UpdateTagMutationOptions = Apollo.BaseMutationOptions<UpdateTagMutation, UpdateTagMutationVariables>;
export const UpdateHallwayDocument = gql`
    mutation UpdateHallway($id: uuid!, $name: String!, $colour: String!, $priority: Int!) {
  update_Hallway_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, colour: $colour, priority: $priority}
  ) {
    ...HallwayInfo
  }
}
    ${HallwayInfoFragmentDoc}`;
export type UpdateHallwayMutationFn = Apollo.MutationFunction<UpdateHallwayMutation, UpdateHallwayMutationVariables>;

/**
 * __useUpdateHallwayMutation__
 *
 * To run a mutation, you first call `useUpdateHallwayMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateHallwayMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateHallwayMutation, { data, loading, error }] = useUpdateHallwayMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      colour: // value for 'colour'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateHallwayMutation(baseOptions?: Apollo.MutationHookOptions<UpdateHallwayMutation, UpdateHallwayMutationVariables>) {
        return Apollo.useMutation<UpdateHallwayMutation, UpdateHallwayMutationVariables>(UpdateHallwayDocument, baseOptions);
      }
export type UpdateHallwayMutationHookResult = ReturnType<typeof useUpdateHallwayMutation>;
export type UpdateHallwayMutationResult = Apollo.MutationResult<UpdateHallwayMutation>;
export type UpdateHallwayMutationOptions = Apollo.BaseMutationOptions<UpdateHallwayMutation, UpdateHallwayMutationVariables>;
export const ImportAttendeesDocument = gql`
    mutation ImportAttendees($insertAttendees: [Attendee_insert_input!]!, $insertInvitations: [Invitation_insert_input!]!) {
  insert_Attendee(objects: $insertAttendees) {
    affected_rows
  }
  insert_Invitation(objects: $insertInvitations) {
    affected_rows
  }
}
    `;
export type ImportAttendeesMutationFn = Apollo.MutationFunction<ImportAttendeesMutation, ImportAttendeesMutationVariables>;

/**
 * __useImportAttendeesMutation__
 *
 * To run a mutation, you first call `useImportAttendeesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImportAttendeesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [importAttendeesMutation, { data, loading, error }] = useImportAttendeesMutation({
 *   variables: {
 *      insertAttendees: // value for 'insertAttendees'
 *      insertInvitations: // value for 'insertInvitations'
 *   },
 * });
 */
export function useImportAttendeesMutation(baseOptions?: Apollo.MutationHookOptions<ImportAttendeesMutation, ImportAttendeesMutationVariables>) {
        return Apollo.useMutation<ImportAttendeesMutation, ImportAttendeesMutationVariables>(ImportAttendeesDocument, baseOptions);
      }
export type ImportAttendeesMutationHookResult = ReturnType<typeof useImportAttendeesMutation>;
export type ImportAttendeesMutationResult = Apollo.MutationResult<ImportAttendeesMutation>;
export type ImportAttendeesMutationOptions = Apollo.BaseMutationOptions<ImportAttendeesMutation, ImportAttendeesMutationVariables>;
export const CreateConferencePrepareJobDocument = gql`
    mutation CreateConferencePrepareJob($conferenceId: uuid!) {
  insert_ConferencePrepareJob_one(object: {conferenceId: $conferenceId}) {
    id
    conferenceId
  }
}
    `;
export type CreateConferencePrepareJobMutationFn = Apollo.MutationFunction<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>;

/**
 * __useCreateConferencePrepareJobMutation__
 *
 * To run a mutation, you first call `useCreateConferencePrepareJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConferencePrepareJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConferencePrepareJobMutation, { data, loading, error }] = useCreateConferencePrepareJobMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateConferencePrepareJobMutation(baseOptions?: Apollo.MutationHookOptions<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>) {
        return Apollo.useMutation<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>(CreateConferencePrepareJobDocument, baseOptions);
      }
export type CreateConferencePrepareJobMutationHookResult = ReturnType<typeof useCreateConferencePrepareJobMutation>;
export type CreateConferencePrepareJobMutationResult = Apollo.MutationResult<CreateConferencePrepareJobMutation>;
export type CreateConferencePrepareJobMutationOptions = Apollo.BaseMutationOptions<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>;
export const ConferencePrepareJobSubscriptionDocument = gql`
    subscription ConferencePrepareJobSubscription($conferenceId: uuid!) {
  ConferencePrepareJob(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {createdAt: desc}
    limit: 10
  ) {
    id
    jobStatusName
    message
    updatedAt
    createdAt
    videoRenderJobs {
      id
      jobStatusName
      updated_at
      created_at
    }
  }
}
    `;

/**
 * __useConferencePrepareJobSubscriptionSubscription__
 *
 * To run a query within a React component, call `useConferencePrepareJobSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useConferencePrepareJobSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferencePrepareJobSubscriptionSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferencePrepareJobSubscriptionSubscription(baseOptions: Apollo.SubscriptionHookOptions<ConferencePrepareJobSubscriptionSubscription, ConferencePrepareJobSubscriptionSubscriptionVariables>) {
        return Apollo.useSubscription<ConferencePrepareJobSubscriptionSubscription, ConferencePrepareJobSubscriptionSubscriptionVariables>(ConferencePrepareJobSubscriptionDocument, baseOptions);
      }
export type ConferencePrepareJobSubscriptionSubscriptionHookResult = ReturnType<typeof useConferencePrepareJobSubscriptionSubscription>;
export type ConferencePrepareJobSubscriptionSubscriptionResult = Apollo.SubscriptionResult<ConferencePrepareJobSubscriptionSubscription>;
export const GetMediaLiveChannelsDocument = gql`
    query GetMediaLiveChannels($conferenceId: uuid!) {
  Room(where: {mediaLiveChannel: {}, conferenceId: {_eq: $conferenceId}}) {
    mediaLiveChannel {
      cloudFrontDomain
      endpointUri
      id
    }
    name
    id
  }
}
    `;

/**
 * __useGetMediaLiveChannelsQuery__
 *
 * To run a query within a React component, call `useGetMediaLiveChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMediaLiveChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMediaLiveChannelsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetMediaLiveChannelsQuery(baseOptions: Apollo.QueryHookOptions<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>) {
        return Apollo.useQuery<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>(GetMediaLiveChannelsDocument, baseOptions);
      }
export function useGetMediaLiveChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>) {
          return Apollo.useLazyQuery<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>(GetMediaLiveChannelsDocument, baseOptions);
        }
export type GetMediaLiveChannelsQueryHookResult = ReturnType<typeof useGetMediaLiveChannelsQuery>;
export type GetMediaLiveChannelsLazyQueryHookResult = ReturnType<typeof useGetMediaLiveChannelsLazyQuery>;
export type GetMediaLiveChannelsQueryResult = Apollo.QueryResult<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>;
export const EventVonageControls_GetEventsDocument = gql`
    query EventVonageControls_GetEvents($conferenceId: uuid!) {
  Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [Q_AND_A, PRESENTATION]}}
  ) {
    id
    name
    contentGroup {
      id
      title
    }
  }
}
    `;

/**
 * __useEventVonageControls_GetEventsQuery__
 *
 * To run a query within a React component, call `useEventVonageControls_GetEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventVonageControls_GetEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventVonageControls_GetEventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useEventVonageControls_GetEventsQuery(baseOptions: Apollo.QueryHookOptions<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>) {
        return Apollo.useQuery<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>(EventVonageControls_GetEventsDocument, baseOptions);
      }
export function useEventVonageControls_GetEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>) {
          return Apollo.useLazyQuery<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>(EventVonageControls_GetEventsDocument, baseOptions);
        }
export type EventVonageControls_GetEventsQueryHookResult = ReturnType<typeof useEventVonageControls_GetEventsQuery>;
export type EventVonageControls_GetEventsLazyQueryHookResult = ReturnType<typeof useEventVonageControls_GetEventsLazyQuery>;
export type EventVonageControls_GetEventsQueryResult = Apollo.QueryResult<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>;
export const EventVonageControls_StopEventBroadcastDocument = gql`
    mutation EventVonageControls_StopEventBroadcast($eventId: uuid!) {
  stopEventBroadcast(eventId: $eventId) {
    broadcastsStopped
  }
}
    `;
export type EventVonageControls_StopEventBroadcastMutationFn = Apollo.MutationFunction<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>;

/**
 * __useEventVonageControls_StopEventBroadcastMutation__
 *
 * To run a mutation, you first call `useEventVonageControls_StopEventBroadcastMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEventVonageControls_StopEventBroadcastMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [eventVonageControlsStopEventBroadcastMutation, { data, loading, error }] = useEventVonageControls_StopEventBroadcastMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useEventVonageControls_StopEventBroadcastMutation(baseOptions?: Apollo.MutationHookOptions<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>) {
        return Apollo.useMutation<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>(EventVonageControls_StopEventBroadcastDocument, baseOptions);
      }
export type EventVonageControls_StopEventBroadcastMutationHookResult = ReturnType<typeof useEventVonageControls_StopEventBroadcastMutation>;
export type EventVonageControls_StopEventBroadcastMutationResult = Apollo.MutationResult<EventVonageControls_StopEventBroadcastMutation>;
export type EventVonageControls_StopEventBroadcastMutationOptions = Apollo.BaseMutationOptions<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>;
export const ManageConferenceExportPage_GetVideoFilesDocument = gql`
    query ManageConferenceExportPage_GetVideoFiles($conferenceId: uuid!) {
  ContentItem(
    where: {conferenceId: {_eq: $conferenceId}, contentTypeName: {_in: VIDEO_FILE}}
  ) {
    ...ManageConferenceExportPage_ContentItemData
  }
}
    ${ManageConferenceExportPage_ContentItemDataFragmentDoc}`;

/**
 * __useManageConferenceExportPage_GetVideoFilesQuery__
 *
 * To run a query within a React component, call `useManageConferenceExportPage_GetVideoFilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageConferenceExportPage_GetVideoFilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageConferenceExportPage_GetVideoFilesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageConferenceExportPage_GetVideoFilesQuery(baseOptions: Apollo.QueryHookOptions<ManageConferenceExportPage_GetVideoFilesQuery, ManageConferenceExportPage_GetVideoFilesQueryVariables>) {
        return Apollo.useQuery<ManageConferenceExportPage_GetVideoFilesQuery, ManageConferenceExportPage_GetVideoFilesQueryVariables>(ManageConferenceExportPage_GetVideoFilesDocument, baseOptions);
      }
export function useManageConferenceExportPage_GetVideoFilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageConferenceExportPage_GetVideoFilesQuery, ManageConferenceExportPage_GetVideoFilesQueryVariables>) {
          return Apollo.useLazyQuery<ManageConferenceExportPage_GetVideoFilesQuery, ManageConferenceExportPage_GetVideoFilesQueryVariables>(ManageConferenceExportPage_GetVideoFilesDocument, baseOptions);
        }
export type ManageConferenceExportPage_GetVideoFilesQueryHookResult = ReturnType<typeof useManageConferenceExportPage_GetVideoFilesQuery>;
export type ManageConferenceExportPage_GetVideoFilesLazyQueryHookResult = ReturnType<typeof useManageConferenceExportPage_GetVideoFilesLazyQuery>;
export type ManageConferenceExportPage_GetVideoFilesQueryResult = Apollo.QueryResult<ManageConferenceExportPage_GetVideoFilesQuery, ManageConferenceExportPage_GetVideoFilesQueryVariables>;
export const SelectAllGroupsDocument = gql`
    query SelectAllGroups($conferenceId: uuid!) {
  Group(where: {conferenceId: {_eq: $conferenceId}}) {
    conferenceId
    enabled
    id
    includeUnauthenticated
    name
    groupRoles {
      id
      roleId
      groupId
    }
  }
}
    `;

/**
 * __useSelectAllGroupsQuery__
 *
 * To run a query within a React component, call `useSelectAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllGroupsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>) {
        return Apollo.useQuery<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>(SelectAllGroupsDocument, baseOptions);
      }
export function useSelectAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>) {
          return Apollo.useLazyQuery<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>(SelectAllGroupsDocument, baseOptions);
        }
export type SelectAllGroupsQueryHookResult = ReturnType<typeof useSelectAllGroupsQuery>;
export type SelectAllGroupsLazyQueryHookResult = ReturnType<typeof useSelectAllGroupsLazyQuery>;
export type SelectAllGroupsQueryResult = Apollo.QueryResult<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>;
export const CreateDeleteGroupsDocument = gql`
    mutation CreateDeleteGroups($deleteGroupIds: [uuid!] = [], $insertGroups: [Group_insert_input!]!) {
  delete_Group(where: {id: {_in: $deleteGroupIds}}) {
    returning {
      id
    }
  }
  insert_Group(objects: $insertGroups) {
    returning {
      id
      conferenceId
      name
      enabled
      includeUnauthenticated
      groupRoles {
        id
        groupId
        roleId
      }
    }
  }
}
    `;
export type CreateDeleteGroupsMutationFn = Apollo.MutationFunction<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>;

/**
 * __useCreateDeleteGroupsMutation__
 *
 * To run a mutation, you first call `useCreateDeleteGroupsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeleteGroupsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeleteGroupsMutation, { data, loading, error }] = useCreateDeleteGroupsMutation({
 *   variables: {
 *      deleteGroupIds: // value for 'deleteGroupIds'
 *      insertGroups: // value for 'insertGroups'
 *   },
 * });
 */
export function useCreateDeleteGroupsMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>) {
        return Apollo.useMutation<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>(CreateDeleteGroupsDocument, baseOptions);
      }
export type CreateDeleteGroupsMutationHookResult = ReturnType<typeof useCreateDeleteGroupsMutation>;
export type CreateDeleteGroupsMutationResult = Apollo.MutationResult<CreateDeleteGroupsMutation>;
export type CreateDeleteGroupsMutationOptions = Apollo.BaseMutationOptions<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>;
export const UpdateGroupDocument = gql`
    mutation UpdateGroup($groupId: uuid!, $groupName: String!, $enabled: Boolean!, $includeUnauthenticated: Boolean!, $insertRoles: [GroupRole_insert_input!]!, $deleteRoleIds: [uuid!] = []) {
  update_Group(
    where: {id: {_eq: $groupId}}
    _set: {name: $groupName, enabled: $enabled, includeUnauthenticated: $includeUnauthenticated}
  ) {
    returning {
      id
      name
      groupRoles {
        id
        groupId
        roleId
      }
      conferenceId
    }
  }
  insert_GroupRole(objects: $insertRoles) {
    returning {
      id
      groupId
      roleId
    }
  }
  delete_GroupRole(where: {roleId: {_in: $deleteRoleIds}}) {
    returning {
      id
    }
  }
}
    `;
export type UpdateGroupMutationFn = Apollo.MutationFunction<UpdateGroupMutation, UpdateGroupMutationVariables>;

/**
 * __useUpdateGroupMutation__
 *
 * To run a mutation, you first call `useUpdateGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupMutation, { data, loading, error }] = useUpdateGroupMutation({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      groupName: // value for 'groupName'
 *      enabled: // value for 'enabled'
 *      includeUnauthenticated: // value for 'includeUnauthenticated'
 *      insertRoles: // value for 'insertRoles'
 *      deleteRoleIds: // value for 'deleteRoleIds'
 *   },
 * });
 */
export function useUpdateGroupMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupMutation, UpdateGroupMutationVariables>) {
        return Apollo.useMutation<UpdateGroupMutation, UpdateGroupMutationVariables>(UpdateGroupDocument, baseOptions);
      }
export type UpdateGroupMutationHookResult = ReturnType<typeof useUpdateGroupMutation>;
export type UpdateGroupMutationResult = Apollo.MutationResult<UpdateGroupMutation>;
export type UpdateGroupMutationOptions = Apollo.BaseMutationOptions<UpdateGroupMutation, UpdateGroupMutationVariables>;
export const UpdateConferenceDocument = gql`
    mutation UpdateConference($id: uuid!, $name: String = "", $shortName: String = "", $slug: String = "") {
  update_Conference(
    where: {id: {_eq: $id}}
    _set: {name: $name, shortName: $shortName, slug: $slug}
  ) {
    returning {
      id
      name
      shortName
      slug
    }
  }
}
    `;
export type UpdateConferenceMutationFn = Apollo.MutationFunction<UpdateConferenceMutation, UpdateConferenceMutationVariables>;

/**
 * __useUpdateConferenceMutation__
 *
 * To run a mutation, you first call `useUpdateConferenceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateConferenceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateConferenceMutation, { data, loading, error }] = useUpdateConferenceMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useUpdateConferenceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateConferenceMutation, UpdateConferenceMutationVariables>) {
        return Apollo.useMutation<UpdateConferenceMutation, UpdateConferenceMutationVariables>(UpdateConferenceDocument, baseOptions);
      }
export type UpdateConferenceMutationHookResult = ReturnType<typeof useUpdateConferenceMutation>;
export type UpdateConferenceMutationResult = Apollo.MutationResult<UpdateConferenceMutation>;
export type UpdateConferenceMutationOptions = Apollo.BaseMutationOptions<UpdateConferenceMutation, UpdateConferenceMutationVariables>;
export const SelectAllAttendeesDocument = gql`
    query SelectAllAttendees($conferenceId: uuid!) {
  Attendee(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AttendeeParts
  }
}
    ${AttendeePartsFragmentDoc}`;

/**
 * __useSelectAllAttendeesQuery__
 *
 * To run a query within a React component, call `useSelectAllAttendeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllAttendeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllAttendeesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllAttendeesQuery(baseOptions: Apollo.QueryHookOptions<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>) {
        return Apollo.useQuery<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>(SelectAllAttendeesDocument, baseOptions);
      }
export function useSelectAllAttendeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>) {
          return Apollo.useLazyQuery<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>(SelectAllAttendeesDocument, baseOptions);
        }
export type SelectAllAttendeesQueryHookResult = ReturnType<typeof useSelectAllAttendeesQuery>;
export type SelectAllAttendeesLazyQueryHookResult = ReturnType<typeof useSelectAllAttendeesLazyQuery>;
export type SelectAllAttendeesQueryResult = Apollo.QueryResult<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>;
export const CreateDeleteAttendeesDocument = gql`
    mutation CreateDeleteAttendees($deleteAttendeeIds: [uuid!] = [], $insertAttendees: [Attendee_insert_input!]!, $insertInvitations: [Invitation_insert_input!]!) {
  delete_Attendee(where: {id: {_in: $deleteAttendeeIds}}) {
    returning {
      id
    }
  }
  insert_Attendee(objects: $insertAttendees) {
    returning {
      ...AttendeeParts
    }
  }
  insert_Invitation(objects: $insertInvitations) {
    affected_rows
  }
}
    ${AttendeePartsFragmentDoc}`;
export type CreateDeleteAttendeesMutationFn = Apollo.MutationFunction<CreateDeleteAttendeesMutation, CreateDeleteAttendeesMutationVariables>;

/**
 * __useCreateDeleteAttendeesMutation__
 *
 * To run a mutation, you first call `useCreateDeleteAttendeesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeleteAttendeesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeleteAttendeesMutation, { data, loading, error }] = useCreateDeleteAttendeesMutation({
 *   variables: {
 *      deleteAttendeeIds: // value for 'deleteAttendeeIds'
 *      insertAttendees: // value for 'insertAttendees'
 *      insertInvitations: // value for 'insertInvitations'
 *   },
 * });
 */
export function useCreateDeleteAttendeesMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeleteAttendeesMutation, CreateDeleteAttendeesMutationVariables>) {
        return Apollo.useMutation<CreateDeleteAttendeesMutation, CreateDeleteAttendeesMutationVariables>(CreateDeleteAttendeesDocument, baseOptions);
      }
export type CreateDeleteAttendeesMutationHookResult = ReturnType<typeof useCreateDeleteAttendeesMutation>;
export type CreateDeleteAttendeesMutationResult = Apollo.MutationResult<CreateDeleteAttendeesMutation>;
export type CreateDeleteAttendeesMutationOptions = Apollo.BaseMutationOptions<CreateDeleteAttendeesMutation, CreateDeleteAttendeesMutationVariables>;
export const UpdateAttendeeDocument = gql`
    mutation UpdateAttendee($attendeeId: uuid!, $attendeeName: String!, $insertGroups: [GroupAttendee_insert_input!]!, $deleteGroupIds: [uuid!] = []) {
  update_Attendee_by_pk(
    pk_columns: {id: $attendeeId}
    _set: {displayName: $attendeeName}
  ) {
    ...AttendeeParts
  }
  insert_GroupAttendee(objects: $insertGroups) {
    returning {
      id
      attendeeId
      groupId
    }
  }
  delete_GroupAttendee(
    where: {attendeeId: {_eq: $attendeeId}, groupId: {_in: $deleteGroupIds}}
  ) {
    returning {
      id
    }
  }
}
    ${AttendeePartsFragmentDoc}`;
export type UpdateAttendeeMutationFn = Apollo.MutationFunction<UpdateAttendeeMutation, UpdateAttendeeMutationVariables>;

/**
 * __useUpdateAttendeeMutation__
 *
 * To run a mutation, you first call `useUpdateAttendeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAttendeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAttendeeMutation, { data, loading, error }] = useUpdateAttendeeMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      attendeeName: // value for 'attendeeName'
 *      insertGroups: // value for 'insertGroups'
 *      deleteGroupIds: // value for 'deleteGroupIds'
 *   },
 * });
 */
export function useUpdateAttendeeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAttendeeMutation, UpdateAttendeeMutationVariables>) {
        return Apollo.useMutation<UpdateAttendeeMutation, UpdateAttendeeMutationVariables>(UpdateAttendeeDocument, baseOptions);
      }
export type UpdateAttendeeMutationHookResult = ReturnType<typeof useUpdateAttendeeMutation>;
export type UpdateAttendeeMutationResult = Apollo.MutationResult<UpdateAttendeeMutation>;
export type UpdateAttendeeMutationOptions = Apollo.BaseMutationOptions<UpdateAttendeeMutation, UpdateAttendeeMutationVariables>;
export const InsertInvitationEmailJobsDocument = gql`
    mutation InsertInvitationEmailJobs($attendeeIds: jsonb!, $conferenceId: uuid!, $sendRepeat: Boolean!) {
  insert_job_queues_InvitationEmailJob(
    objects: [{attendeeIds: $attendeeIds, conferenceId: $conferenceId, sendRepeat: $sendRepeat}]
  ) {
    affected_rows
  }
}
    `;
export type InsertInvitationEmailJobsMutationFn = Apollo.MutationFunction<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>;

/**
 * __useInsertInvitationEmailJobsMutation__
 *
 * To run a mutation, you first call `useInsertInvitationEmailJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertInvitationEmailJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertInvitationEmailJobsMutation, { data, loading, error }] = useInsertInvitationEmailJobsMutation({
 *   variables: {
 *      attendeeIds: // value for 'attendeeIds'
 *      conferenceId: // value for 'conferenceId'
 *      sendRepeat: // value for 'sendRepeat'
 *   },
 * });
 */
export function useInsertInvitationEmailJobsMutation(baseOptions?: Apollo.MutationHookOptions<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>) {
        return Apollo.useMutation<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>(InsertInvitationEmailJobsDocument, baseOptions);
      }
export type InsertInvitationEmailJobsMutationHookResult = ReturnType<typeof useInsertInvitationEmailJobsMutation>;
export type InsertInvitationEmailJobsMutationResult = Apollo.MutationResult<InsertInvitationEmailJobsMutation>;
export type InsertInvitationEmailJobsMutationOptions = Apollo.BaseMutationOptions<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>;
export const SelectAllPermissionsDocument = gql`
    query SelectAllPermissions {
  Permission {
    name
    description
  }
}
    `;

/**
 * __useSelectAllPermissionsQuery__
 *
 * To run a query within a React component, call `useSelectAllPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllPermissionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSelectAllPermissionsQuery(baseOptions?: Apollo.QueryHookOptions<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>) {
        return Apollo.useQuery<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>(SelectAllPermissionsDocument, baseOptions);
      }
export function useSelectAllPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>) {
          return Apollo.useLazyQuery<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>(SelectAllPermissionsDocument, baseOptions);
        }
export type SelectAllPermissionsQueryHookResult = ReturnType<typeof useSelectAllPermissionsQuery>;
export type SelectAllPermissionsLazyQueryHookResult = ReturnType<typeof useSelectAllPermissionsLazyQuery>;
export type SelectAllPermissionsQueryResult = Apollo.QueryResult<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>;
export const SelectAllRolesDocument = gql`
    query SelectAllRoles($conferenceId: uuid!) {
  Role(where: {conferenceId: {_eq: $conferenceId}}) {
    conferenceId
    id
    name
    rolePermissions {
      id
      permissionName
      roleId
    }
  }
}
    `;

/**
 * __useSelectAllRolesQuery__
 *
 * To run a query within a React component, call `useSelectAllRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRolesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRolesQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRolesQuery, SelectAllRolesQueryVariables>) {
        return Apollo.useQuery<SelectAllRolesQuery, SelectAllRolesQueryVariables>(SelectAllRolesDocument, baseOptions);
      }
export function useSelectAllRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRolesQuery, SelectAllRolesQueryVariables>) {
          return Apollo.useLazyQuery<SelectAllRolesQuery, SelectAllRolesQueryVariables>(SelectAllRolesDocument, baseOptions);
        }
export type SelectAllRolesQueryHookResult = ReturnType<typeof useSelectAllRolesQuery>;
export type SelectAllRolesLazyQueryHookResult = ReturnType<typeof useSelectAllRolesLazyQuery>;
export type SelectAllRolesQueryResult = Apollo.QueryResult<SelectAllRolesQuery, SelectAllRolesQueryVariables>;
export const CreateDeleteRolesDocument = gql`
    mutation CreateDeleteRoles($deleteRoleIds: [uuid!] = [], $insertRoles: [Role_insert_input!]!) {
  delete_Role(where: {id: {_in: $deleteRoleIds}}) {
    returning {
      id
    }
  }
  insert_Role(objects: $insertRoles) {
    returning {
      id
      conferenceId
      name
      rolePermissions {
        id
        permissionName
        roleId
      }
    }
  }
}
    `;
export type CreateDeleteRolesMutationFn = Apollo.MutationFunction<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>;

/**
 * __useCreateDeleteRolesMutation__
 *
 * To run a mutation, you first call `useCreateDeleteRolesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeleteRolesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeleteRolesMutation, { data, loading, error }] = useCreateDeleteRolesMutation({
 *   variables: {
 *      deleteRoleIds: // value for 'deleteRoleIds'
 *      insertRoles: // value for 'insertRoles'
 *   },
 * });
 */
export function useCreateDeleteRolesMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>) {
        return Apollo.useMutation<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>(CreateDeleteRolesDocument, baseOptions);
      }
export type CreateDeleteRolesMutationHookResult = ReturnType<typeof useCreateDeleteRolesMutation>;
export type CreateDeleteRolesMutationResult = Apollo.MutationResult<CreateDeleteRolesMutation>;
export type CreateDeleteRolesMutationOptions = Apollo.BaseMutationOptions<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>;
export const UpdateRoleDocument = gql`
    mutation UpdateRole($roleId: uuid!, $roleName: String!, $insertPermissions: [RolePermission_insert_input!]!, $deletePermissionNames: [Permission_enum!] = []) {
  update_Role(where: {id: {_eq: $roleId}}, _set: {name: $roleName}) {
    returning {
      id
      name
      rolePermissions {
        id
        permissionName
        roleId
      }
      conferenceId
    }
  }
  insert_RolePermission(objects: $insertPermissions) {
    returning {
      id
      permissionName
      roleId
    }
  }
  delete_RolePermission(where: {permissionName: {_in: $deletePermissionNames}}) {
    returning {
      id
    }
  }
}
    `;
export type UpdateRoleMutationFn = Apollo.MutationFunction<UpdateRoleMutation, UpdateRoleMutationVariables>;

/**
 * __useUpdateRoleMutation__
 *
 * To run a mutation, you first call `useUpdateRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoleMutation, { data, loading, error }] = useUpdateRoleMutation({
 *   variables: {
 *      roleId: // value for 'roleId'
 *      roleName: // value for 'roleName'
 *      insertPermissions: // value for 'insertPermissions'
 *      deletePermissionNames: // value for 'deletePermissionNames'
 *   },
 * });
 */
export function useUpdateRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoleMutation, UpdateRoleMutationVariables>) {
        return Apollo.useMutation<UpdateRoleMutation, UpdateRoleMutationVariables>(UpdateRoleDocument, baseOptions);
      }
export type UpdateRoleMutationHookResult = ReturnType<typeof useUpdateRoleMutation>;
export type UpdateRoleMutationResult = Apollo.MutationResult<UpdateRoleMutation>;
export type UpdateRoleMutationOptions = Apollo.BaseMutationOptions<UpdateRoleMutation, UpdateRoleMutationVariables>;
export const SelectAllRoomsWithParticipantsDocument = gql`
    query SelectAllRoomsWithParticipants($conferenceId: uuid!) {
  Room(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;

/**
 * __useSelectAllRoomsWithParticipantsQuery__
 *
 * To run a query within a React component, call `useSelectAllRoomsWithParticipantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRoomsWithParticipantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRoomsWithParticipantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRoomsWithParticipantsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>) {
        return Apollo.useQuery<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>(SelectAllRoomsWithParticipantsDocument, baseOptions);
      }
export function useSelectAllRoomsWithParticipantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>) {
          return Apollo.useLazyQuery<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>(SelectAllRoomsWithParticipantsDocument, baseOptions);
        }
export type SelectAllRoomsWithParticipantsQueryHookResult = ReturnType<typeof useSelectAllRoomsWithParticipantsQuery>;
export type SelectAllRoomsWithParticipantsLazyQueryHookResult = ReturnType<typeof useSelectAllRoomsWithParticipantsLazyQuery>;
export type SelectAllRoomsWithParticipantsQueryResult = Apollo.QueryResult<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>;
export const CreateRoomDocument = gql`
    mutation CreateRoom($room: Room_insert_input!) {
  insert_Room(objects: [$room]) {
    returning {
      ...RoomWithParticipantInfo
    }
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;
export type CreateRoomMutationFn = Apollo.MutationFunction<CreateRoomMutation, CreateRoomMutationVariables>;

/**
 * __useCreateRoomMutation__
 *
 * To run a mutation, you first call `useCreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoomMutation, { data, loading, error }] = useCreateRoomMutation({
 *   variables: {
 *      room: // value for 'room'
 *   },
 * });
 */
export function useCreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<CreateRoomMutation, CreateRoomMutationVariables>) {
        return Apollo.useMutation<CreateRoomMutation, CreateRoomMutationVariables>(CreateRoomDocument, baseOptions);
      }
export type CreateRoomMutationHookResult = ReturnType<typeof useCreateRoomMutation>;
export type CreateRoomMutationResult = Apollo.MutationResult<CreateRoomMutation>;
export type CreateRoomMutationOptions = Apollo.BaseMutationOptions<CreateRoomMutation, CreateRoomMutationVariables>;
export const UpdateRoomsWithParticipantsDocument = gql`
    mutation UpdateRoomsWithParticipants($id: uuid!, $name: String!, $capacity: Int!, $priority: Int!) {
  update_Room_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, capacity: $capacity, priority: $priority}
  ) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;
export type UpdateRoomsWithParticipantsMutationFn = Apollo.MutationFunction<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>;

/**
 * __useUpdateRoomsWithParticipantsMutation__
 *
 * To run a mutation, you first call `useUpdateRoomsWithParticipantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoomsWithParticipantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoomsWithParticipantsMutation, { data, loading, error }] = useUpdateRoomsWithParticipantsMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      capacity: // value for 'capacity'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateRoomsWithParticipantsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>) {
        return Apollo.useMutation<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>(UpdateRoomsWithParticipantsDocument, baseOptions);
      }
export type UpdateRoomsWithParticipantsMutationHookResult = ReturnType<typeof useUpdateRoomsWithParticipantsMutation>;
export type UpdateRoomsWithParticipantsMutationResult = Apollo.MutationResult<UpdateRoomsWithParticipantsMutation>;
export type UpdateRoomsWithParticipantsMutationOptions = Apollo.BaseMutationOptions<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>;
export const SelectWholeScheduleDocument = gql`
    query SelectWholeSchedule($conferenceId: uuid!) {
  Room(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RoomInfo
  }
  Event(where: {conferenceId: {_eq: $conferenceId}}) {
    ...EventInfo
  }
  OriginatingData(where: {conferenceId: {_eq: $conferenceId}}) {
    ...OriginatingDataInfo
  }
  Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...TagInfo
  }
  ContentGroup(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ContentGroupFullNestedInfo
  }
  Attendee(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AttendeeInfo
  }
}
    ${RoomInfoFragmentDoc}
${EventInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}
${TagInfoFragmentDoc}
${ContentGroupFullNestedInfoFragmentDoc}
${AttendeeInfoFragmentDoc}`;

/**
 * __useSelectWholeScheduleQuery__
 *
 * To run a query within a React component, call `useSelectWholeScheduleQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectWholeScheduleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectWholeScheduleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectWholeScheduleQuery(baseOptions: Apollo.QueryHookOptions<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>) {
        return Apollo.useQuery<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>(SelectWholeScheduleDocument, baseOptions);
      }
export function useSelectWholeScheduleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>) {
          return Apollo.useLazyQuery<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>(SelectWholeScheduleDocument, baseOptions);
        }
export type SelectWholeScheduleQueryHookResult = ReturnType<typeof useSelectWholeScheduleQuery>;
export type SelectWholeScheduleLazyQueryHookResult = ReturnType<typeof useSelectWholeScheduleLazyQuery>;
export type SelectWholeScheduleQueryResult = Apollo.QueryResult<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>;
export const InsertRoomsDocument = gql`
    mutation InsertRooms($newRooms: [Room_insert_input!]!) {
  insert_Room(objects: $newRooms) {
    returning {
      ...RoomInfo
    }
  }
}
    ${RoomInfoFragmentDoc}`;
export type InsertRoomsMutationFn = Apollo.MutationFunction<InsertRoomsMutation, InsertRoomsMutationVariables>;

/**
 * __useInsertRoomsMutation__
 *
 * To run a mutation, you first call `useInsertRoomsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRoomsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRoomsMutation, { data, loading, error }] = useInsertRoomsMutation({
 *   variables: {
 *      newRooms: // value for 'newRooms'
 *   },
 * });
 */
export function useInsertRoomsMutation(baseOptions?: Apollo.MutationHookOptions<InsertRoomsMutation, InsertRoomsMutationVariables>) {
        return Apollo.useMutation<InsertRoomsMutation, InsertRoomsMutationVariables>(InsertRoomsDocument, baseOptions);
      }
export type InsertRoomsMutationHookResult = ReturnType<typeof useInsertRoomsMutation>;
export type InsertRoomsMutationResult = Apollo.MutationResult<InsertRoomsMutation>;
export type InsertRoomsMutationOptions = Apollo.BaseMutationOptions<InsertRoomsMutation, InsertRoomsMutationVariables>;
export const DeleteRoomsDocument = gql`
    mutation DeleteRooms($deleteRoomIds: [uuid!]!) {
  delete_Room(where: {id: {_in: $deleteRoomIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteRoomsMutationFn = Apollo.MutationFunction<DeleteRoomsMutation, DeleteRoomsMutationVariables>;

/**
 * __useDeleteRoomsMutation__
 *
 * To run a mutation, you first call `useDeleteRoomsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRoomsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRoomsMutation, { data, loading, error }] = useDeleteRoomsMutation({
 *   variables: {
 *      deleteRoomIds: // value for 'deleteRoomIds'
 *   },
 * });
 */
export function useDeleteRoomsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRoomsMutation, DeleteRoomsMutationVariables>) {
        return Apollo.useMutation<DeleteRoomsMutation, DeleteRoomsMutationVariables>(DeleteRoomsDocument, baseOptions);
      }
export type DeleteRoomsMutationHookResult = ReturnType<typeof useDeleteRoomsMutation>;
export type DeleteRoomsMutationResult = Apollo.MutationResult<DeleteRoomsMutation>;
export type DeleteRoomsMutationOptions = Apollo.BaseMutationOptions<DeleteRoomsMutation, DeleteRoomsMutationVariables>;
export const UpdateRoomDocument = gql`
    mutation UpdateRoom($id: uuid!, $name: String!, $capacity: Int = null, $originatingDataId: uuid = null, $priority: Int!) {
  update_Room_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, capacity: $capacity, originatingDataId: $originatingDataId, priority: $priority}
  ) {
    ...RoomInfo
  }
}
    ${RoomInfoFragmentDoc}`;
export type UpdateRoomMutationFn = Apollo.MutationFunction<UpdateRoomMutation, UpdateRoomMutationVariables>;

/**
 * __useUpdateRoomMutation__
 *
 * To run a mutation, you first call `useUpdateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoomMutation, { data, loading, error }] = useUpdateRoomMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      capacity: // value for 'capacity'
 *      originatingDataId: // value for 'originatingDataId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateRoomMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoomMutation, UpdateRoomMutationVariables>) {
        return Apollo.useMutation<UpdateRoomMutation, UpdateRoomMutationVariables>(UpdateRoomDocument, baseOptions);
      }
export type UpdateRoomMutationHookResult = ReturnType<typeof useUpdateRoomMutation>;
export type UpdateRoomMutationResult = Apollo.MutationResult<UpdateRoomMutation>;
export type UpdateRoomMutationOptions = Apollo.BaseMutationOptions<UpdateRoomMutation, UpdateRoomMutationVariables>;
export const InsertDeleteEventsDocument = gql`
    mutation InsertDeleteEvents($newEvents: [Event_insert_input!]!, $deleteEventIds: [uuid!]!) {
  insert_Event(objects: $newEvents) {
    returning {
      ...EventInfo
    }
  }
  delete_Event(where: {id: {_in: $deleteEventIds}}) {
    returning {
      id
    }
  }
}
    ${EventInfoFragmentDoc}`;
export type InsertDeleteEventsMutationFn = Apollo.MutationFunction<InsertDeleteEventsMutation, InsertDeleteEventsMutationVariables>;

/**
 * __useInsertDeleteEventsMutation__
 *
 * To run a mutation, you first call `useInsertDeleteEventsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertDeleteEventsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertDeleteEventsMutation, { data, loading, error }] = useInsertDeleteEventsMutation({
 *   variables: {
 *      newEvents: // value for 'newEvents'
 *      deleteEventIds: // value for 'deleteEventIds'
 *   },
 * });
 */
export function useInsertDeleteEventsMutation(baseOptions?: Apollo.MutationHookOptions<InsertDeleteEventsMutation, InsertDeleteEventsMutationVariables>) {
        return Apollo.useMutation<InsertDeleteEventsMutation, InsertDeleteEventsMutationVariables>(InsertDeleteEventsDocument, baseOptions);
      }
export type InsertDeleteEventsMutationHookResult = ReturnType<typeof useInsertDeleteEventsMutation>;
export type InsertDeleteEventsMutationResult = Apollo.MutationResult<InsertDeleteEventsMutation>;
export type InsertDeleteEventsMutationOptions = Apollo.BaseMutationOptions<InsertDeleteEventsMutation, InsertDeleteEventsMutationVariables>;
export const UpdateEventDocument = gql`
    mutation UpdateEvent($eventId: uuid!, $roomId: uuid!, $intendedRoomModeName: RoomMode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $contentGroupId: uuid = null, $newEventTags: [EventTag_insert_input!]!, $deleteEventTagIds: [uuid!]!, $newEventPeople: [EventPerson_insert_input!]!, $deleteEventPeopleIds: [uuid!]!) {
  insert_EventTag(objects: $newEventTags) {
    returning {
      ...EventTagInfo
    }
  }
  insert_EventPerson(objects: $newEventPeople) {
    returning {
      ...EventPersonInfo
    }
  }
  update_Event_by_pk(
    pk_columns: {id: $eventId}
    _set: {roomId: $roomId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds}
  ) {
    ...EventInfo
  }
  delete_EventTag(where: {tag: {id: {_in: $deleteEventTagIds}}}) {
    returning {
      id
    }
  }
  delete_EventPerson(where: {id: {_in: $deleteEventPeopleIds}}) {
    returning {
      id
    }
  }
}
    ${EventTagInfoFragmentDoc}
${EventPersonInfoFragmentDoc}
${EventInfoFragmentDoc}`;
export type UpdateEventMutationFn = Apollo.MutationFunction<UpdateEventMutation, UpdateEventMutationVariables>;

/**
 * __useUpdateEventMutation__
 *
 * To run a mutation, you first call `useUpdateEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventMutation, { data, loading, error }] = useUpdateEventMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      roomId: // value for 'roomId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      contentGroupId: // value for 'contentGroupId'
 *      newEventTags: // value for 'newEventTags'
 *      deleteEventTagIds: // value for 'deleteEventTagIds'
 *      newEventPeople: // value for 'newEventPeople'
 *      deleteEventPeopleIds: // value for 'deleteEventPeopleIds'
 *   },
 * });
 */
export function useUpdateEventMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventMutation, UpdateEventMutationVariables>) {
        return Apollo.useMutation<UpdateEventMutation, UpdateEventMutationVariables>(UpdateEventDocument, baseOptions);
      }
export type UpdateEventMutationHookResult = ReturnType<typeof useUpdateEventMutation>;
export type UpdateEventMutationResult = Apollo.MutationResult<UpdateEventMutation>;
export type UpdateEventMutationOptions = Apollo.BaseMutationOptions<UpdateEventMutation, UpdateEventMutationVariables>;
export const UpdateEventPersonDocument = gql`
    mutation UpdateEventPerson($id: uuid!, $attendeeId: uuid = null, $name: String!, $affiliation: String = null, $roleName: EventPersonRole_enum!, $originatingDataId: uuid = null) {
  update_EventPerson_by_pk(
    pk_columns: {id: $id}
    _set: {attendeeId: $attendeeId, name: $name, affiliation: $affiliation, roleName: $roleName, originatingDataId: $originatingDataId}
  ) {
    ...EventPersonInfo
  }
}
    ${EventPersonInfoFragmentDoc}`;
export type UpdateEventPersonMutationFn = Apollo.MutationFunction<UpdateEventPersonMutation, UpdateEventPersonMutationVariables>;

/**
 * __useUpdateEventPersonMutation__
 *
 * To run a mutation, you first call `useUpdateEventPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventPersonMutation, { data, loading, error }] = useUpdateEventPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attendeeId: // value for 'attendeeId'
 *      name: // value for 'name'
 *      affiliation: // value for 'affiliation'
 *      roleName: // value for 'roleName'
 *      originatingDataId: // value for 'originatingDataId'
 *   },
 * });
 */
export function useUpdateEventPersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventPersonMutation, UpdateEventPersonMutationVariables>) {
        return Apollo.useMutation<UpdateEventPersonMutation, UpdateEventPersonMutationVariables>(UpdateEventPersonDocument, baseOptions);
      }
export type UpdateEventPersonMutationHookResult = ReturnType<typeof useUpdateEventPersonMutation>;
export type UpdateEventPersonMutationResult = Apollo.MutationResult<UpdateEventPersonMutation>;
export type UpdateEventPersonMutationOptions = Apollo.BaseMutationOptions<UpdateEventPersonMutation, UpdateEventPersonMutationVariables>;
export const ConferenceTakenDocument = gql`
    query ConferenceTaken($name: String!, $shortName: String!, $slug: String!) {
  Conference(
    where: {_or: [{name: {_eq: $name}}, {shortName: {_eq: $shortName}}, {slug: {_eq: $slug}}]}
  ) {
    id
    name
    shortName
    slug
  }
}
    `;

/**
 * __useConferenceTakenQuery__
 *
 * To run a query within a React component, call `useConferenceTakenQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceTakenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceTakenQuery({
 *   variables: {
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useConferenceTakenQuery(baseOptions: Apollo.QueryHookOptions<ConferenceTakenQuery, ConferenceTakenQueryVariables>) {
        return Apollo.useQuery<ConferenceTakenQuery, ConferenceTakenQueryVariables>(ConferenceTakenDocument, baseOptions);
      }
export function useConferenceTakenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceTakenQuery, ConferenceTakenQueryVariables>) {
          return Apollo.useLazyQuery<ConferenceTakenQuery, ConferenceTakenQueryVariables>(ConferenceTakenDocument, baseOptions);
        }
export type ConferenceTakenQueryHookResult = ReturnType<typeof useConferenceTakenQuery>;
export type ConferenceTakenLazyQueryHookResult = ReturnType<typeof useConferenceTakenLazyQuery>;
export type ConferenceTakenQueryResult = Apollo.QueryResult<ConferenceTakenQuery, ConferenceTakenQueryVariables>;
export const CreateConferenceDocument = gql`
    mutation CreateConference($name: String!, $shortName: String!, $slug: String!, $demoCode: uuid!) {
  insert_Conference(
    objects: [{name: $name, shortName: $shortName, slug: $slug, demoCodeId: $demoCode}]
  ) {
    returning {
      id
      slug
    }
  }
  update_ConferenceDemoCode(
    where: {id: {_eq: $demoCode}}
    _set: {note: "Code has been used."}
  ) {
    affected_rows
  }
}
    `;
export type CreateConferenceMutationFn = Apollo.MutationFunction<CreateConferenceMutation, CreateConferenceMutationVariables>;

/**
 * __useCreateConferenceMutation__
 *
 * To run a mutation, you first call `useCreateConferenceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConferenceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConferenceMutation, { data, loading, error }] = useCreateConferenceMutation({
 *   variables: {
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *      demoCode: // value for 'demoCode'
 *   },
 * });
 */
export function useCreateConferenceMutation(baseOptions?: Apollo.MutationHookOptions<CreateConferenceMutation, CreateConferenceMutationVariables>) {
        return Apollo.useMutation<CreateConferenceMutation, CreateConferenceMutationVariables>(CreateConferenceDocument, baseOptions);
      }
export type CreateConferenceMutationHookResult = ReturnType<typeof useCreateConferenceMutation>;
export type CreateConferenceMutationResult = Apollo.MutationResult<CreateConferenceMutation>;
export type CreateConferenceMutationOptions = Apollo.BaseMutationOptions<CreateConferenceMutation, CreateConferenceMutationVariables>;
export const CreateNewConferenceMetaStructureDocument = gql`
    mutation CreateNewConferenceMetaStructure($conferenceId: uuid!, $attendeeDisplayName: String!, $userId: String!, $abstractData: jsonb!, $contentGroupListData: jsonb!) {
  insert_Attendee(
    objects: [{displayName: $attendeeDisplayName, userId: $userId, conferenceId: $conferenceId, groupAttendees: {data: {group: {data: {conferenceId: $conferenceId, includeUnauthenticated: false, name: "Organisers", groupRoles: {data: {role: {data: {conferenceId: $conferenceId, name: "Organiser", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_NAME}, {permissionName: CONFERENCE_MANAGE_ATTENDEES}, {permissionName: CONFERENCE_MODERATE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}, {permissionName: CONFERENCE_VIEW}, {permissionName: CONFERENCE_MANAGE_ROLES}, {permissionName: CONFERENCE_MANAGE_GROUPS}, {permissionName: CONFERENCE_MANAGE_CONTENT}, {permissionName: CONFERENCE_MANAGE_SCHEDULE}]}}}}}}}}}}]
  ) {
    affected_rows
  }
  insert_Group(
    objects: [{conferenceId: $conferenceId, enabled: false, name: "Attendees", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Attendee", rolePermissions: {data: [{permissionName: CONFERENCE_VIEW}, {permissionName: CONFERENCE_VIEW_ATTENDEES}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Public", includeUnauthenticated: true, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Public", rolePermissions: {data: [{permissionName: CONFERENCE_VIEW}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Registrars", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Registrar", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Moderators", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Moderator", rolePermissions: {data: [{permissionName: CONFERENCE_MODERATE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}, {permissionName: CONFERENCE_VIEW}]}}}}]}}]
  ) {
    returning {
      id
      conferenceId
      name
      enabled
      groupRoles {
        id
        roleId
        groupId
        role {
          id
          name
          conferenceId
          rolePermissions {
            id
            roleId
            permissionName
          }
        }
      }
    }
  }
  insert_ContentGroup(
    objects: {conferenceId: $conferenceId, contentGroupTypeName: LANDING_PAGE, contentItems: {data: [{conferenceId: $conferenceId, contentTypeName: ABSTRACT, data: $abstractData, isHidden: false, layoutData: {}, name: "Welcome text"}, {conferenceId: $conferenceId, contentTypeName: CONTENT_GROUP_LIST, data: $contentGroupListData, isHidden: false, layoutData: {}, name: "Content group list"}]}, shortTitle: "Landing", title: "Landing page"}
  ) {
    returning {
      ...ContentGroupData
    }
  }
}
    ${ContentGroupDataFragmentDoc}`;
export type CreateNewConferenceMetaStructureMutationFn = Apollo.MutationFunction<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>;

/**
 * __useCreateNewConferenceMetaStructureMutation__
 *
 * To run a mutation, you first call `useCreateNewConferenceMetaStructureMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNewConferenceMetaStructureMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNewConferenceMetaStructureMutation, { data, loading, error }] = useCreateNewConferenceMetaStructureMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      attendeeDisplayName: // value for 'attendeeDisplayName'
 *      userId: // value for 'userId'
 *      abstractData: // value for 'abstractData'
 *      contentGroupListData: // value for 'contentGroupListData'
 *   },
 * });
 */
export function useCreateNewConferenceMetaStructureMutation(baseOptions?: Apollo.MutationHookOptions<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>) {
        return Apollo.useMutation<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>(CreateNewConferenceMetaStructureDocument, baseOptions);
      }
export type CreateNewConferenceMetaStructureMutationHookResult = ReturnType<typeof useCreateNewConferenceMetaStructureMutation>;
export type CreateNewConferenceMetaStructureMutationResult = Apollo.MutationResult<CreateNewConferenceMetaStructureMutation>;
export type CreateNewConferenceMetaStructureMutationOptions = Apollo.BaseMutationOptions<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>;
export const ConferenceBySlugDocument = gql`
    query ConferenceBySlug($slug: String!) {
  Conference(where: {slug: {_eq: $slug}}) {
    id
    name
    shortName
    slug
  }
}
    `;

/**
 * __useConferenceBySlugQuery__
 *
 * To run a query within a React component, call `useConferenceBySlugQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceBySlugQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceBySlugQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useConferenceBySlugQuery(baseOptions: Apollo.QueryHookOptions<ConferenceBySlugQuery, ConferenceBySlugQueryVariables>) {
        return Apollo.useQuery<ConferenceBySlugQuery, ConferenceBySlugQueryVariables>(ConferenceBySlugDocument, baseOptions);
      }
export function useConferenceBySlugLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceBySlugQuery, ConferenceBySlugQueryVariables>) {
          return Apollo.useLazyQuery<ConferenceBySlugQuery, ConferenceBySlugQueryVariables>(ConferenceBySlugDocument, baseOptions);
        }
export type ConferenceBySlugQueryHookResult = ReturnType<typeof useConferenceBySlugQuery>;
export type ConferenceBySlugLazyQueryHookResult = ReturnType<typeof useConferenceBySlugLazyQuery>;
export type ConferenceBySlugQueryResult = Apollo.QueryResult<ConferenceBySlugQuery, ConferenceBySlugQueryVariables>;
export const CurrentUserGroupsRolesPermissionsDocument = gql`
    query CurrentUserGroupsRolesPermissions($userId: String, $conferenceId: uuid!) {
  User(where: {id: {_eq: $userId}}) {
    conferencesCreated(where: {id: {_eq: $conferenceId}}) {
      id
    }
    attendees(where: {conferenceId: {_eq: $conferenceId}}) {
      groupAttendees {
        group {
          ...GroupData
        }
        id
        groupId
        attendeeId
      }
      id
      userId
      conferenceId
      displayName
    }
    id
  }
  publicGroups: Group(
    where: {conferenceId: {_eq: $conferenceId}, enabled: {_eq: true}, includeUnauthenticated: {_eq: true}}
  ) {
    ...GroupData
  }
}
    ${GroupDataFragmentDoc}`;

/**
 * __useCurrentUserGroupsRolesPermissionsQuery__
 *
 * To run a query within a React component, call `useCurrentUserGroupsRolesPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrentUserGroupsRolesPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrentUserGroupsRolesPermissionsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCurrentUserGroupsRolesPermissionsQuery(baseOptions: Apollo.QueryHookOptions<CurrentUserGroupsRolesPermissionsQuery, CurrentUserGroupsRolesPermissionsQueryVariables>) {
        return Apollo.useQuery<CurrentUserGroupsRolesPermissionsQuery, CurrentUserGroupsRolesPermissionsQueryVariables>(CurrentUserGroupsRolesPermissionsDocument, baseOptions);
      }
export function useCurrentUserGroupsRolesPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CurrentUserGroupsRolesPermissionsQuery, CurrentUserGroupsRolesPermissionsQueryVariables>) {
          return Apollo.useLazyQuery<CurrentUserGroupsRolesPermissionsQuery, CurrentUserGroupsRolesPermissionsQueryVariables>(CurrentUserGroupsRolesPermissionsDocument, baseOptions);
        }
export type CurrentUserGroupsRolesPermissionsQueryHookResult = ReturnType<typeof useCurrentUserGroupsRolesPermissionsQuery>;
export type CurrentUserGroupsRolesPermissionsLazyQueryHookResult = ReturnType<typeof useCurrentUserGroupsRolesPermissionsLazyQuery>;
export type CurrentUserGroupsRolesPermissionsQueryResult = Apollo.QueryResult<CurrentUserGroupsRolesPermissionsQuery, CurrentUserGroupsRolesPermissionsQueryVariables>;
export const PublicUserGroupsRolesPermissionsDocument = gql`
    query PublicUserGroupsRolesPermissions($conferenceId: uuid!) {
  publicGroups: Group(
    where: {conferenceId: {_eq: $conferenceId}, enabled: {_eq: true}, includeUnauthenticated: {_eq: true}}
  ) {
    ...GroupData
  }
}
    ${GroupDataFragmentDoc}`;

/**
 * __usePublicUserGroupsRolesPermissionsQuery__
 *
 * To run a query within a React component, call `usePublicUserGroupsRolesPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePublicUserGroupsRolesPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePublicUserGroupsRolesPermissionsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function usePublicUserGroupsRolesPermissionsQuery(baseOptions: Apollo.QueryHookOptions<PublicUserGroupsRolesPermissionsQuery, PublicUserGroupsRolesPermissionsQueryVariables>) {
        return Apollo.useQuery<PublicUserGroupsRolesPermissionsQuery, PublicUserGroupsRolesPermissionsQueryVariables>(PublicUserGroupsRolesPermissionsDocument, baseOptions);
      }
export function usePublicUserGroupsRolesPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PublicUserGroupsRolesPermissionsQuery, PublicUserGroupsRolesPermissionsQueryVariables>) {
          return Apollo.useLazyQuery<PublicUserGroupsRolesPermissionsQuery, PublicUserGroupsRolesPermissionsQueryVariables>(PublicUserGroupsRolesPermissionsDocument, baseOptions);
        }
export type PublicUserGroupsRolesPermissionsQueryHookResult = ReturnType<typeof usePublicUserGroupsRolesPermissionsQuery>;
export type PublicUserGroupsRolesPermissionsLazyQueryHookResult = ReturnType<typeof usePublicUserGroupsRolesPermissionsLazyQuery>;
export type PublicUserGroupsRolesPermissionsQueryResult = Apollo.QueryResult<PublicUserGroupsRolesPermissionsQuery, PublicUserGroupsRolesPermissionsQueryVariables>;
export const AttendeeByUserIdConferenceIdDocument = gql`
    query AttendeeByUserIdConferenceId($conferenceId: uuid!, $userId: String!) {
  Attendee(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {userId: {_eq: $userId}}]}
  ) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useAttendeeByUserIdConferenceIdQuery__
 *
 * To run a query within a React component, call `useAttendeeByUserIdConferenceIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useAttendeeByUserIdConferenceIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAttendeeByUserIdConferenceIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useAttendeeByUserIdConferenceIdQuery(baseOptions: Apollo.QueryHookOptions<AttendeeByUserIdConferenceIdQuery, AttendeeByUserIdConferenceIdQueryVariables>) {
        return Apollo.useQuery<AttendeeByUserIdConferenceIdQuery, AttendeeByUserIdConferenceIdQueryVariables>(AttendeeByUserIdConferenceIdDocument, baseOptions);
      }
export function useAttendeeByUserIdConferenceIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AttendeeByUserIdConferenceIdQuery, AttendeeByUserIdConferenceIdQueryVariables>) {
          return Apollo.useLazyQuery<AttendeeByUserIdConferenceIdQuery, AttendeeByUserIdConferenceIdQueryVariables>(AttendeeByUserIdConferenceIdDocument, baseOptions);
        }
export type AttendeeByUserIdConferenceIdQueryHookResult = ReturnType<typeof useAttendeeByUserIdConferenceIdQuery>;
export type AttendeeByUserIdConferenceIdLazyQueryHookResult = ReturnType<typeof useAttendeeByUserIdConferenceIdLazyQuery>;
export type AttendeeByUserIdConferenceIdQueryResult = Apollo.QueryResult<AttendeeByUserIdConferenceIdQuery, AttendeeByUserIdConferenceIdQueryVariables>;
export const AttendeeByIdDocument = gql`
    query AttendeeById($conferenceId: uuid!, $attendeeId: uuid!) {
  Attendee(where: {id: {_eq: $attendeeId}, conferenceId: {_eq: $conferenceId}}) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useAttendeeByIdQuery__
 *
 * To run a query within a React component, call `useAttendeeByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useAttendeeByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAttendeeByIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useAttendeeByIdQuery(baseOptions: Apollo.QueryHookOptions<AttendeeByIdQuery, AttendeeByIdQueryVariables>) {
        return Apollo.useQuery<AttendeeByIdQuery, AttendeeByIdQueryVariables>(AttendeeByIdDocument, baseOptions);
      }
export function useAttendeeByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AttendeeByIdQuery, AttendeeByIdQueryVariables>) {
          return Apollo.useLazyQuery<AttendeeByIdQuery, AttendeeByIdQueryVariables>(AttendeeByIdDocument, baseOptions);
        }
export type AttendeeByIdQueryHookResult = ReturnType<typeof useAttendeeByIdQuery>;
export type AttendeeByIdLazyQueryHookResult = ReturnType<typeof useAttendeeByIdLazyQuery>;
export type AttendeeByIdQueryResult = Apollo.QueryResult<AttendeeByIdQuery, AttendeeByIdQueryVariables>;
export const UpdateSubtitlesDocument = gql`
    mutation UpdateSubtitles($contentItemId: String!, $magicToken: String!, $subtitleText: String!) {
  updateSubtitles(
    contentItemId: $contentItemId
    magicToken: $magicToken
    subtitleText: $subtitleText
  ) {
    message
    success
  }
}
    `;
export type UpdateSubtitlesMutationFn = Apollo.MutationFunction<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>;

/**
 * __useUpdateSubtitlesMutation__
 *
 * To run a mutation, you first call `useUpdateSubtitlesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubtitlesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubtitlesMutation, { data, loading, error }] = useUpdateSubtitlesMutation({
 *   variables: {
 *      contentItemId: // value for 'contentItemId'
 *      magicToken: // value for 'magicToken'
 *      subtitleText: // value for 'subtitleText'
 *   },
 * });
 */
export function useUpdateSubtitlesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>) {
        return Apollo.useMutation<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>(UpdateSubtitlesDocument, baseOptions);
      }
export type UpdateSubtitlesMutationHookResult = ReturnType<typeof useUpdateSubtitlesMutation>;
export type UpdateSubtitlesMutationResult = Apollo.MutationResult<UpdateSubtitlesMutation>;
export type UpdateSubtitlesMutationOptions = Apollo.BaseMutationOptions<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>;
export const GetContentItemDocument = gql`
    query GetContentItem($magicToken: String!) {
  getContentItem(magicToken: $magicToken) {
    contentTypeName
    data
    layoutData
    name
    id
    contentGroupTitle
  }
}
    `;

/**
 * __useGetContentItemQuery__
 *
 * To run a query within a React component, call `useGetContentItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetContentItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetContentItemQuery({
 *   variables: {
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useGetContentItemQuery(baseOptions: Apollo.QueryHookOptions<GetContentItemQuery, GetContentItemQueryVariables>) {
        return Apollo.useQuery<GetContentItemQuery, GetContentItemQueryVariables>(GetContentItemDocument, baseOptions);
      }
export function useGetContentItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetContentItemQuery, GetContentItemQueryVariables>) {
          return Apollo.useLazyQuery<GetContentItemQuery, GetContentItemQueryVariables>(GetContentItemDocument, baseOptions);
        }
export type GetContentItemQueryHookResult = ReturnType<typeof useGetContentItemQuery>;
export type GetContentItemLazyQueryHookResult = ReturnType<typeof useGetContentItemLazyQuery>;
export type GetContentItemQueryResult = Apollo.QueryResult<GetContentItemQuery, GetContentItemQueryVariables>;
export const SelectRequiredItemDocument = gql`
    query SelectRequiredItem($requiredContentItemId: uuid!) {
  RequiredContentItem(where: {id: {_eq: $requiredContentItemId}}) {
    ...RequiredItemFields
  }
}
    ${RequiredItemFieldsFragmentDoc}`;

/**
 * __useSelectRequiredItemQuery__
 *
 * To run a query within a React component, call `useSelectRequiredItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectRequiredItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectRequiredItemQuery({
 *   variables: {
 *      requiredContentItemId: // value for 'requiredContentItemId'
 *   },
 * });
 */
export function useSelectRequiredItemQuery(baseOptions: Apollo.QueryHookOptions<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>) {
        return Apollo.useQuery<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>(SelectRequiredItemDocument, baseOptions);
      }
export function useSelectRequiredItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>) {
          return Apollo.useLazyQuery<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>(SelectRequiredItemDocument, baseOptions);
        }
export type SelectRequiredItemQueryHookResult = ReturnType<typeof useSelectRequiredItemQuery>;
export type SelectRequiredItemLazyQueryHookResult = ReturnType<typeof useSelectRequiredItemLazyQuery>;
export type SelectRequiredItemQueryResult = Apollo.QueryResult<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>;
export const SubmitContentItemDocument = gql`
    mutation SubmitContentItem($contentItemData: jsonb!, $magicToken: String!) {
  submitContentItem(data: $contentItemData, magicToken: $magicToken) {
    message
    success
  }
}
    `;
export type SubmitContentItemMutationFn = Apollo.MutationFunction<SubmitContentItemMutation, SubmitContentItemMutationVariables>;

/**
 * __useSubmitContentItemMutation__
 *
 * To run a mutation, you first call `useSubmitContentItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitContentItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitContentItemMutation, { data, loading, error }] = useSubmitContentItemMutation({
 *   variables: {
 *      contentItemData: // value for 'contentItemData'
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useSubmitContentItemMutation(baseOptions?: Apollo.MutationHookOptions<SubmitContentItemMutation, SubmitContentItemMutationVariables>) {
        return Apollo.useMutation<SubmitContentItemMutation, SubmitContentItemMutationVariables>(SubmitContentItemDocument, baseOptions);
      }
export type SubmitContentItemMutationHookResult = ReturnType<typeof useSubmitContentItemMutation>;
export type SubmitContentItemMutationResult = Apollo.MutationResult<SubmitContentItemMutation>;
export type SubmitContentItemMutationOptions = Apollo.BaseMutationOptions<SubmitContentItemMutation, SubmitContentItemMutationVariables>;
export const GetUploadAgreementDocument = gql`
    query GetUploadAgreement($magicToken: String!) {
  getUploadAgreement(magicToken: $magicToken) {
    agreementText
  }
}
    `;

/**
 * __useGetUploadAgreementQuery__
 *
 * To run a query within a React component, call `useGetUploadAgreementQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUploadAgreementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUploadAgreementQuery({
 *   variables: {
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useGetUploadAgreementQuery(baseOptions: Apollo.QueryHookOptions<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>) {
        return Apollo.useQuery<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>(GetUploadAgreementDocument, baseOptions);
      }
export function useGetUploadAgreementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>) {
          return Apollo.useLazyQuery<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>(GetUploadAgreementDocument, baseOptions);
        }
export type GetUploadAgreementQueryHookResult = ReturnType<typeof useGetUploadAgreementQuery>;
export type GetUploadAgreementLazyQueryHookResult = ReturnType<typeof useGetUploadAgreementLazyQuery>;
export type GetUploadAgreementQueryResult = Apollo.QueryResult<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>;
export const EchoDocument = gql`
    query Echo($message: String!) {
  echo(message: $message) {
    message
  }
}
    `;

/**
 * __useEchoQuery__
 *
 * To run a query within a React component, call `useEchoQuery` and pass it any options that fit your needs.
 * When your component renders, `useEchoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEchoQuery({
 *   variables: {
 *      message: // value for 'message'
 *   },
 * });
 */
export function useEchoQuery(baseOptions: Apollo.QueryHookOptions<EchoQuery, EchoQueryVariables>) {
        return Apollo.useQuery<EchoQuery, EchoQueryVariables>(EchoDocument, baseOptions);
      }
export function useEchoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EchoQuery, EchoQueryVariables>) {
          return Apollo.useLazyQuery<EchoQuery, EchoQueryVariables>(EchoDocument, baseOptions);
        }
export type EchoQueryHookResult = ReturnType<typeof useEchoQuery>;
export type EchoLazyQueryHookResult = ReturnType<typeof useEchoLazyQuery>;
export type EchoQueryResult = Apollo.QueryResult<EchoQuery, EchoQueryVariables>;
export const ProtectedEchoDocument = gql`
    query ProtectedEcho($message: String!) {
  protectedEcho(message: $message) {
    message
  }
}
    `;

/**
 * __useProtectedEchoQuery__
 *
 * To run a query within a React component, call `useProtectedEchoQuery` and pass it any options that fit your needs.
 * When your component renders, `useProtectedEchoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProtectedEchoQuery({
 *   variables: {
 *      message: // value for 'message'
 *   },
 * });
 */
export function useProtectedEchoQuery(baseOptions: Apollo.QueryHookOptions<ProtectedEchoQuery, ProtectedEchoQueryVariables>) {
        return Apollo.useQuery<ProtectedEchoQuery, ProtectedEchoQueryVariables>(ProtectedEchoDocument, baseOptions);
      }
export function useProtectedEchoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProtectedEchoQuery, ProtectedEchoQueryVariables>) {
          return Apollo.useLazyQuery<ProtectedEchoQuery, ProtectedEchoQueryVariables>(ProtectedEchoDocument, baseOptions);
        }
export type ProtectedEchoQueryHookResult = ReturnType<typeof useProtectedEchoQuery>;
export type ProtectedEchoLazyQueryHookResult = ReturnType<typeof useProtectedEchoLazyQuery>;
export type ProtectedEchoQueryResult = Apollo.QueryResult<ProtectedEchoQuery, ProtectedEchoQueryVariables>;
export const UserEventRolesDocument = gql`
    subscription UserEventRoles($eventId: uuid!) {
  Event_by_pk(id: $eventId) {
    eventPeople {
      ...EventPersonDetails
    }
  }
}
    ${EventPersonDetailsFragmentDoc}`;

/**
 * __useUserEventRolesSubscription__
 *
 * To run a query within a React component, call `useUserEventRolesSubscription` and pass it any options that fit your needs.
 * When your component renders, `useUserEventRolesSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserEventRolesSubscription({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useUserEventRolesSubscription(baseOptions: Apollo.SubscriptionHookOptions<UserEventRolesSubscription, UserEventRolesSubscriptionVariables>) {
        return Apollo.useSubscription<UserEventRolesSubscription, UserEventRolesSubscriptionVariables>(UserEventRolesDocument, baseOptions);
      }
export type UserEventRolesSubscriptionHookResult = ReturnType<typeof useUserEventRolesSubscription>;
export type UserEventRolesSubscriptionResult = Apollo.SubscriptionResult<UserEventRolesSubscription>;
export const SelectInvitationForAcceptDocument = gql`
    query SelectInvitationForAccept($inviteCode: uuid!) {
  Invitation(where: {inviteCode: {_eq: $inviteCode}}) {
    hash
  }
}
    `;

/**
 * __useSelectInvitationForAcceptQuery__
 *
 * To run a query within a React component, call `useSelectInvitationForAcceptQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInvitationForAcceptQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInvitationForAcceptQuery({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSelectInvitationForAcceptQuery(baseOptions: Apollo.QueryHookOptions<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>) {
        return Apollo.useQuery<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>(SelectInvitationForAcceptDocument, baseOptions);
      }
export function useSelectInvitationForAcceptLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>) {
          return Apollo.useLazyQuery<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>(SelectInvitationForAcceptDocument, baseOptions);
        }
export type SelectInvitationForAcceptQueryHookResult = ReturnType<typeof useSelectInvitationForAcceptQuery>;
export type SelectInvitationForAcceptLazyQueryHookResult = ReturnType<typeof useSelectInvitationForAcceptLazyQuery>;
export type SelectInvitationForAcceptQueryResult = Apollo.QueryResult<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>;
export const Invitation_ConfirmCurrentDocument = gql`
    mutation Invitation_ConfirmCurrent($inviteCode: uuid!) {
  invitationConfirmCurrent(inviteCode: $inviteCode) {
    confSlug
    ok
  }
}
    `;
export type Invitation_ConfirmCurrentMutationFn = Apollo.MutationFunction<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>;

/**
 * __useInvitation_ConfirmCurrentMutation__
 *
 * To run a mutation, you first call `useInvitation_ConfirmCurrentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInvitation_ConfirmCurrentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [invitationConfirmCurrentMutation, { data, loading, error }] = useInvitation_ConfirmCurrentMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useInvitation_ConfirmCurrentMutation(baseOptions?: Apollo.MutationHookOptions<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>) {
        return Apollo.useMutation<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>(Invitation_ConfirmCurrentDocument, baseOptions);
      }
export type Invitation_ConfirmCurrentMutationHookResult = ReturnType<typeof useInvitation_ConfirmCurrentMutation>;
export type Invitation_ConfirmCurrentMutationResult = Apollo.MutationResult<Invitation_ConfirmCurrentMutation>;
export type Invitation_ConfirmCurrentMutationOptions = Apollo.BaseMutationOptions<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>;
export const Invitation_ConfirmWithCodeDocument = gql`
    mutation Invitation_ConfirmWithCode($inviteCode: uuid!, $confirmationCode: String!) {
  invitationConfirmWithCode(
    inviteInput: {inviteCode: $inviteCode, confirmationCode: $confirmationCode}
  ) {
    confSlug
    ok
  }
}
    `;
export type Invitation_ConfirmWithCodeMutationFn = Apollo.MutationFunction<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>;

/**
 * __useInvitation_ConfirmWithCodeMutation__
 *
 * To run a mutation, you first call `useInvitation_ConfirmWithCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInvitation_ConfirmWithCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [invitationConfirmWithCodeMutation, { data, loading, error }] = useInvitation_ConfirmWithCodeMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *      confirmationCode: // value for 'confirmationCode'
 *   },
 * });
 */
export function useInvitation_ConfirmWithCodeMutation(baseOptions?: Apollo.MutationHookOptions<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>) {
        return Apollo.useMutation<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>(Invitation_ConfirmWithCodeDocument, baseOptions);
      }
export type Invitation_ConfirmWithCodeMutationHookResult = ReturnType<typeof useInvitation_ConfirmWithCodeMutation>;
export type Invitation_ConfirmWithCodeMutationResult = Apollo.MutationResult<Invitation_ConfirmWithCodeMutation>;
export type Invitation_ConfirmWithCodeMutationOptions = Apollo.BaseMutationOptions<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>;
export const SendInitialConfirmationEmailDocument = gql`
    mutation SendInitialConfirmationEmail($inviteCode: uuid!) {
  invitationConfirmSendInitialEmail(inviteInput: {inviteCode: $inviteCode}) {
    sent
  }
}
    `;
export type SendInitialConfirmationEmailMutationFn = Apollo.MutationFunction<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>;

/**
 * __useSendInitialConfirmationEmailMutation__
 *
 * To run a mutation, you first call `useSendInitialConfirmationEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendInitialConfirmationEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendInitialConfirmationEmailMutation, { data, loading, error }] = useSendInitialConfirmationEmailMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSendInitialConfirmationEmailMutation(baseOptions?: Apollo.MutationHookOptions<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>) {
        return Apollo.useMutation<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>(SendInitialConfirmationEmailDocument, baseOptions);
      }
export type SendInitialConfirmationEmailMutationHookResult = ReturnType<typeof useSendInitialConfirmationEmailMutation>;
export type SendInitialConfirmationEmailMutationResult = Apollo.MutationResult<SendInitialConfirmationEmailMutation>;
export type SendInitialConfirmationEmailMutationOptions = Apollo.BaseMutationOptions<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>;
export const SendRepeatConfirmationEmailDocument = gql`
    mutation SendRepeatConfirmationEmail($inviteCode: uuid!) {
  invitationConfirmSendRepeatEmail(inviteInput: {inviteCode: $inviteCode}) {
    sent
  }
}
    `;
export type SendRepeatConfirmationEmailMutationFn = Apollo.MutationFunction<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>;

/**
 * __useSendRepeatConfirmationEmailMutation__
 *
 * To run a mutation, you first call `useSendRepeatConfirmationEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendRepeatConfirmationEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendRepeatConfirmationEmailMutation, { data, loading, error }] = useSendRepeatConfirmationEmailMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSendRepeatConfirmationEmailMutation(baseOptions?: Apollo.MutationHookOptions<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>) {
        return Apollo.useMutation<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>(SendRepeatConfirmationEmailDocument, baseOptions);
      }
export type SendRepeatConfirmationEmailMutationHookResult = ReturnType<typeof useSendRepeatConfirmationEmailMutation>;
export type SendRepeatConfirmationEmailMutationResult = Apollo.MutationResult<SendRepeatConfirmationEmailMutation>;
export type SendRepeatConfirmationEmailMutationOptions = Apollo.BaseMutationOptions<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>;
export const PinnedChatsWithUnreadCountsDocument = gql`
    query PinnedChatsWithUnreadCounts($attendeeId: uuid!) {
  chat_Pin(where: {attendeeId: {_eq: $attendeeId}}) {
    attendeeId
    chatId
    chat {
      ...SidebarChatInfo
    }
  }
}
    ${SidebarChatInfoFragmentDoc}`;

/**
 * __usePinnedChatsWithUnreadCountsQuery__
 *
 * To run a query within a React component, call `usePinnedChatsWithUnreadCountsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePinnedChatsWithUnreadCountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePinnedChatsWithUnreadCountsQuery({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function usePinnedChatsWithUnreadCountsQuery(baseOptions: Apollo.QueryHookOptions<PinnedChatsWithUnreadCountsQuery, PinnedChatsWithUnreadCountsQueryVariables>) {
        return Apollo.useQuery<PinnedChatsWithUnreadCountsQuery, PinnedChatsWithUnreadCountsQueryVariables>(PinnedChatsWithUnreadCountsDocument, baseOptions);
      }
export function usePinnedChatsWithUnreadCountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PinnedChatsWithUnreadCountsQuery, PinnedChatsWithUnreadCountsQueryVariables>) {
          return Apollo.useLazyQuery<PinnedChatsWithUnreadCountsQuery, PinnedChatsWithUnreadCountsQueryVariables>(PinnedChatsWithUnreadCountsDocument, baseOptions);
        }
export type PinnedChatsWithUnreadCountsQueryHookResult = ReturnType<typeof usePinnedChatsWithUnreadCountsQuery>;
export type PinnedChatsWithUnreadCountsLazyQueryHookResult = ReturnType<typeof usePinnedChatsWithUnreadCountsLazyQuery>;
export type PinnedChatsWithUnreadCountsQueryResult = Apollo.QueryResult<PinnedChatsWithUnreadCountsQuery, PinnedChatsWithUnreadCountsQueryVariables>;
export const MenuScheduleDocument = gql`
    query MenuSchedule($now: timestamptz!, $inThreeMinutes: timestamptz!, $in30Minutes: timestamptz!, $inOneHour: timestamptz!, $conferenceId: uuid!) {
  eventsNow: Event(
    where: {startTime: {_lte: $inThreeMinutes}, endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...MenuSchedule_Event
  }
  eventsIn30mins: Event(
    where: {startTime: {_gt: $inThreeMinutes, _lte: $in30Minutes}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...MenuSchedule_Event
  }
  eventsIn1Hour: Event(
    where: {startTime: {_gt: $in30Minutes, _lte: $inOneHour}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...MenuSchedule_Event
  }
}
    ${MenuSchedule_EventFragmentDoc}`;

/**
 * __useMenuScheduleQuery__
 *
 * To run a query within a React component, call `useMenuScheduleQuery` and pass it any options that fit your needs.
 * When your component renders, `useMenuScheduleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMenuScheduleQuery({
 *   variables: {
 *      now: // value for 'now'
 *      inThreeMinutes: // value for 'inThreeMinutes'
 *      in30Minutes: // value for 'in30Minutes'
 *      inOneHour: // value for 'inOneHour'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useMenuScheduleQuery(baseOptions: Apollo.QueryHookOptions<MenuScheduleQuery, MenuScheduleQueryVariables>) {
        return Apollo.useQuery<MenuScheduleQuery, MenuScheduleQueryVariables>(MenuScheduleDocument, baseOptions);
      }
export function useMenuScheduleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MenuScheduleQuery, MenuScheduleQueryVariables>) {
          return Apollo.useLazyQuery<MenuScheduleQuery, MenuScheduleQueryVariables>(MenuScheduleDocument, baseOptions);
        }
export type MenuScheduleQueryHookResult = ReturnType<typeof useMenuScheduleQuery>;
export type MenuScheduleLazyQueryHookResult = ReturnType<typeof useMenuScheduleLazyQuery>;
export type MenuScheduleQueryResult = Apollo.QueryResult<MenuScheduleQuery, MenuScheduleQueryVariables>;
export const MenuSchedule_SearchEventsDocument = gql`
    query MenuSchedule_SearchEvents($conferenceId: uuid!, $search: String!) {
  Event(
    where: {conferenceId: {_eq: $conferenceId}, _or: [{name: {_ilike: $search}}, {contentGroup: {_or: [{title: {_ilike: $search}}, {people: {person: {_or: [{name: {_ilike: $search}}, {affiliation: {_ilike: $search}}]}}}]}}, {eventPeople: {attendee: {displayName: {_ilike: $search}}}}, {eventTags: {tag: {name: {_ilike: $search}}}}]}
    limit: 10
    order_by: {startTime: asc}
  ) {
    ...MenuSchedule_Event
  }
}
    ${MenuSchedule_EventFragmentDoc}`;

/**
 * __useMenuSchedule_SearchEventsQuery__
 *
 * To run a query within a React component, call `useMenuSchedule_SearchEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMenuSchedule_SearchEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMenuSchedule_SearchEventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useMenuSchedule_SearchEventsQuery(baseOptions: Apollo.QueryHookOptions<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>) {
        return Apollo.useQuery<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>(MenuSchedule_SearchEventsDocument, baseOptions);
      }
export function useMenuSchedule_SearchEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>) {
          return Apollo.useLazyQuery<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>(MenuSchedule_SearchEventsDocument, baseOptions);
        }
export type MenuSchedule_SearchEventsQueryHookResult = ReturnType<typeof useMenuSchedule_SearchEventsQuery>;
export type MenuSchedule_SearchEventsLazyQueryHookResult = ReturnType<typeof useMenuSchedule_SearchEventsLazyQuery>;
export type MenuSchedule_SearchEventsQueryResult = Apollo.QueryResult<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>;
export const MainMenuSponsors_GetSponsorsDocument = gql`
    query MainMenuSponsors_GetSponsors($conferenceId: uuid!) {
  ContentGroup(
    where: {conferenceId: {_eq: $conferenceId}, contentGroupTypeName: {_eq: SPONSOR}}
    order_by: {title: asc}
  ) {
    ...MainMenuSponsors_ContentGroupData
  }
}
    ${MainMenuSponsors_ContentGroupDataFragmentDoc}`;

/**
 * __useMainMenuSponsors_GetSponsorsQuery__
 *
 * To run a query within a React component, call `useMainMenuSponsors_GetSponsorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMainMenuSponsors_GetSponsorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMainMenuSponsors_GetSponsorsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useMainMenuSponsors_GetSponsorsQuery(baseOptions: Apollo.QueryHookOptions<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>) {
        return Apollo.useQuery<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>(MainMenuSponsors_GetSponsorsDocument, baseOptions);
      }
export function useMainMenuSponsors_GetSponsorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>) {
          return Apollo.useLazyQuery<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>(MainMenuSponsors_GetSponsorsDocument, baseOptions);
        }
export type MainMenuSponsors_GetSponsorsQueryHookResult = ReturnType<typeof useMainMenuSponsors_GetSponsorsQuery>;
export type MainMenuSponsors_GetSponsorsLazyQueryHookResult = ReturnType<typeof useMainMenuSponsors_GetSponsorsLazyQuery>;
export type MainMenuSponsors_GetSponsorsQueryResult = Apollo.QueryResult<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>;
export const GetRoomMembersDocument = gql`
    subscription GetRoomMembers($roomId: uuid!) {
  RoomPerson(where: {roomId: {_eq: $roomId}}) {
    ...RoomMember
  }
}
    ${RoomMemberFragmentDoc}`;

/**
 * __useGetRoomMembersSubscription__
 *
 * To run a query within a React component, call `useGetRoomMembersSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomMembersSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomMembersSubscription({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomMembersSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetRoomMembersSubscription, GetRoomMembersSubscriptionVariables>) {
        return Apollo.useSubscription<GetRoomMembersSubscription, GetRoomMembersSubscriptionVariables>(GetRoomMembersDocument, baseOptions);
      }
export type GetRoomMembersSubscriptionHookResult = ReturnType<typeof useGetRoomMembersSubscription>;
export type GetRoomMembersSubscriptionResult = Apollo.SubscriptionResult<GetRoomMembersSubscription>;
export const GetRoomParticipantsDocument = gql`
    subscription GetRoomParticipants($conferenceId: uuid!, $roomId: uuid!) {
  RoomParticipant(
    where: {conferenceId: {_eq: $conferenceId}, roomId: {_eq: $roomId}}
  ) {
    ...RoomParticipantDetails
  }
}
    ${RoomParticipantDetailsFragmentDoc}`;

/**
 * __useGetRoomParticipantsSubscription__
 *
 * To run a query within a React component, call `useGetRoomParticipantsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomParticipantsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomParticipantsSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomParticipantsSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetRoomParticipantsSubscription, GetRoomParticipantsSubscriptionVariables>) {
        return Apollo.useSubscription<GetRoomParticipantsSubscription, GetRoomParticipantsSubscriptionVariables>(GetRoomParticipantsDocument, baseOptions);
      }
export type GetRoomParticipantsSubscriptionHookResult = ReturnType<typeof useGetRoomParticipantsSubscription>;
export type GetRoomParticipantsSubscriptionResult = Apollo.SubscriptionResult<GetRoomParticipantsSubscription>;
export const GetAllRoomParticipantsDocument = gql`
    query GetAllRoomParticipants($conferenceId: uuid!) {
  RoomParticipant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RoomParticipantDetails
  }
}
    ${RoomParticipantDetailsFragmentDoc}`;

/**
 * __useGetAllRoomParticipantsQuery__
 *
 * To run a query within a React component, call `useGetAllRoomParticipantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllRoomParticipantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllRoomParticipantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetAllRoomParticipantsQuery(baseOptions: Apollo.QueryHookOptions<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>) {
        return Apollo.useQuery<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>(GetAllRoomParticipantsDocument, baseOptions);
      }
export function useGetAllRoomParticipantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>) {
          return Apollo.useLazyQuery<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>(GetAllRoomParticipantsDocument, baseOptions);
        }
export type GetAllRoomParticipantsQueryHookResult = ReturnType<typeof useGetAllRoomParticipantsQuery>;
export type GetAllRoomParticipantsLazyQueryHookResult = ReturnType<typeof useGetAllRoomParticipantsLazyQuery>;
export type GetAllRoomParticipantsQueryResult = Apollo.QueryResult<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>;
export const MyShuffleQueueEntryDocument = gql`
    subscription MyShuffleQueueEntry($id: bigint!) {
  room_ShuffleQueueEntry_by_pk(id: $id) {
    ...SubdShuffleQueueEntryData
  }
}
    ${SubdShuffleQueueEntryDataFragmentDoc}`;

/**
 * __useMyShuffleQueueEntrySubscription__
 *
 * To run a query within a React component, call `useMyShuffleQueueEntrySubscription` and pass it any options that fit your needs.
 * When your component renders, `useMyShuffleQueueEntrySubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyShuffleQueueEntrySubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useMyShuffleQueueEntrySubscription(baseOptions: Apollo.SubscriptionHookOptions<MyShuffleQueueEntrySubscription, MyShuffleQueueEntrySubscriptionVariables>) {
        return Apollo.useSubscription<MyShuffleQueueEntrySubscription, MyShuffleQueueEntrySubscriptionVariables>(MyShuffleQueueEntryDocument, baseOptions);
      }
export type MyShuffleQueueEntrySubscriptionHookResult = ReturnType<typeof useMyShuffleQueueEntrySubscription>;
export type MyShuffleQueueEntrySubscriptionResult = Apollo.SubscriptionResult<MyShuffleQueueEntrySubscription>;
export const GetShuffleRoomDocument = gql`
    query GetShuffleRoom($id: bigint!) {
  room_ShuffleRoom_by_pk(id: $id) {
    id
    roomId
  }
}
    `;

/**
 * __useGetShuffleRoomQuery__
 *
 * To run a query within a React component, call `useGetShuffleRoomQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetShuffleRoomQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetShuffleRoomQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetShuffleRoomQuery(baseOptions: Apollo.QueryHookOptions<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>) {
        return Apollo.useQuery<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>(GetShuffleRoomDocument, baseOptions);
      }
export function useGetShuffleRoomLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>) {
          return Apollo.useLazyQuery<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>(GetShuffleRoomDocument, baseOptions);
        }
export type GetShuffleRoomQueryHookResult = ReturnType<typeof useGetShuffleRoomQuery>;
export type GetShuffleRoomLazyQueryHookResult = ReturnType<typeof useGetShuffleRoomLazyQuery>;
export type GetShuffleRoomQueryResult = Apollo.QueryResult<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>;
export const ShufflePeriodsDocument = gql`
    query ShufflePeriods($conferenceId: uuid!, $start: timestamptz!, $end: timestamptz!) {
  room_ShufflePeriod(
    where: {conferenceId: {_eq: $conferenceId}, startAt: {_lte: $start}, endAt: {_gte: $end}}
  ) {
    ...ShufflePeriodData
  }
}
    ${ShufflePeriodDataFragmentDoc}`;

/**
 * __useShufflePeriodsQuery__
 *
 * To run a query within a React component, call `useShufflePeriodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useShufflePeriodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useShufflePeriodsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      start: // value for 'start'
 *      end: // value for 'end'
 *   },
 * });
 */
export function useShufflePeriodsQuery(baseOptions: Apollo.QueryHookOptions<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>) {
        return Apollo.useQuery<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>(ShufflePeriodsDocument, baseOptions);
      }
export function useShufflePeriodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>) {
          return Apollo.useLazyQuery<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>(ShufflePeriodsDocument, baseOptions);
        }
export type ShufflePeriodsQueryHookResult = ReturnType<typeof useShufflePeriodsQuery>;
export type ShufflePeriodsLazyQueryHookResult = ReturnType<typeof useShufflePeriodsLazyQuery>;
export type ShufflePeriodsQueryResult = Apollo.QueryResult<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>;
export const JoinShuffleQueueDocument = gql`
    mutation JoinShuffleQueue($shufflePeriodId: uuid!, $attendeeId: uuid!) {
  insert_room_ShuffleQueueEntry_one(
    object: {attendeeId: $attendeeId, shufflePeriodId: $shufflePeriodId}
  ) {
    ...PrefetchShuffleQueueEntryData
  }
}
    ${PrefetchShuffleQueueEntryDataFragmentDoc}`;
export type JoinShuffleQueueMutationFn = Apollo.MutationFunction<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>;

/**
 * __useJoinShuffleQueueMutation__
 *
 * To run a mutation, you first call `useJoinShuffleQueueMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinShuffleQueueMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinShuffleQueueMutation, { data, loading, error }] = useJoinShuffleQueueMutation({
 *   variables: {
 *      shufflePeriodId: // value for 'shufflePeriodId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useJoinShuffleQueueMutation(baseOptions?: Apollo.MutationHookOptions<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>) {
        return Apollo.useMutation<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>(JoinShuffleQueueDocument, baseOptions);
      }
export type JoinShuffleQueueMutationHookResult = ReturnType<typeof useJoinShuffleQueueMutation>;
export type JoinShuffleQueueMutationResult = Apollo.MutationResult<JoinShuffleQueueMutation>;
export type JoinShuffleQueueMutationOptions = Apollo.BaseMutationOptions<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>;
export const GetShuffleRoomsParticipantsCountDocument = gql`
    query GetShuffleRoomsParticipantsCount($conferenceId: uuid!) {
  RoomParticipant_aggregate(
    where: {conferenceId: {_eq: $conferenceId}, room: {shuffleRooms: {isEnded: {_eq: false}}}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetShuffleRoomsParticipantsCountQuery__
 *
 * To run a query within a React component, call `useGetShuffleRoomsParticipantsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetShuffleRoomsParticipantsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetShuffleRoomsParticipantsCountQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetShuffleRoomsParticipantsCountQuery(baseOptions: Apollo.QueryHookOptions<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>) {
        return Apollo.useQuery<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>(GetShuffleRoomsParticipantsCountDocument, baseOptions);
      }
export function useGetShuffleRoomsParticipantsCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>) {
          return Apollo.useLazyQuery<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>(GetShuffleRoomsParticipantsCountDocument, baseOptions);
        }
export type GetShuffleRoomsParticipantsCountQueryHookResult = ReturnType<typeof useGetShuffleRoomsParticipantsCountQuery>;
export type GetShuffleRoomsParticipantsCountLazyQueryHookResult = ReturnType<typeof useGetShuffleRoomsParticipantsCountLazyQuery>;
export type GetShuffleRoomsParticipantsCountQueryResult = Apollo.QueryResult<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>;
export const SelectCurrentUserDocument = gql`
    query SelectCurrentUser($userId: String!) {
  User_by_pk(id: $userId) {
    id
    email
    lastName
    firstName
    attendees {
      ...AttendeeFields
    }
  }
}
    ${AttendeeFieldsFragmentDoc}`;

/**
 * __useSelectCurrentUserQuery__
 *
 * To run a query within a React component, call `useSelectCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectCurrentUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSelectCurrentUserQuery(baseOptions: Apollo.QueryHookOptions<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>) {
        return Apollo.useQuery<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>(SelectCurrentUserDocument, baseOptions);
      }
export function useSelectCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>) {
          return Apollo.useLazyQuery<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>(SelectCurrentUserDocument, baseOptions);
        }
export type SelectCurrentUserQueryHookResult = ReturnType<typeof useSelectCurrentUserQuery>;
export type SelectCurrentUserLazyQueryHookResult = ReturnType<typeof useSelectCurrentUserLazyQuery>;
export type SelectCurrentUserQueryResult = Apollo.QueryResult<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>;
export const GetCurrentUserIsIncognitoDocument = gql`
    query getCurrentUserIsIncognito($userId: String!) {
  OnlineStatus(where: {userId: {_eq: $userId}}) {
    id
    isIncognito
  }
}
    `;

/**
 * __useGetCurrentUserIsIncognitoQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserIsIncognitoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserIsIncognitoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserIsIncognitoQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetCurrentUserIsIncognitoQuery(baseOptions: Apollo.QueryHookOptions<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>) {
        return Apollo.useQuery<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>(GetCurrentUserIsIncognitoDocument, baseOptions);
      }
export function useGetCurrentUserIsIncognitoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>) {
          return Apollo.useLazyQuery<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>(GetCurrentUserIsIncognitoDocument, baseOptions);
        }
export type GetCurrentUserIsIncognitoQueryHookResult = ReturnType<typeof useGetCurrentUserIsIncognitoQuery>;
export type GetCurrentUserIsIncognitoLazyQueryHookResult = ReturnType<typeof useGetCurrentUserIsIncognitoLazyQuery>;
export type GetCurrentUserIsIncognitoQueryResult = Apollo.QueryResult<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>;
export const UpdateCurrentUserIsIncognitoDocument = gql`
    mutation updateCurrentUserIsIncognito($userId: String!, $isIncognito: Boolean = false) {
  update_OnlineStatus(
    _set: {isIncognito: $isIncognito}
    where: {userId: {_eq: $userId}}
  ) {
    returning {
      id
      isIncognito
    }
  }
}
    `;
export type UpdateCurrentUserIsIncognitoMutationFn = Apollo.MutationFunction<UpdateCurrentUserIsIncognitoMutation, UpdateCurrentUserIsIncognitoMutationVariables>;

/**
 * __useUpdateCurrentUserIsIncognitoMutation__
 *
 * To run a mutation, you first call `useUpdateCurrentUserIsIncognitoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCurrentUserIsIncognitoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCurrentUserIsIncognitoMutation, { data, loading, error }] = useUpdateCurrentUserIsIncognitoMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      isIncognito: // value for 'isIncognito'
 *   },
 * });
 */
export function useUpdateCurrentUserIsIncognitoMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCurrentUserIsIncognitoMutation, UpdateCurrentUserIsIncognitoMutationVariables>) {
        return Apollo.useMutation<UpdateCurrentUserIsIncognitoMutation, UpdateCurrentUserIsIncognitoMutationVariables>(UpdateCurrentUserIsIncognitoDocument, baseOptions);
      }
export type UpdateCurrentUserIsIncognitoMutationHookResult = ReturnType<typeof useUpdateCurrentUserIsIncognitoMutation>;
export type UpdateCurrentUserIsIncognitoMutationResult = Apollo.MutationResult<UpdateCurrentUserIsIncognitoMutation>;
export type UpdateCurrentUserIsIncognitoMutationOptions = Apollo.BaseMutationOptions<UpdateCurrentUserIsIncognitoMutation, UpdateCurrentUserIsIncognitoMutationVariables>;
export const GetCurrentUserLastSeenDocument = gql`
    query getCurrentUserLastSeen($userId: String!) {
  OnlineStatus(where: {userId: {_eq: $userId}}) {
    id
    lastSeen
  }
}
    `;

/**
 * __useGetCurrentUserLastSeenQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserLastSeenQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserLastSeenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserLastSeenQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetCurrentUserLastSeenQuery(baseOptions: Apollo.QueryHookOptions<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>) {
        return Apollo.useQuery<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>(GetCurrentUserLastSeenDocument, baseOptions);
      }
export function useGetCurrentUserLastSeenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>) {
          return Apollo.useLazyQuery<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>(GetCurrentUserLastSeenDocument, baseOptions);
        }
export type GetCurrentUserLastSeenQueryHookResult = ReturnType<typeof useGetCurrentUserLastSeenQuery>;
export type GetCurrentUserLastSeenLazyQueryHookResult = ReturnType<typeof useGetCurrentUserLastSeenLazyQuery>;
export type GetCurrentUserLastSeenQueryResult = Apollo.QueryResult<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>;
export const InsertCurrentUserOnlineStatusDocument = gql`
    mutation insertCurrentUserOnlineStatus($userId: String!) {
  insert_OnlineStatus(objects: {userId: $userId, isIncognito: false}) {
    returning {
      id
      isIncognito
      lastSeen
      userId
    }
  }
}
    `;
export type InsertCurrentUserOnlineStatusMutationFn = Apollo.MutationFunction<InsertCurrentUserOnlineStatusMutation, InsertCurrentUserOnlineStatusMutationVariables>;

/**
 * __useInsertCurrentUserOnlineStatusMutation__
 *
 * To run a mutation, you first call `useInsertCurrentUserOnlineStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertCurrentUserOnlineStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertCurrentUserOnlineStatusMutation, { data, loading, error }] = useInsertCurrentUserOnlineStatusMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInsertCurrentUserOnlineStatusMutation(baseOptions?: Apollo.MutationHookOptions<InsertCurrentUserOnlineStatusMutation, InsertCurrentUserOnlineStatusMutationVariables>) {
        return Apollo.useMutation<InsertCurrentUserOnlineStatusMutation, InsertCurrentUserOnlineStatusMutationVariables>(InsertCurrentUserOnlineStatusDocument, baseOptions);
      }
export type InsertCurrentUserOnlineStatusMutationHookResult = ReturnType<typeof useInsertCurrentUserOnlineStatusMutation>;
export type InsertCurrentUserOnlineStatusMutationResult = Apollo.MutationResult<InsertCurrentUserOnlineStatusMutation>;
export type InsertCurrentUserOnlineStatusMutationOptions = Apollo.BaseMutationOptions<InsertCurrentUserOnlineStatusMutation, InsertCurrentUserOnlineStatusMutationVariables>;
export const UpdateCurrentUserLastSeenDocument = gql`
    mutation updateCurrentUserLastSeen($userId: String!, $lastSeen: timestamptz) {
  update_OnlineStatus(
    _set: {lastSeen: $lastSeen}
    where: {userId: {_eq: $userId}}
  ) {
    returning {
      id
      lastSeen
    }
  }
}
    `;
export type UpdateCurrentUserLastSeenMutationFn = Apollo.MutationFunction<UpdateCurrentUserLastSeenMutation, UpdateCurrentUserLastSeenMutationVariables>;

/**
 * __useUpdateCurrentUserLastSeenMutation__
 *
 * To run a mutation, you first call `useUpdateCurrentUserLastSeenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCurrentUserLastSeenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCurrentUserLastSeenMutation, { data, loading, error }] = useUpdateCurrentUserLastSeenMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      lastSeen: // value for 'lastSeen'
 *   },
 * });
 */
export function useUpdateCurrentUserLastSeenMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCurrentUserLastSeenMutation, UpdateCurrentUserLastSeenMutationVariables>) {
        return Apollo.useMutation<UpdateCurrentUserLastSeenMutation, UpdateCurrentUserLastSeenMutationVariables>(UpdateCurrentUserLastSeenDocument, baseOptions);
      }
export type UpdateCurrentUserLastSeenMutationHookResult = ReturnType<typeof useUpdateCurrentUserLastSeenMutation>;
export type UpdateCurrentUserLastSeenMutationResult = Apollo.MutationResult<UpdateCurrentUserLastSeenMutation>;
export type UpdateCurrentUserLastSeenMutationOptions = Apollo.BaseMutationOptions<UpdateCurrentUserLastSeenMutation, UpdateCurrentUserLastSeenMutationVariables>;